CCS PCM C Compiler, Version 5.025, 54110               23-Jul-20 02:21

               Filename:   C:\Users\Admin\Desktop\DoAnXuLyTin\color_sensor.lst

               ROM used:   3220 words (39%)
                           Largest free fragment is 2048
               RAM used:   75 (20%) at main() level
                           144 (39%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   310
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   05C
002B:  BTFSS  0B.4
002C:  GOTO   02F
002D:  BTFSC  0B.1
002E:  GOTO   05F
002F:  MOVLW  8C
0030:  MOVWF  04
0031:  BTFSS  00.5
0032:  GOTO   035
0033:  BTFSC  0C.5
0034:  GOTO   062
0035:  MOVLW  8C
0036:  MOVWF  04
0037:  BTFSS  00.0
0038:  GOTO   03B
0039:  BTFSC  0C.0
003A:  GOTO   065
003B:  MOVF   22,W
003C:  MOVWF  04
003D:  MOVF   23,W
003E:  MOVWF  77
003F:  MOVF   24,W
0040:  MOVWF  78
0041:  MOVF   25,W
0042:  MOVWF  79
0043:  MOVF   26,W
0044:  MOVWF  7A
0045:  MOVF   27,W
0046:  BSF    03.6
0047:  MOVWF  0D
0048:  BCF    03.6
0049:  MOVF   28,W
004A:  BSF    03.6
004B:  MOVWF  0F
004C:  BCF    03.6
004D:  MOVF   29,W
004E:  BSF    03.6
004F:  MOVWF  0C
0050:  BCF    03.6
0051:  MOVF   2A,W
0052:  BSF    03.6
0053:  MOVWF  0E
0054:  BCF    03.6
0055:  MOVF   20,W
0056:  MOVWF  0A
0057:  SWAPF  21,W
0058:  MOVWF  03
0059:  SWAPF  7F,F
005A:  SWAPF  7F,W
005B:  RETFIE
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   1D1
005F:  BCF    0A.3
0060:  BCF    0A.4
0061:  GOTO   1AE
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   34D
0065:  BCF    0A.3
0066:  BCF    0A.4
0067:  GOTO   207
.................... #include <color_sensor.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0068:  MOVLW  80
0069:  BTFSS  03.1
006A:  GOTO   06E
006B:  BSF    03.5
006C:  XORWF  45,F
006D:  BCF    03.5
006E:  BSF    03.5
006F:  CLRF   4A
0070:  CLRF   4B
0071:  MOVF   41,W
0072:  MOVWF  49
0073:  MOVF   45,W
0074:  XORWF  49,F
0075:  MOVF   40,W
0076:  BTFSC  03.2
0077:  GOTO   15C
0078:  MOVWF  48
0079:  MOVWF  77
007A:  MOVF   44,W
007B:  BTFSC  03.2
007C:  GOTO   165
007D:  SUBWF  48,F
007E:  BTFSC  03.2
007F:  GOTO   101
0080:  BTFSS  03.0
0081:  GOTO   0BF
0082:  MOVF   45,W
0083:  MOVWF  4E
0084:  BSF    4E.7
0085:  MOVF   46,W
0086:  MOVWF  4D
0087:  MOVF   47,W
0088:  MOVWF  4C
0089:  CLRF   4B
008A:  BCF    03.0
008B:  RRF    4E,F
008C:  RRF    4D,F
008D:  RRF    4C,F
008E:  RRF    4B,F
008F:  DECFSZ 48,F
0090:  GOTO   089
0091:  BTFSS  49.7
0092:  GOTO   096
0093:  BSF    4A.0
0094:  GOTO   179
0095:  BCF    4A.0
0096:  BCF    48.0
0097:  BSF    4A.4
0098:  MOVLW  C3
0099:  MOVWF  04
009A:  BCF    03.7
009B:  GOTO   18E
009C:  BCF    4A.4
009D:  BTFSC  49.7
009E:  GOTO   0A9
009F:  BTFSS  48.0
00A0:  GOTO   0B4
00A1:  RRF    4E,F
00A2:  RRF    4D,F
00A3:  RRF    4C,F
00A4:  RRF    4B,F
00A5:  INCF   77,F
00A6:  BTFSC  03.2
00A7:  GOTO   174
00A8:  GOTO   0B4
00A9:  BTFSC  4E.7
00AA:  GOTO   0B7
00AB:  BCF    03.0
00AC:  RLF    4B,F
00AD:  RLF    4C,F
00AE:  RLF    4D,F
00AF:  RLF    4E,F
00B0:  DECF   77,F
00B1:  BTFSC  03.2
00B2:  GOTO   174
00B3:  GOTO   0A9
00B4:  BSF    4A.6
00B5:  GOTO   121
00B6:  BCF    4A.6
00B7:  MOVF   41,W
00B8:  MOVWF  49
00B9:  BTFSS  49.7
00BA:  GOTO   0BD
00BB:  BSF    4E.7
00BC:  GOTO   16D
00BD:  BCF    4E.7
00BE:  GOTO   16D
00BF:  MOVF   44,W
00C0:  MOVWF  48
00C1:  MOVWF  77
00C2:  MOVF   40,W
00C3:  SUBWF  48,F
00C4:  MOVF   41,W
00C5:  MOVWF  4E
00C6:  BSF    4E.7
00C7:  MOVF   42,W
00C8:  MOVWF  4D
00C9:  MOVF   43,W
00CA:  MOVWF  4C
00CB:  CLRF   4B
00CC:  BCF    03.0
00CD:  RRF    4E,F
00CE:  RRF    4D,F
00CF:  RRF    4C,F
00D0:  RRF    4B,F
00D1:  DECFSZ 48,F
00D2:  GOTO   0CB
00D3:  BTFSS  49.7
00D4:  GOTO   0D8
00D5:  BSF    4A.1
00D6:  GOTO   179
00D7:  BCF    4A.1
00D8:  BCF    48.0
00D9:  BSF    4A.5
00DA:  MOVLW  C7
00DB:  MOVWF  04
00DC:  BCF    03.7
00DD:  GOTO   18E
00DE:  BCF    4A.5
00DF:  BTFSC  49.7
00E0:  GOTO   0EB
00E1:  BTFSS  48.0
00E2:  GOTO   0F6
00E3:  RRF    4E,F
00E4:  RRF    4D,F
00E5:  RRF    4C,F
00E6:  RRF    4B,F
00E7:  INCF   77,F
00E8:  BTFSC  03.2
00E9:  GOTO   174
00EA:  GOTO   0F6
00EB:  BTFSC  4E.7
00EC:  GOTO   0F9
00ED:  BCF    03.0
00EE:  RLF    4B,F
00EF:  RLF    4C,F
00F0:  RLF    4D,F
00F1:  RLF    4E,F
00F2:  DECF   77,F
00F3:  BTFSC  03.2
00F4:  GOTO   174
00F5:  GOTO   0EB
00F6:  BSF    4A.7
00F7:  GOTO   121
00F8:  BCF    4A.7
00F9:  MOVF   45,W
00FA:  MOVWF  49
00FB:  BTFSS  49.7
00FC:  GOTO   0FF
00FD:  BSF    4E.7
00FE:  GOTO   16D
00FF:  BCF    4E.7
0100:  GOTO   16D
0101:  MOVF   45,W
0102:  MOVWF  4E
0103:  BSF    4E.7
0104:  MOVF   46,W
0105:  MOVWF  4D
0106:  MOVF   47,W
0107:  MOVWF  4C
0108:  BTFSS  49.7
0109:  GOTO   10E
010A:  BCF    4E.7
010B:  BSF    4A.2
010C:  GOTO   179
010D:  BCF    4A.2
010E:  CLRF   4B
010F:  BCF    48.0
0110:  MOVLW  C3
0111:  MOVWF  04
0112:  BCF    03.7
0113:  GOTO   18E
0114:  BTFSC  49.7
0115:  GOTO   137
0116:  MOVF   41,W
0117:  MOVWF  49
0118:  BTFSS  48.0
0119:  GOTO   121
011A:  RRF    4E,F
011B:  RRF    4D,F
011C:  RRF    4C,F
011D:  RRF    4B,F
011E:  INCF   77,F
011F:  BTFSC  03.2
0120:  GOTO   174
0121:  BTFSS  4B.7
0122:  GOTO   132
0123:  INCF   4C,F
0124:  BTFSS  03.2
0125:  GOTO   132
0126:  INCF   4D,F
0127:  BTFSS  03.2
0128:  GOTO   132
0129:  INCF   4E,F
012A:  BTFSS  03.2
012B:  GOTO   132
012C:  RRF    4E,F
012D:  RRF    4D,F
012E:  RRF    4C,F
012F:  INCF   77,F
0130:  BTFSC  03.2
0131:  GOTO   174
0132:  BTFSC  4A.6
0133:  GOTO   0B6
0134:  BTFSC  4A.7
0135:  GOTO   0F8
0136:  GOTO   156
0137:  MOVLW  80
0138:  XORWF  4E,F
0139:  BTFSS  4E.7
013A:  GOTO   13F
013B:  GOTO   179
013C:  MOVF   45,W
013D:  MOVWF  49
013E:  GOTO   14C
013F:  MOVF   41,W
0140:  MOVWF  49
0141:  MOVF   4E,F
0142:  BTFSS  03.2
0143:  GOTO   14C
0144:  MOVF   4D,F
0145:  BTFSS  03.2
0146:  GOTO   14C
0147:  MOVF   4C,F
0148:  BTFSS  03.2
0149:  GOTO   14C
014A:  CLRF   77
014B:  GOTO   16D
014C:  BTFSC  4E.7
014D:  GOTO   156
014E:  BCF    03.0
014F:  RLF    4B,F
0150:  RLF    4C,F
0151:  RLF    4D,F
0152:  RLF    4E,F
0153:  DECFSZ 77,F
0154:  GOTO   14C
0155:  GOTO   174
0156:  BTFSS  49.7
0157:  GOTO   15A
0158:  BSF    4E.7
0159:  GOTO   16D
015A:  BCF    4E.7
015B:  GOTO   16D
015C:  MOVF   44,W
015D:  MOVWF  77
015E:  MOVF   45,W
015F:  MOVWF  4E
0160:  MOVF   46,W
0161:  MOVWF  4D
0162:  MOVF   47,W
0163:  MOVWF  4C
0164:  GOTO   16D
0165:  MOVF   40,W
0166:  MOVWF  77
0167:  MOVF   41,W
0168:  MOVWF  4E
0169:  MOVF   42,W
016A:  MOVWF  4D
016B:  MOVF   43,W
016C:  MOVWF  4C
016D:  MOVF   4E,W
016E:  MOVWF  78
016F:  MOVF   4D,W
0170:  MOVWF  79
0171:  MOVF   4C,W
0172:  MOVWF  7A
0173:  GOTO   1AC
0174:  CLRF   77
0175:  CLRF   78
0176:  CLRF   79
0177:  CLRF   7A
0178:  GOTO   1AC
0179:  CLRF   4B
017A:  COMF   4C,F
017B:  COMF   4D,F
017C:  COMF   4E,F
017D:  COMF   4B,F
017E:  INCF   4B,F
017F:  BTFSS  03.2
0180:  GOTO   187
0181:  INCF   4C,F
0182:  BTFSS  03.2
0183:  GOTO   187
0184:  INCF   4D,F
0185:  BTFSC  03.2
0186:  INCF   4E,F
0187:  BTFSC  4A.0
0188:  GOTO   095
0189:  BTFSC  4A.1
018A:  GOTO   0D7
018B:  BTFSC  4A.2
018C:  GOTO   10D
018D:  GOTO   13C
018E:  MOVF   00,W
018F:  ADDWF  4C,F
0190:  BTFSS  03.0
0191:  GOTO   198
0192:  INCF   4D,F
0193:  BTFSS  03.2
0194:  GOTO   198
0195:  INCF   4E,F
0196:  BTFSC  03.2
0197:  BSF    48.0
0198:  DECF   04,F
0199:  MOVF   00,W
019A:  ADDWF  4D,F
019B:  BTFSS  03.0
019C:  GOTO   1A0
019D:  INCF   4E,F
019E:  BTFSC  03.2
019F:  BSF    48.0
01A0:  DECF   04,F
01A1:  MOVF   00,W
01A2:  BTFSS  00.7
01A3:  XORLW  80
01A4:  ADDWF  4E,F
01A5:  BTFSC  03.0
01A6:  BSF    48.0
01A7:  BTFSC  4A.4
01A8:  GOTO   09C
01A9:  BTFSC  4A.5
01AA:  GOTO   0DE
01AB:  GOTO   114
01AC:  BCF    03.5
01AD:  RETURN
*
0243:  BCF    0A.0
0244:  BSF    0A.1
0245:  BCF    0A.2
0246:  ADDWF  02,F
0247:  GOTO   20D
0248:  GOTO   213
0249:  GOTO   222
024A:  GOTO   231
*
02BA:  CLRF   77
02BB:  CLRF   78
02BC:  MOVF   47,W
02BD:  BCF    03.0
02BE:  BTFSC  48.0
02BF:  ADDWF  77,F
02C0:  RRF    77,F
02C1:  RRF    78,F
02C2:  BTFSC  48.1
02C3:  ADDWF  77,F
02C4:  RRF    77,F
02C5:  RRF    78,F
02C6:  BTFSC  48.2
02C7:  ADDWF  77,F
02C8:  RRF    77,F
02C9:  RRF    78,F
02CA:  BTFSC  48.3
02CB:  ADDWF  77,F
02CC:  RRF    77,F
02CD:  RRF    78,F
02CE:  BTFSC  48.4
02CF:  ADDWF  77,F
02D0:  RRF    77,F
02D1:  RRF    78,F
02D2:  BTFSC  48.5
02D3:  ADDWF  77,F
02D4:  RRF    77,F
02D5:  RRF    78,F
02D6:  BTFSC  48.6
02D7:  ADDWF  77,F
02D8:  RRF    77,F
02D9:  RRF    78,F
02DA:  BTFSC  48.7
02DB:  ADDWF  77,F
02DC:  RRF    77,F
02DD:  RRF    78,F
*
0353:  MOVF   78,W
0354:  BTFSC  03.2
0355:  GOTO   35B
0356:  MOVF   77,W
0357:  MOVWF  00
0358:  INCF   04,F
0359:  DECFSZ 78,F
035A:  GOTO   356
*
03C1:  DATA 0C,00
03C2:  DATA 53,2A
03C3:  DATA 4F,28
03C4:  DATA 50,10
03C5:  DATA A1,10
03C6:  DATA 21,00
03C7:  DATA 0C,00
03C8:  DATA 52,22
03C9:  DATA 20,10
03CA:  DATA 20,21
03CB:  DATA 4C,10
03CC:  DATA A0,23
03CD:  DATA 52,10
03CE:  DATA 00,01
03CF:  DATA 20,10
03D0:  DATA 20,10
03D1:  DATA CD,20
03D2:  DATA 43,24
03D3:  DATA 20,22
03D4:  DATA C5,26
03D5:  DATA A0,29
03D6:  DATA 50,00
03D7:  DATA 20,10
03D8:  DATA C3,20
03D9:  DATA 4D,10
03DA:  DATA C2,24
03DB:  DATA 45,27
03DC:  DATA A0,26
03DD:  DATA C1,2A
03DE:  DATA 00,00
*
056E:  MOVF   0B,W
056F:  MOVWF  65
0570:  BCF    0B.7
0571:  BSF    03.5
0572:  BSF    03.6
0573:  BSF    0C.7
0574:  BSF    0C.0
0575:  NOP
0576:  NOP
0577:  BCF    03.5
0578:  BCF    03.6
0579:  BTFSC  65.7
057A:  BSF    0B.7
057B:  BSF    03.6
057C:  MOVF   0C,W
057D:  ANDLW  7F
057E:  BTFSC  03.2
057F:  GOTO   5C2
0580:  BCF    03.6
0581:  MOVWF  65
0582:  BSF    03.6
0583:  MOVF   0D,W
0584:  BCF    03.6
0585:  MOVWF  66
0586:  BSF    03.6
0587:  MOVF   0F,W
0588:  BCF    03.6
0589:  MOVWF  67
058A:  MOVF   65,W
058B:  MOVWF  68
058C:  CALL   542
058D:  MOVF   66,W
058E:  BSF    03.6
058F:  MOVWF  0D
0590:  BCF    03.6
0591:  MOVF   67,W
0592:  BSF    03.6
0593:  MOVWF  0F
0594:  BCF    03.6
0595:  MOVF   0B,W
0596:  MOVWF  68
0597:  BCF    0B.7
0598:  BSF    03.5
0599:  BSF    03.6
059A:  BSF    0C.7
059B:  BSF    0C.0
059C:  NOP
059D:  NOP
059E:  BCF    03.5
059F:  BCF    03.6
05A0:  BTFSC  68.7
05A1:  BSF    0B.7
05A2:  BSF    03.6
05A3:  RLF    0C,W
05A4:  RLF    0E,W
05A5:  ANDLW  7F
05A6:  BTFSC  03.2
05A7:  GOTO   5C2
05A8:  BCF    03.6
05A9:  MOVWF  65
05AA:  BSF    03.6
05AB:  MOVF   0D,W
05AC:  BCF    03.6
05AD:  MOVWF  66
05AE:  BSF    03.6
05AF:  MOVF   0F,W
05B0:  BCF    03.6
05B1:  MOVWF  67
05B2:  MOVF   65,W
05B3:  MOVWF  68
05B4:  CALL   542
05B5:  MOVF   66,W
05B6:  BSF    03.6
05B7:  MOVWF  0D
05B8:  BCF    03.6
05B9:  MOVF   67,W
05BA:  BSF    03.6
05BB:  MOVWF  0F
05BC:  INCF   0D,F
05BD:  BTFSC  03.2
05BE:  INCF   0F,F
05BF:  BCF    03.6
05C0:  GOTO   56E
05C1:  BSF    03.6
05C2:  BCF    03.6
05C3:  RETURN
05C4:  MOVF   6C,W
05C5:  CLRF   78
05C6:  SUBWF  6B,W
05C7:  BTFSC  03.0
05C8:  GOTO   5CC
05C9:  MOVF   6B,W
05CA:  MOVWF  77
05CB:  GOTO   5D8
05CC:  CLRF   77
05CD:  MOVLW  08
05CE:  MOVWF  6D
05CF:  RLF    6B,F
05D0:  RLF    77,F
05D1:  MOVF   6C,W
05D2:  SUBWF  77,W
05D3:  BTFSC  03.0
05D4:  MOVWF  77
05D5:  RLF    78,F
05D6:  DECFSZ 6D,F
05D7:  GOTO   5CF
05D8:  RETURN
05D9:  MOVLW  20
05DA:  BTFSS  66.4
05DB:  MOVLW  30
05DC:  MOVWF  67
05DD:  MOVF   65,W
05DE:  MOVWF  77
05DF:  BTFSS  65.7
05E0:  GOTO   5E9
05E1:  COMF   77,F
05E2:  INCF   77,F
05E3:  MOVF   77,W
05E4:  MOVWF  65
05E5:  MOVLW  2D
05E6:  MOVWF  67
05E7:  BSF    66.7
05E8:  BSF    66.0
05E9:  MOVF   65,W
05EA:  MOVWF  6B
05EB:  MOVLW  64
05EC:  MOVWF  6C
05ED:  CALL   5C4
05EE:  MOVF   77,W
05EF:  MOVWF  65
05F0:  MOVLW  30
05F1:  ADDWF  78,W
05F2:  MOVWF  68
05F3:  MOVF   65,W
05F4:  MOVWF  6B
05F5:  MOVLW  0A
05F6:  MOVWF  6C
05F7:  CALL   5C4
05F8:  MOVLW  30
05F9:  ADDWF  77,W
05FA:  MOVWF  6A
05FB:  MOVLW  30
05FC:  ADDWF  78,W
05FD:  MOVWF  69
05FE:  MOVF   67,W
05FF:  MOVWF  77
0600:  MOVLW  30
0601:  SUBWF  68,W
0602:  BTFSC  03.2
0603:  GOTO   608
0604:  BSF    66.1
0605:  BTFSC  66.7
0606:  BSF    66.2
0607:  GOTO   61C
0608:  MOVF   67,W
0609:  MOVWF  68
060A:  MOVLW  20
060B:  MOVWF  67
060C:  MOVLW  30
060D:  SUBWF  69,W
060E:  BTFSC  03.2
060F:  GOTO   614
0610:  BSF    66.0
0611:  BTFSC  66.7
0612:  BSF    66.1
0613:  GOTO   61C
0614:  BTFSS  03.2
0615:  BSF    66.0
0616:  BTFSS  03.2
0617:  GOTO   61C
0618:  MOVF   68,W
0619:  MOVWF  69
061A:  MOVLW  20
061B:  MOVWF  68
061C:  BTFSC  66.2
061D:  GOTO   623
061E:  BTFSC  66.1
061F:  GOTO   627
0620:  BTFSC  66.0
0621:  GOTO   62B
0622:  GOTO   62F
0623:  MOVF   67,W
0624:  BTFSS  0C.4
0625:  GOTO   624
0626:  MOVWF  19
0627:  MOVF   68,W
0628:  BTFSS  0C.4
0629:  GOTO   628
062A:  MOVWF  19
062B:  MOVF   69,W
062C:  BTFSS  0C.4
062D:  GOTO   62C
062E:  MOVWF  19
062F:  MOVF   6A,W
0630:  BTFSS  0C.4
0631:  GOTO   630
0632:  MOVWF  19
0633:  RETURN
0634:  MOVF   66,W
0635:  MOVWF  6D
0636:  MOVF   6A,W
0637:  XORWF  6D,F
0638:  BTFSS  6D.7
0639:  GOTO   63F
063A:  BCF    03.2
063B:  BCF    03.0
063C:  BTFSC  66.7
063D:  BSF    03.0
063E:  GOTO   672
063F:  MOVF   66,W
0640:  MOVWF  6D
0641:  MOVF   69,W
0642:  MOVWF  6E
0643:  MOVF   65,W
0644:  SUBWF  6E,F
0645:  BTFSC  03.2
0646:  GOTO   64D
0647:  BTFSS  6D.7
0648:  GOTO   672
0649:  MOVF   03,W
064A:  XORLW  01
064B:  MOVWF  03
064C:  GOTO   672
064D:  MOVF   6A,W
064E:  MOVWF  6E
064F:  MOVF   66,W
0650:  SUBWF  6E,F
0651:  BTFSC  03.2
0652:  GOTO   659
0653:  BTFSS  6D.7
0654:  GOTO   672
0655:  MOVF   03,W
0656:  XORLW  01
0657:  MOVWF  03
0658:  GOTO   672
0659:  MOVF   6B,W
065A:  MOVWF  6E
065B:  MOVF   67,W
065C:  SUBWF  6E,F
065D:  BTFSC  03.2
065E:  GOTO   665
065F:  BTFSS  6D.7
0660:  GOTO   672
0661:  MOVF   03,W
0662:  XORLW  01
0663:  MOVWF  03
0664:  GOTO   672
0665:  MOVF   6C,W
0666:  MOVWF  6E
0667:  MOVF   68,W
0668:  SUBWF  6E,F
0669:  BTFSC  03.2
066A:  GOTO   671
066B:  BTFSS  6D.7
066C:  GOTO   672
066D:  MOVF   03,W
066E:  XORLW  01
066F:  MOVWF  03
0670:  GOTO   672
0671:  BCF    03.0
0672:  RETURN
*
0804:  MOVLW  8E
0805:  MOVWF  77
0806:  MOVF   6B,W
0807:  MOVWF  78
0808:  MOVF   6A,W
0809:  MOVWF  79
080A:  CLRF   7A
080B:  MOVF   78,F
080C:  BTFSS  03.2
080D:  GOTO   018
080E:  MOVF   79,W
080F:  MOVWF  78
0810:  CLRF   79
0811:  MOVLW  08
0812:  SUBWF  77,F
0813:  MOVF   78,F
0814:  BTFSS  03.2
0815:  GOTO   018
0816:  CLRF   77
0817:  GOTO   020
0818:  BCF    03.0
0819:  BTFSC  78.7
081A:  GOTO   01F
081B:  RLF    79,F
081C:  RLF    78,F
081D:  DECF   77,F
081E:  GOTO   018
081F:  BCF    78.7
*
089C:  MOVF   30,W
089D:  BTFSC  03.2
089E:  GOTO   161
089F:  MOVWF  3C
08A0:  MOVF   34,W
08A1:  BTFSC  03.2
08A2:  GOTO   161
08A3:  SUBWF  3C,F
08A4:  BTFSS  03.0
08A5:  GOTO   0AB
08A6:  MOVLW  7F
08A7:  ADDWF  3C,F
08A8:  BTFSC  03.0
08A9:  GOTO   161
08AA:  GOTO   0B1
08AB:  MOVLW  81
08AC:  SUBWF  3C,F
08AD:  BTFSS  03.0
08AE:  GOTO   161
08AF:  BTFSC  03.2
08B0:  GOTO   161
08B1:  MOVF   3C,W
08B2:  MOVWF  77
08B3:  CLRF   78
08B4:  CLRF   79
08B5:  CLRF   7A
08B6:  CLRF   3B
08B7:  MOVF   31,W
08B8:  MOVWF  3A
08B9:  BSF    3A.7
08BA:  MOVF   32,W
08BB:  MOVWF  39
08BC:  MOVF   33,W
08BD:  MOVWF  38
08BE:  MOVLW  19
08BF:  MOVWF  3C
08C0:  MOVF   37,W
08C1:  SUBWF  38,F
08C2:  BTFSC  03.0
08C3:  GOTO   0D4
08C4:  MOVLW  01
08C5:  SUBWF  39,F
08C6:  BTFSC  03.0
08C7:  GOTO   0D4
08C8:  SUBWF  3A,F
08C9:  BTFSC  03.0
08CA:  GOTO   0D4
08CB:  SUBWF  3B,F
08CC:  BTFSC  03.0
08CD:  GOTO   0D4
08CE:  INCF   3B,F
08CF:  INCF   3A,F
08D0:  INCF   39,F
08D1:  MOVF   37,W
08D2:  ADDWF  38,F
08D3:  GOTO   106
08D4:  MOVF   36,W
08D5:  SUBWF  39,F
08D6:  BTFSC  03.0
08D7:  GOTO   0EF
08D8:  MOVLW  01
08D9:  SUBWF  3A,F
08DA:  BTFSC  03.0
08DB:  GOTO   0EF
08DC:  SUBWF  3B,F
08DD:  BTFSC  03.0
08DE:  GOTO   0EF
08DF:  INCF   3B,F
08E0:  INCF   3A,F
08E1:  MOVF   36,W
08E2:  ADDWF  39,F
08E3:  MOVF   37,W
08E4:  ADDWF  38,F
08E5:  BTFSS  03.0
08E6:  GOTO   106
08E7:  INCF   39,F
08E8:  BTFSS  03.2
08E9:  GOTO   106
08EA:  INCF   3A,F
08EB:  BTFSS  03.2
08EC:  GOTO   106
08ED:  INCF   3B,F
08EE:  GOTO   106
08EF:  MOVF   35,W
08F0:  IORLW  80
08F1:  SUBWF  3A,F
08F2:  BTFSC  03.0
08F3:  GOTO   105
08F4:  MOVLW  01
08F5:  SUBWF  3B,F
08F6:  BTFSC  03.0
08F7:  GOTO   105
08F8:  INCF   3B,F
08F9:  MOVF   35,W
08FA:  IORLW  80
08FB:  ADDWF  3A,F
08FC:  MOVF   36,W
08FD:  ADDWF  39,F
08FE:  BTFSS  03.0
08FF:  GOTO   0E3
0900:  INCF   3A,F
0901:  BTFSS  03.2
0902:  GOTO   0E3
0903:  INCF   3B,F
0904:  GOTO   0E3
0905:  BSF    7A.0
0906:  DECFSZ 3C,F
0907:  GOTO   109
0908:  GOTO   114
0909:  BCF    03.0
090A:  RLF    38,F
090B:  RLF    39,F
090C:  RLF    3A,F
090D:  RLF    3B,F
090E:  BCF    03.0
090F:  RLF    7A,F
0910:  RLF    79,F
0911:  RLF    78,F
0912:  RLF    3D,F
0913:  GOTO   0C0
0914:  BTFSS  3D.0
0915:  GOTO   11C
0916:  BCF    03.0
0917:  RRF    78,F
0918:  RRF    79,F
0919:  RRF    7A,F
091A:  RRF    3D,F
091B:  GOTO   11F
091C:  DECF   77,F
091D:  BTFSC  03.2
091E:  GOTO   161
091F:  BTFSC  3D.7
0920:  GOTO   148
0921:  BCF    03.0
0922:  RLF    38,F
0923:  RLF    39,F
0924:  RLF    3A,F
0925:  RLF    3B,F
0926:  MOVF   37,W
0927:  SUBWF  38,F
0928:  BTFSC  03.0
0929:  GOTO   134
092A:  MOVLW  01
092B:  SUBWF  39,F
092C:  BTFSC  03.0
092D:  GOTO   134
092E:  SUBWF  3A,F
092F:  BTFSC  03.0
0930:  GOTO   134
0931:  SUBWF  3B,F
0932:  BTFSS  03.0
0933:  GOTO   157
0934:  MOVF   36,W
0935:  SUBWF  39,F
0936:  BTFSC  03.0
0937:  GOTO   13F
0938:  MOVLW  01
0939:  SUBWF  3A,F
093A:  BTFSC  03.0
093B:  GOTO   13F
093C:  SUBWF  3B,F
093D:  BTFSS  03.0
093E:  GOTO   157
093F:  MOVF   35,W
0940:  IORLW  80
0941:  SUBWF  3A,F
0942:  BTFSC  03.0
0943:  GOTO   148
0944:  MOVLW  01
0945:  SUBWF  3B,F
0946:  BTFSS  03.0
0947:  GOTO   157
0948:  INCF   7A,F
0949:  BTFSS  03.2
094A:  GOTO   157
094B:  INCF   79,F
094C:  BTFSS  03.2
094D:  GOTO   157
094E:  INCF   78,F
094F:  BTFSS  03.2
0950:  GOTO   157
0951:  INCF   77,F
0952:  BTFSC  03.2
0953:  GOTO   161
0954:  RRF    78,F
0955:  RRF    79,F
0956:  RRF    7A,F
0957:  MOVF   31,W
0958:  MOVWF  3C
0959:  MOVF   35,W
095A:  XORWF  3C,F
095B:  BTFSS  3C.7
095C:  GOTO   15F
095D:  BSF    78.7
095E:  GOTO   165
095F:  BCF    78.7
0960:  GOTO   165
0961:  CLRF   77
0962:  CLRF   78
0963:  CLRF   79
0964:  CLRF   7A
*
09A7:  MOVF   30,W
09A8:  BTFSC  03.2
09A9:  GOTO   217
09AA:  MOVWF  38
09AB:  MOVF   34,W
09AC:  BTFSC  03.2
09AD:  GOTO   217
09AE:  ADDWF  38,F
09AF:  BTFSC  03.0
09B0:  GOTO   1B8
09B1:  MOVLW  7F
09B2:  SUBWF  38,F
09B3:  BTFSS  03.0
09B4:  GOTO   217
09B5:  BTFSC  03.2
09B6:  GOTO   217
09B7:  GOTO   1BC
09B8:  MOVLW  81
09B9:  ADDWF  38,F
09BA:  BTFSC  03.0
09BB:  GOTO   217
09BC:  MOVF   38,W
09BD:  MOVWF  77
09BE:  CLRF   78
09BF:  CLRF   79
09C0:  CLRF   7A
09C1:  MOVF   31,W
09C2:  MOVWF  3C
09C3:  BSF    3C.7
09C4:  MOVF   32,W
09C5:  MOVWF  3B
09C6:  MOVF   33,W
09C7:  MOVWF  3A
09C8:  MOVLW  18
09C9:  MOVWF  38
09CA:  CLRF   39
09CB:  BTFSS  3A.0
09CC:  GOTO   1E5
09CD:  MOVF   37,W
09CE:  ADDWF  7A,F
09CF:  BTFSS  03.0
09D0:  GOTO   1D7
09D1:  INCF   79,F
09D2:  BTFSS  03.2
09D3:  GOTO   1D7
09D4:  INCF   78,F
09D5:  BTFSC  03.2
09D6:  BSF    39.7
09D7:  MOVF   36,W
09D8:  ADDWF  79,F
09D9:  BTFSS  03.0
09DA:  GOTO   1DE
09DB:  INCF   78,F
09DC:  BTFSC  03.2
09DD:  BSF    39.7
09DE:  MOVF   35,W
09DF:  MOVWF  32
09E0:  BSF    32.7
09E1:  MOVF   32,W
09E2:  ADDWF  78,F
09E3:  BTFSC  03.0
09E4:  BSF    39.7
09E5:  RLF    39,F
09E6:  RRF    78,F
09E7:  RRF    79,F
09E8:  RRF    7A,F
09E9:  RRF    3C,F
09EA:  RRF    3B,F
09EB:  RRF    3A,F
09EC:  BCF    03.0
09ED:  DECFSZ 38,F
09EE:  GOTO   1CA
09EF:  MOVLW  01
09F0:  ADDWF  77,F
09F1:  BTFSC  03.0
09F2:  GOTO   217
09F3:  BTFSC  78.7
09F4:  GOTO   1FC
09F5:  RLF    3C,F
09F6:  RLF    7A,F
09F7:  RLF    79,F
09F8:  RLF    78,F
09F9:  DECF   77,F
09FA:  BTFSC  03.2
09FB:  GOTO   217
09FC:  BTFSS  3C.7
09FD:  GOTO   20D
09FE:  INCF   7A,F
09FF:  BTFSS  03.2
0A00:  GOTO   20D
0A01:  INCF   79,F
0A02:  BTFSS  03.2
0A03:  GOTO   20D
0A04:  INCF   78,F
0A05:  BTFSS  03.2
0A06:  GOTO   20D
0A07:  RRF    78,F
0A08:  RRF    79,F
0A09:  RRF    7A,F
0A0A:  INCF   77,F
0A0B:  BTFSC  03.2
0A0C:  GOTO   217
0A0D:  MOVF   31,W
0A0E:  MOVWF  39
0A0F:  MOVF   35,W
0A10:  XORWF  39,F
0A11:  BTFSS  39.7
0A12:  GOTO   215
0A13:  BSF    78.7
0A14:  GOTO   21B
0A15:  BCF    78.7
0A16:  GOTO   21B
0A17:  CLRF   77
0A18:  CLRF   78
0A19:  CLRF   79
0A1A:  CLRF   7A
*
0A51:  MOVLW  8E
0A52:  MOVWF  77
0A53:  MOVF   2C,W
0A54:  SUBWF  77,F
0A55:  MOVF   2D,W
0A56:  MOVWF  79
0A57:  MOVF   2E,W
0A58:  MOVWF  78
0A59:  BSF    79.7
0A5A:  MOVF   77,F
0A5B:  BTFSC  03.2
0A5C:  GOTO   268
0A5D:  BCF    03.0
0A5E:  MOVF   79,F
0A5F:  BTFSS  03.2
0A60:  GOTO   264
0A61:  MOVF   78,F
0A62:  BTFSC  03.2
0A63:  GOTO   268
0A64:  RRF    79,F
0A65:  RRF    78,F
0A66:  DECFSZ 77,F
0A67:  GOTO   25D
0A68:  BTFSS  2D.7
0A69:  GOTO   26F
0A6A:  COMF   78,F
0A6B:  COMF   79,F
0A6C:  INCF   78,F
0A6D:  BTFSC  03.2
0A6E:  INCF   79,F
*
0A7C:  MOVF   6B,W
0A7D:  XORWF  6D,W
0A7E:  ANDLW  80
0A7F:  MOVWF  6F
0A80:  BTFSS  6B.7
0A81:  GOTO   287
0A82:  COMF   6A,F
0A83:  COMF   6B,F
0A84:  INCF   6A,F
0A85:  BTFSC  03.2
0A86:  INCF   6B,F
0A87:  BTFSS  6D.7
0A88:  GOTO   28E
0A89:  COMF   6C,F
0A8A:  COMF   6D,F
0A8B:  INCF   6C,F
0A8C:  BTFSC  03.2
0A8D:  INCF   6D,F
0A8E:  CLRF   78
0A8F:  CLRF   79
0A90:  CLRF   77
0A91:  CLRF   7A
0A92:  MOVF   6D,W
0A93:  BTFSS  03.2
0A94:  GOTO   298
0A95:  MOVF   6C,W
0A96:  BTFSC  03.2
0A97:  GOTO   2B2
0A98:  MOVLW  10
0A99:  MOVWF  6E
0A9A:  BCF    03.0
0A9B:  RLF    6A,F
0A9C:  RLF    6B,F
0A9D:  RLF    77,F
0A9E:  RLF    7A,F
0A9F:  MOVF   6D,W
0AA0:  SUBWF  7A,W
0AA1:  BTFSS  03.2
0AA2:  GOTO   2A5
0AA3:  MOVF   6C,W
0AA4:  SUBWF  77,W
0AA5:  BTFSS  03.0
0AA6:  GOTO   2AE
0AA7:  MOVF   6C,W
0AA8:  SUBWF  77,F
0AA9:  BTFSS  03.0
0AAA:  DECF   7A,F
0AAB:  MOVF   6D,W
0AAC:  SUBWF  7A,F
0AAD:  BSF    03.0
0AAE:  RLF    78,F
0AAF:  RLF    79,F
0AB0:  DECFSZ 6E,F
0AB1:  GOTO   29A
0AB2:  BTFSS  6F.7
0AB3:  GOTO   2B9
0AB4:  COMF   78,F
0AB5:  COMF   79,F
0AB6:  INCF   78,F
0AB7:  BTFSC  03.2
0AB8:  INCF   79,F
*
0CE3:  BCF    0A.0
0CE4:  BCF    0A.1
0CE5:  BSF    0A.2
0CE6:  ADDWF  02,F
0CE7:  GOTO   3DE
0CE8:  GOTO   3D8
0CE9:  GOTO   3DA
0CEA:  GOTO   3DC
....................  
.................... #list 
....................  
.................... #device ADC=16 
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0B35:  BCF    03.5
0B36:  CLRF   2C
0B37:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
024B:  BSF    03.5
024C:  CLRF   45
....................    sign = 0; 
024D:  CLRF   43
....................    base = 10; 
024E:  MOVLW  0A
024F:  MOVWF  44
....................    result = 0; 
0250:  CLRF   42
....................  
....................    if (!s) 
0251:  MOVF   40,W
0252:  IORWF  41,W
0253:  BTFSS  03.2
0254:  GOTO   258
....................       return 0; 
0255:  MOVLW  00
0256:  MOVWF  78
0257:  GOTO   34B
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0258:  MOVF   45,W
0259:  INCF   45,F
025A:  ADDWF  40,W
025B:  MOVWF  04
025C:  BCF    03.7
025D:  BTFSC  41.0
025E:  BSF    03.7
025F:  MOVF   00,W
0260:  MOVWF  46
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0261:  MOVF   46,W
0262:  SUBLW  2D
0263:  BTFSS  03.2
0264:  GOTO   271
....................    { 
....................       sign = 1;         // Set the sign to negative 
0265:  MOVLW  01
0266:  MOVWF  43
....................       c = s[index++]; 
0267:  MOVF   45,W
0268:  INCF   45,F
0269:  ADDWF  40,W
026A:  MOVWF  04
026B:  BCF    03.7
026C:  BTFSC  41.0
026D:  BSF    03.7
026E:  MOVF   00,W
026F:  MOVWF  46
....................    } 
0270:  GOTO   27E
....................    else if (c == '+') 
0271:  MOVF   46,W
0272:  SUBLW  2B
0273:  BTFSS  03.2
0274:  GOTO   27E
....................    { 
....................       c = s[index++]; 
0275:  MOVF   45,W
0276:  INCF   45,F
0277:  ADDWF  40,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  BTFSC  41.0
027B:  BSF    03.7
027C:  MOVF   00,W
027D:  MOVWF  46
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
027E:  MOVF   46,W
027F:  SUBLW  2F
0280:  BTFSC  03.0
0281:  GOTO   341
0282:  MOVF   46,W
0283:  SUBLW  39
0284:  BTFSS  03.0
0285:  GOTO   341
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0286:  MOVF   46,W
0287:  SUBLW  30
0288:  BTFSS  03.2
0289:  GOTO   2AA
028A:  MOVF   45,W
028B:  ADDWF  40,W
028C:  MOVWF  04
028D:  BCF    03.7
028E:  BTFSC  41.0
028F:  BSF    03.7
0290:  MOVF   00,W
0291:  SUBLW  78
0292:  BTFSC  03.2
0293:  GOTO   29E
0294:  MOVF   45,W
0295:  ADDWF  40,W
0296:  MOVWF  04
0297:  BCF    03.7
0298:  BTFSC  41.0
0299:  BSF    03.7
029A:  MOVF   00,W
029B:  SUBLW  58
029C:  BTFSS  03.2
029D:  GOTO   2AA
....................       { 
....................          base = 16; 
029E:  MOVLW  10
029F:  MOVWF  44
....................          index++; 
02A0:  INCF   45,F
....................          c = s[index++]; 
02A1:  MOVF   45,W
02A2:  INCF   45,F
02A3:  ADDWF  40,W
02A4:  MOVWF  04
02A5:  BCF    03.7
02A6:  BTFSC  41.0
02A7:  BSF    03.7
02A8:  MOVF   00,W
02A9:  MOVWF  46
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02AA:  MOVF   44,W
02AB:  SUBLW  0A
02AC:  BTFSS  03.2
02AD:  GOTO   2EF
....................       { 
....................          while (c >= '0' && c <= '9') 
02AE:  MOVF   46,W
02AF:  SUBLW  2F
02B0:  BTFSC  03.0
02B1:  GOTO   2EE
02B2:  MOVF   46,W
02B3:  SUBLW  39
02B4:  BTFSS  03.0
02B5:  GOTO   2EE
....................          { 
....................             result = 10*result + (c - '0'); 
02B6:  MOVLW  0A
02B7:  MOVWF  47
02B8:  MOVF   42,W
02B9:  MOVWF  48
*
02DE:  MOVF   78,W
02DF:  MOVWF  47
02E0:  MOVLW  30
02E1:  SUBWF  46,W
02E2:  ADDWF  47,W
02E3:  MOVWF  42
....................             c = s[index++]; 
02E4:  MOVF   45,W
02E5:  INCF   45,F
02E6:  ADDWF  40,W
02E7:  MOVWF  04
02E8:  BCF    03.7
02E9:  BTFSC  41.0
02EA:  BSF    03.7
02EB:  MOVF   00,W
02EC:  MOVWF  46
02ED:  GOTO   2AE
....................          } 
....................       } 
02EE:  GOTO   341
....................       else if (base == 16)    // The number is a hexa number 
02EF:  MOVF   44,W
02F0:  SUBLW  10
02F1:  BTFSS  03.2
02F2:  GOTO   341
....................       { 
....................          c = toupper(c); 
02F3:  MOVF   46,W
02F4:  SUBLW  60
02F5:  BTFSC  03.0
02F6:  GOTO   2FE
02F7:  MOVF   46,W
02F8:  SUBLW  7A
02F9:  BTFSS  03.0
02FA:  GOTO   2FE
02FB:  MOVF   46,W
02FC:  ANDLW  DF
02FD:  GOTO   2FF
02FE:  MOVF   46,W
02FF:  MOVWF  46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0300:  MOVF   46,W
0301:  SUBLW  2F
0302:  BTFSC  03.0
0303:  GOTO   308
0304:  MOVF   46,W
0305:  SUBLW  39
0306:  BTFSC  03.0
0307:  GOTO   310
0308:  MOVF   46,W
0309:  SUBLW  40
030A:  BTFSC  03.0
030B:  GOTO   341
030C:  MOVF   46,W
030D:  SUBLW  46
030E:  BTFSS  03.0
030F:  GOTO   341
....................          { 
....................             if (c >= '0' && c <= '9') 
0310:  MOVF   46,W
0311:  SUBLW  2F
0312:  BTFSC  03.0
0313:  GOTO   321
0314:  MOVF   46,W
0315:  SUBLW  39
0316:  BTFSS  03.0
0317:  GOTO   321
....................                result = (result << 4) + (c - '0'); 
0318:  SWAPF  42,W
0319:  MOVWF  47
031A:  MOVLW  F0
031B:  ANDWF  47,F
031C:  MOVLW  30
031D:  SUBWF  46,W
031E:  ADDWF  47,W
031F:  MOVWF  42
0320:  GOTO   32A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0321:  SWAPF  42,W
0322:  MOVWF  47
0323:  MOVLW  F0
0324:  ANDWF  47,F
0325:  MOVLW  41
0326:  SUBWF  46,W
0327:  ADDLW  0A
0328:  ADDWF  47,W
0329:  MOVWF  42
....................  
....................             c = s[index++]; 
032A:  MOVF   45,W
032B:  INCF   45,F
032C:  ADDWF  40,W
032D:  MOVWF  04
032E:  BCF    03.7
032F:  BTFSC  41.0
0330:  BSF    03.7
0331:  MOVF   00,W
0332:  MOVWF  46
....................             c = toupper(c); 
0333:  MOVF   46,W
0334:  SUBLW  60
0335:  BTFSC  03.0
0336:  GOTO   33E
0337:  MOVF   46,W
0338:  SUBLW  7A
0339:  BTFSS  03.0
033A:  GOTO   33E
033B:  MOVF   46,W
033C:  ANDLW  DF
033D:  GOTO   33F
033E:  MOVF   46,W
033F:  MOVWF  46
0340:  GOTO   300
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0341:  DECFSZ 43,W
0342:  GOTO   349
0343:  MOVF   44,W
0344:  SUBLW  0A
0345:  BTFSS  03.2
0346:  GOTO   349
....................        result = -result; 
0347:  COMF   42,F
0348:  INCF   42,F
....................  
....................    return(result); 
0349:  MOVF   42,W
034A:  MOVWF  78
034B:  BCF    03.5
034C:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE<string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS 
....................  
.................... #use delay(crystal=20000000) 
*
03DF:  MOVLW  6A
03E0:  MOVWF  04
03E1:  BCF    03.7
03E2:  MOVF   00,W
03E3:  BTFSC  03.2
03E4:  GOTO   3F2
03E5:  MOVLW  06
03E6:  MOVWF  78
03E7:  CLRF   77
03E8:  DECFSZ 77,F
03E9:  GOTO   3E8
03EA:  DECFSZ 78,F
03EB:  GOTO   3E7
03EC:  MOVLW  7B
03ED:  MOVWF  77
03EE:  DECFSZ 77,F
03EF:  GOTO   3EE
03F0:  DECFSZ 00,F
03F1:  GOTO   3E5
03F2:  RETURN
.................... #use FIXED_IO( A_outputs=PIN_A3,PIN_A2,PIN_A1,PIN_A0,PIN_A4 ) 
.................... #use rs232(stream=com1,baud=9600,xmit=PIN_C6,rcv=PIN_c7)) 
....................  
.................... #define S_0   PIN_A0 
.................... #define S_1   PIN_A1 
.................... #define S_2   PIN_A2 
.................... #define S_3   PIN_A3 
.................... #define READ   PIN_B0 
....................  
....................  
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_D6 
.................... #define LCD_RS_PIN PIN_D7 
.................... #define LCD_RW_PIN PIN_C4 
.................... #define LCD_DATA4 PIN_D5 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D3 
.................... #define LCD_DATA7 PIN_D2 
....................  
.................... #define UNIDENTIFIED    0 
.................... #define COLOR_RED       1 
.................... #define COLOR_BLUE      2 
.................... #define COLOR_GREEN     3 
.................... #define COLOR_COUNT_MAX     4 
.................... #define LOW_   1 
.................... #define MEDIUM    2 
.................... #define HIGH_   3 
.................... #define ON_    1 
.................... #define OFF_   0 
.................... #include<lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0466:  BSF    08.5
....................    output_float(LCD_DATA5); 
0467:  BSF    08.4
....................    output_float(LCD_DATA6); 
0468:  BSF    08.3
....................    output_float(LCD_DATA7); 
0469:  BSF    08.2
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
046A:  BCF    03.5
046B:  BSF    07.4
046C:  BCF    32.4
046D:  MOVF   32,W
046E:  BSF    03.5
046F:  MOVWF  07
....................    delay_cycles(1); 
0470:  NOP
....................    lcd_output_enable(1); 
0471:  BCF    03.5
0472:  BSF    08.6
0473:  BSF    03.5
0474:  BCF    08.6
....................    delay_cycles(1); 
0475:  NOP
....................    high = lcd_read_nibble(); 
0476:  BCF    03.5
0477:  CALL   429
0478:  MOVF   78,W
0479:  MOVWF  70
....................        
....................    lcd_output_enable(0); 
047A:  BCF    08.6
047B:  BSF    03.5
047C:  BCF    08.6
....................    delay_cycles(1); 
047D:  NOP
....................    lcd_output_enable(1); 
047E:  BCF    03.5
047F:  BSF    08.6
0480:  BSF    03.5
0481:  BCF    08.6
....................    delay_us(1); 
0482:  GOTO   483
0483:  GOTO   484
0484:  NOP
....................    low = lcd_read_nibble(); 
0485:  BCF    03.5
0486:  CALL   429
0487:  MOVF   78,W
0488:  MOVWF  6F
....................        
....................    lcd_output_enable(0); 
0489:  BCF    08.6
048A:  BSF    03.5
048B:  BCF    08.6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
048C:  BCF    08.5
....................    output_drive(LCD_DATA5); 
048D:  BCF    08.4
....................    output_drive(LCD_DATA6); 
048E:  BCF    08.3
....................    output_drive(LCD_DATA7); 
048F:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0490:  SWAPF  70,W
0491:  MOVWF  77
0492:  MOVLW  F0
0493:  ANDWF  77,F
0494:  MOVF   77,W
0495:  BCF    03.5
0496:  IORWF  6F,W
0497:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0429:  CLRF   71
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
042A:  BSF    03.5
042B:  BSF    08.5
042C:  MOVLW  00
042D:  BCF    03.5
042E:  BTFSC  08.5
042F:  MOVLW  01
0430:  IORWF  71,F
....................    n |= input(LCD_DATA5) << 1; 
0431:  BSF    03.5
0432:  BSF    08.4
0433:  MOVLW  00
0434:  BCF    03.5
0435:  BTFSC  08.4
0436:  MOVLW  01
0437:  MOVWF  77
0438:  BCF    03.0
0439:  RLF    77,F
043A:  MOVF   77,W
043B:  IORWF  71,F
....................    n |= input(LCD_DATA6) << 2; 
043C:  BSF    03.5
043D:  BSF    08.3
043E:  MOVLW  00
043F:  BCF    03.5
0440:  BTFSC  08.3
0441:  MOVLW  01
0442:  MOVWF  77
0443:  RLF    77,F
0444:  RLF    77,F
0445:  MOVLW  FC
0446:  ANDWF  77,F
0447:  MOVF   77,W
0448:  IORWF  71,F
....................    n |= input(LCD_DATA7) << 3; 
0449:  BSF    03.5
044A:  BSF    08.2
044B:  MOVLW  00
044C:  BCF    03.5
044D:  BTFSC  08.2
044E:  MOVLW  01
044F:  MOVWF  77
0450:  RLF    77,F
0451:  RLF    77,F
0452:  RLF    77,F
0453:  MOVLW  F8
0454:  ANDWF  77,F
0455:  MOVF   77,W
0456:  IORWF  71,F
....................     
....................    return(n); 
0457:  MOVF   71,W
0458:  MOVWF  78
....................   #else 
0459:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
03F3:  BTFSC  70.0
03F4:  GOTO   3F7
03F5:  BCF    08.5
03F6:  GOTO   3F8
03F7:  BSF    08.5
03F8:  BSF    03.5
03F9:  BCF    08.5
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
03FA:  BTFSC  70.1
03FB:  GOTO   400
03FC:  BCF    03.5
03FD:  BCF    08.4
03FE:  GOTO   402
03FF:  BSF    03.5
0400:  BCF    03.5
0401:  BSF    08.4
0402:  BSF    03.5
0403:  BCF    08.4
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0404:  BTFSC  70.2
0405:  GOTO   40A
0406:  BCF    03.5
0407:  BCF    08.3
0408:  GOTO   40C
0409:  BSF    03.5
040A:  BCF    03.5
040B:  BSF    08.3
040C:  BSF    03.5
040D:  BCF    08.3
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
040E:  BTFSC  70.3
040F:  GOTO   414
0410:  BCF    03.5
0411:  BCF    08.2
0412:  GOTO   416
0413:  BSF    03.5
0414:  BCF    03.5
0415:  BSF    08.2
0416:  BSF    03.5
0417:  BCF    08.2
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0418:  NOP
....................    lcd_output_enable(1); 
0419:  BCF    03.5
041A:  BSF    08.6
041B:  BSF    03.5
041C:  BCF    08.6
....................    delay_us(2); 
041D:  MOVLW  02
041E:  MOVWF  77
041F:  DECFSZ 77,F
0420:  GOTO   41F
0421:  GOTO   422
0422:  NOP
....................    lcd_output_enable(0); 
0423:  BCF    03.5
0424:  BCF    08.6
0425:  BSF    03.5
0426:  BCF    08.6
0427:  BCF    03.5
0428:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
045A:  BSF    03.5
045B:  BCF    08.6
....................    lcd_rs_tris(); 
045C:  BCF    08.7
....................    lcd_rw_tris(); 
045D:  BCF    03.5
045E:  BCF    32.4
045F:  MOVF   32,W
0460:  BSF    03.5
0461:  MOVWF  07
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0462:  BCF    03.5
0463:  BCF    08.7
0464:  BSF    03.5
0465:  BCF    08.7
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0498:  MOVF   78,W
0499:  MOVWF  6F
049A:  BTFSS  6F.7
049B:  GOTO   49E
049C:  BSF    03.5
049D:  GOTO   466
....................    lcd_output_rs(address); 
049E:  MOVF   6D,F
049F:  BTFSS  03.2
04A0:  GOTO   4A3
04A1:  BCF    08.7
04A2:  GOTO   4A4
04A3:  BSF    08.7
04A4:  BSF    03.5
04A5:  BCF    08.7
....................    delay_cycles(1); 
04A6:  NOP
....................    lcd_output_rw(0); 
04A7:  BCF    03.5
04A8:  BCF    07.4
04A9:  BCF    32.4
04AA:  MOVF   32,W
04AB:  BSF    03.5
04AC:  MOVWF  07
....................    delay_cycles(1); 
04AD:  NOP
....................    lcd_output_enable(0); 
04AE:  BCF    03.5
04AF:  BCF    08.6
04B0:  BSF    03.5
04B1:  BCF    08.6
....................    lcd_send_nibble(n >> 4); 
04B2:  BCF    03.5
04B3:  SWAPF  6E,W
04B4:  MOVWF  6F
04B5:  MOVLW  0F
04B6:  ANDWF  6F,F
04B7:  MOVF   6F,W
04B8:  MOVWF  70
04B9:  CALL   3F3
....................    lcd_send_nibble(n & 0xf); 
04BA:  MOVF   6E,W
04BB:  ANDLW  0F
04BC:  MOVWF  6F
04BD:  MOVWF  70
04BE:  CALL   3F3
04BF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
04C0:  MOVLW  28
04C1:  MOVWF  66
04C2:  MOVLW  0C
04C3:  MOVWF  67
04C4:  MOVLW  01
04C5:  MOVWF  68
04C6:  MOVLW  06
04C7:  MOVWF  69
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
04C8:  BCF    08.6
04C9:  BSF    03.5
04CA:  BCF    08.6
....................    lcd_output_rs(0); 
04CB:  BCF    03.5
04CC:  BCF    08.7
04CD:  BSF    03.5
04CE:  BCF    08.7
....................    lcd_output_rw(0); 
04CF:  BCF    03.5
04D0:  BCF    07.4
04D1:  BCF    32.4
04D2:  MOVF   32,W
04D3:  BSF    03.5
04D4:  MOVWF  07
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
04D5:  BCF    08.5
....................    output_drive(LCD_DATA5); 
04D6:  BCF    08.4
....................    output_drive(LCD_DATA6); 
04D7:  BCF    08.3
....................    output_drive(LCD_DATA7); 
04D8:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
04D9:  BCF    08.6
....................    lcd_rs_tris(); 
04DA:  BCF    08.7
....................    lcd_rw_tris(); 
04DB:  BCF    03.5
04DC:  BCF    32.4
04DD:  MOVF   32,W
04DE:  BSF    03.5
04DF:  MOVWF  07
....................  #endif 
....................      
....................    delay_ms(15); 
04E0:  MOVLW  0F
04E1:  BCF    03.5
04E2:  MOVWF  6A
04E3:  CALL   3DF
....................    for(i=1;i<=3;++i) 
04E4:  MOVLW  01
04E5:  MOVWF  65
04E6:  MOVF   65,W
04E7:  SUBLW  03
04E8:  BTFSS  03.0
04E9:  GOTO   4F2
....................    { 
....................        lcd_send_nibble(3); 
04EA:  MOVLW  03
04EB:  MOVWF  70
04EC:  CALL   3F3
....................        delay_ms(5); 
04ED:  MOVLW  05
04EE:  MOVWF  6A
04EF:  CALL   3DF
04F0:  INCF   65,F
04F1:  GOTO   4E6
....................    } 
....................     
....................    lcd_send_nibble(2); 
04F2:  MOVLW  02
04F3:  MOVWF  70
04F4:  CALL   3F3
....................    delay_ms(5); 
04F5:  MOVLW  05
04F6:  MOVWF  6A
04F7:  CALL   3DF
....................    for(i=0;i<=3;++i) 
04F8:  CLRF   65
04F9:  MOVF   65,W
04FA:  SUBLW  03
04FB:  BTFSS  03.0
04FC:  GOTO   509
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
04FD:  MOVLW  66
04FE:  ADDWF  65,W
04FF:  MOVWF  04
0500:  BCF    03.7
0501:  MOVF   00,W
0502:  MOVWF  6A
0503:  CLRF   6D
0504:  MOVF   6A,W
0505:  MOVWF  6E
0506:  CALL   45A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0507:  INCF   65,F
0508:  GOTO   4F9
0509:  BSF    0A.3
050A:  BCF    0A.4
050B:  GOTO   34D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0530:  DECFSZ 6A,W
0531:  GOTO   533
0532:  GOTO   536
....................       address=LCD_LINE_TWO; 
0533:  MOVLW  40
0534:  MOVWF  6B
0535:  GOTO   537
....................    else 
....................       address=0; 
0536:  CLRF   6B
....................       
....................    address+=x-1; 
0537:  MOVLW  01
0538:  SUBWF  69,W
0539:  ADDWF  6B,F
....................    lcd_send_byte(0,0x80|address); 
053A:  MOVF   6B,W
053B:  IORLW  80
053C:  MOVWF  6C
053D:  CLRF   6D
053E:  MOVF   6C,W
053F:  MOVWF  6E
0540:  CALL   45A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0541:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0542:  MOVF   68,W
0543:  XORLW  07
0544:  BTFSC  03.2
0545:  GOTO   550
0546:  XORLW  0B
0547:  BTFSC  03.2
0548:  GOTO   555
0549:  XORLW  06
054A:  BTFSC  03.2
054B:  GOTO   55D
054C:  XORLW  02
054D:  BTFSC  03.2
054E:  GOTO   563
054F:  GOTO   568
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0550:  MOVLW  01
0551:  MOVWF  69
0552:  MOVWF  6A
0553:  CALL   530
0554:  GOTO   56D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0555:  CLRF   6D
0556:  MOVLW  01
0557:  MOVWF  6E
0558:  CALL   45A
....................                      delay_ms(2); 
0559:  MOVLW  02
055A:  MOVWF  6A
055B:  CALL   3DF
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
055C:  GOTO   56D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
055D:  MOVLW  01
055E:  MOVWF  69
055F:  MOVLW  02
0560:  MOVWF  6A
0561:  CALL   530
0562:  GOTO   56D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0563:  CLRF   6D
0564:  MOVLW  10
0565:  MOVWF  6E
0566:  CALL   45A
0567:  GOTO   56D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0568:  MOVLW  01
0569:  MOVWF  6D
056A:  MOVF   68,W
056B:  MOVWF  6E
056C:  CALL   45A
....................      #endif 
....................    } 
056D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... unsigned char has_product = 0, count_enable = 0, isFromButtonPressed = 0,done=0,cycle,data_received[5],c,has_red,has_blue,has_green; 
.................... int color_count = 0, red_count = 0, blue_count = 0, green_count = 0, blind_count = 0; 
.................... unsigned int red_product = 0, blue_product = 0, green_product = 0,sum;  
.................... int color_flag,on_off,speed_mode,freq_mode,sp_stop,time_stop,is_running; 
.................... static  float  count, red_freq, blue_freq, green_freq; 
*
0B38:  CLRF   51
0B39:  CLRF   52
0B3A:  CLRF   53
0B3B:  CLRF   54
0B3C:  CLRF   55
0B3D:  CLRF   56
0B3E:  CLRF   57
0B3F:  CLRF   58
0B40:  CLRF   59
0B41:  CLRF   5A
0B42:  CLRF   5B
0B43:  CLRF   5C
0B44:  CLRF   5D
0B45:  CLRF   5E
0B46:  CLRF   5F
0B47:  CLRF   60
.................... int16 Ton, ChuKy=10000; 
.................... float Map(float x, float in_min, float in_max, float out_min, float out_max) 
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
....................    tam =  tam + out_min; 
....................    return tam; 
.................... } 
....................  
.................... void Hien_thi(int16 value) 
.................... { 
....................    lcd_putc(value/10000 + 0x30) ; // chuc nghin 
....................    lcd_putc(value%10000/1000 + 0x30) ;  // nghin 
....................    lcd_putc(value%10000%1000/100 + 0x30) ; // tram 
....................    lcd_putc(value%10000%1000%100/10 + 0x30) ; // chuc 
....................    lcd_putc(value%10 + 0x30) ; // don vi 
....................     
.................... } 
.................... void TCS_mode(int8 s2, int8 s3) 
.................... { 
....................    count=0; 
*
01DA:  CLRF   54
01DB:  CLRF   53
01DC:  CLRF   52
01DD:  CLRF   51
....................    color_flag++; 
01DE:  INCF   4A,F
....................    OUTPUT_BIT(S_2,s2); 
01DF:  BSF    03.5
01E0:  MOVF   40,F
01E1:  BTFSS  03.2
01E2:  GOTO   1E7
01E3:  BCF    03.5
01E4:  BCF    05.2
01E5:  GOTO   1E9
01E6:  BSF    03.5
01E7:  BCF    03.5
01E8:  BSF    05.2
01E9:  MOVLW  E0
01EA:  BSF    03.5
01EB:  MOVWF  05
....................    OUTPUT_BIT(S_3,s3); 
01EC:  MOVF   41,F
01ED:  BTFSS  03.2
01EE:  GOTO   1F3
01EF:  BCF    03.5
01F0:  BCF    05.3
01F1:  GOTO   1F5
01F2:  BSF    03.5
01F3:  BCF    03.5
01F4:  BSF    05.3
01F5:  MOVLW  E0
01F6:  BSF    03.5
01F7:  MOVWF  05
....................    set_timer1(3036); 
01F8:  BCF    03.5
01F9:  CLRF   0E
01FA:  MOVLW  0B
01FB:  MOVWF  0F
01FC:  MOVLW  DC
01FD:  MOVWF  0E
....................    if(color_flag==4) 
01FE:  MOVF   4A,W
01FF:  SUBLW  04
0200:  BTFSS  03.2
0201:  GOTO   206
....................       { 
....................        color_flag=0; 
0202:  CLRF   4A
....................        setup_timer_1(T1_DISABLED); 
0203:  CLRF   10
....................        done=1; 
0204:  MOVLW  01
0205:  MOVWF  36
....................       } 
0206:  RETURN
.................... } 
.................... void get_data() 
*
035B:  BSF    03.5
035C:  CLRF   40
.................... { 
.................... int i=0; 
.................... c=fgetc(com1); 
035D:  BCF    03.5
035E:  BTFSS  0C.5
035F:  GOTO   35E
0360:  MOVF   1A,W
0361:  MOVWF  3D
.................... if(c=='<') 
0362:  MOVF   3D,W
0363:  SUBLW  3C
0364:  BTFSS  03.2
0365:  GOTO   37F
....................    { do{ c=fgetc(com1); 
0366:  BTFSS  0C.5
0367:  GOTO   366
0368:  MOVF   1A,W
0369:  MOVWF  3D
....................          if(c!='-'&& c!='>') data_received[i++]=c; 
036A:  MOVF   3D,W
036B:  SUBLW  2D
036C:  BTFSC  03.2
036D:  GOTO   37B
036E:  MOVF   3D,W
036F:  SUBLW  3E
0370:  BTFSC  03.2
0371:  GOTO   37B
0372:  BSF    03.5
0373:  MOVF   40,W
0374:  INCF   40,F
0375:  ADDLW  38
0376:  MOVWF  04
0377:  BCF    03.7
0378:  BCF    03.5
0379:  MOVF   3D,W
037A:  MOVWF  00
....................        } 
....................        while(c!='>'); 
037B:  MOVF   3D,W
037C:  SUBLW  3E
037D:  BTFSS  03.2
037E:  GOTO   366
....................    } 
....................     
.................... } 
....................  
.................... void Delay4us(int16 t) 
.................... { 
....................    while(t>0) t--; 
*
0794:  MOVF   6C,F
0795:  BTFSS  03.2
0796:  GOTO   79A
0797:  MOVF   6D,F
0798:  BTFSC  03.2
0799:  GOTO   79F
079A:  MOVF   6C,W
079B:  BTFSC  03.2
079C:  DECF   6D,F
079D:  DECF   6C,F
079E:  GOTO   794
079F:  RETURN
.................... } 
....................  
.................... long Convert(float x, float in_min, float in_max, float out_min, float out_max) 
*
0848:  BSF    03.1
0849:  BCF    03.5
084A:  CLRF   2B
084B:  BTFSC  0B.7
084C:  BSF    2B.7
084D:  BCF    0B.7
084E:  BSF    03.5
084F:  MOVF   27,W
0850:  MOVWF  43
0851:  MOVF   26,W
0852:  MOVWF  42
0853:  MOVF   25,W
0854:  MOVWF  41
0855:  MOVF   24,W
0856:  MOVWF  40
0857:  MOVF   23,W
0858:  MOVWF  47
0859:  MOVF   22,W
085A:  MOVWF  46
085B:  MOVF   21,W
085C:  MOVWF  45
085D:  MOVF   20,W
085E:  MOVWF  44
085F:  BCF    0A.3
0860:  BCF    03.5
0861:  CALL   068
0862:  BSF    0A.3
0863:  BTFSC  2B.7
0864:  BSF    0B.7
0865:  MOVF   7A,W
0866:  BSF    03.5
0867:  MOVWF  2F
0868:  MOVF   79,W
0869:  MOVWF  2E
086A:  MOVF   78,W
086B:  MOVWF  2D
086C:  MOVF   77,W
086D:  MOVWF  2C
086E:  BSF    03.1
086F:  BCF    03.5
0870:  CLRF   2B
0871:  BTFSC  0B.7
0872:  BSF    2B.7
0873:  BCF    0B.7
0874:  MOVF   7E,W
0875:  BSF    03.5
0876:  MOVWF  43
0877:  MOVF   7D,W
0878:  MOVWF  42
0879:  MOVF   7C,W
087A:  MOVWF  41
087B:  MOVF   7B,W
087C:  MOVWF  40
087D:  MOVF   75,W
087E:  MOVWF  47
087F:  MOVF   74,W
0880:  MOVWF  46
0881:  MOVF   73,W
0882:  MOVWF  45
0883:  MOVF   72,W
0884:  MOVWF  44
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   068
0888:  BSF    0A.3
0889:  BTFSC  2B.7
088A:  BSF    0B.7
088B:  BSF    03.5
088C:  MOVF   2F,W
088D:  MOVWF  33
088E:  MOVF   2E,W
088F:  MOVWF  32
0890:  MOVF   2D,W
0891:  MOVWF  31
0892:  MOVF   2C,W
0893:  MOVWF  30
0894:  MOVF   7A,W
0895:  MOVWF  37
0896:  MOVF   79,W
0897:  MOVWF  36
0898:  MOVF   78,W
0899:  MOVWF  35
089A:  MOVF   77,W
089B:  MOVWF  34
*
0965:  MOVF   7A,W
0966:  MOVWF  2B
0967:  MOVF   79,W
0968:  MOVWF  2A
0969:  MOVF   78,W
096A:  MOVWF  29
096B:  MOVF   77,W
096C:  MOVWF  28
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
096D:  BSF    03.1
096E:  BCF    03.5
096F:  CLRF   2B
0970:  BTFSC  0B.7
0971:  BSF    2B.7
0972:  BCF    0B.7
0973:  MOVF   71,W
0974:  BSF    03.5
0975:  MOVWF  43
0976:  MOVF   70,W
0977:  MOVWF  42
0978:  BCF    03.5
0979:  MOVF   6F,W
097A:  BSF    03.5
097B:  MOVWF  41
097C:  BCF    03.5
097D:  MOVF   6E,W
097E:  BSF    03.5
097F:  MOVWF  40
0980:  MOVF   75,W
0981:  MOVWF  47
0982:  MOVF   74,W
0983:  MOVWF  46
0984:  MOVF   73,W
0985:  MOVWF  45
0986:  MOVF   72,W
0987:  MOVWF  44
0988:  BCF    0A.3
0989:  BCF    03.5
098A:  CALL   068
098B:  BSF    0A.3
098C:  BTFSC  2B.7
098D:  BSF    0B.7
098E:  MOVF   7A,W
098F:  BSF    03.5
0990:  MOVWF  2F
0991:  MOVF   79,W
0992:  MOVWF  2E
0993:  MOVF   78,W
0994:  MOVWF  2D
0995:  MOVF   77,W
0996:  MOVWF  2C
0997:  MOVF   2F,W
0998:  MOVWF  33
0999:  MOVF   2E,W
099A:  MOVWF  32
099B:  MOVF   2D,W
099C:  MOVWF  31
099D:  MOVF   2C,W
099E:  MOVWF  30
099F:  MOVF   2B,W
09A0:  MOVWF  37
09A1:  MOVF   2A,W
09A2:  MOVWF  36
09A3:  MOVF   29,W
09A4:  MOVWF  35
09A5:  MOVF   28,W
09A6:  MOVWF  34
*
0A1B:  MOVF   7A,W
0A1C:  MOVWF  2B
0A1D:  MOVF   79,W
0A1E:  MOVWF  2A
0A1F:  MOVF   78,W
0A20:  MOVWF  29
0A21:  MOVF   77,W
0A22:  MOVWF  28
....................    tam = tam + out_min; 
0A23:  BCF    03.1
0A24:  BCF    03.5
0A25:  CLRF   2B
0A26:  BTFSC  0B.7
0A27:  BSF    2B.7
0A28:  BCF    0B.7
0A29:  BSF    03.5
0A2A:  MOVF   2B,W
0A2B:  MOVWF  43
0A2C:  MOVF   2A,W
0A2D:  MOVWF  42
0A2E:  MOVF   29,W
0A2F:  MOVWF  41
0A30:  MOVF   28,W
0A31:  MOVWF  40
0A32:  MOVF   23,W
0A33:  MOVWF  47
0A34:  MOVF   22,W
0A35:  MOVWF  46
0A36:  MOVF   21,W
0A37:  MOVWF  45
0A38:  MOVF   20,W
0A39:  MOVWF  44
0A3A:  BCF    0A.3
0A3B:  BCF    03.5
0A3C:  CALL   068
0A3D:  BSF    0A.3
0A3E:  BTFSC  2B.7
0A3F:  BSF    0B.7
0A40:  MOVF   7A,W
0A41:  BSF    03.5
0A42:  MOVWF  2B
0A43:  MOVF   79,W
0A44:  MOVWF  2A
0A45:  MOVF   78,W
0A46:  MOVWF  29
0A47:  MOVF   77,W
0A48:  MOVWF  28
....................    return tam; 
0A49:  MOVF   2B,W
0A4A:  MOVWF  2F
0A4B:  MOVF   2A,W
0A4C:  MOVWF  2E
0A4D:  MOVF   29,W
0A4E:  MOVWF  2D
0A4F:  MOVF   28,W
0A50:  MOVWF  2C
*
0A6F:  MOVF   79,W
.................... } 
....................  
.................... void Write(long Goc, signed long t,int servo) 
.................... { 
....................    Ton = Convert(Goc,0,180, 247,1250); 
*
0800:  MOVF   66,W
0801:  MOVWF  6B
0802:  MOVF   65,W
0803:  MOVWF  6A
*
0820:  MOVF   7A,W
0821:  MOVWF  6D
0822:  MOVF   79,W
0823:  MOVWF  6C
0824:  MOVF   78,W
0825:  MOVWF  6B
0826:  MOVF   77,W
0827:  MOVWF  6A
0828:  MOVF   6D,W
0829:  MOVWF  71
082A:  MOVF   6C,W
082B:  MOVWF  70
082C:  MOVF   6B,W
082D:  MOVWF  6F
082E:  MOVF   6A,W
082F:  MOVWF  6E
0830:  CLRF   75
0831:  CLRF   74
0832:  CLRF   73
0833:  CLRF   72
0834:  CLRF   7E
0835:  CLRF   7D
0836:  MOVLW  34
0837:  MOVWF  7C
0838:  MOVLW  86
0839:  MOVWF  7B
083A:  BSF    03.5
083B:  CLRF   23
083C:  CLRF   22
083D:  MOVLW  77
083E:  MOVWF  21
083F:  MOVLW  86
0840:  MOVWF  20
0841:  CLRF   27
0842:  MOVLW  40
0843:  MOVWF  26
0844:  MOVLW  1C
0845:  MOVWF  25
0846:  MOVLW  89
0847:  MOVWF  24
*
0A70:  MOVF   79,W
0A71:  BCF    03.5
0A72:  MOVWF  62
0A73:  MOVF   78,W
0A74:  MOVWF  61
....................    t=t/20; 
0A75:  MOVF   68,W
0A76:  MOVWF  6B
0A77:  MOVF   67,W
0A78:  MOVWF  6A
0A79:  CLRF   6D
0A7A:  MOVLW  14
0A7B:  MOVWF  6C
*
0AB9:  MOVF   79,W
0ABA:  MOVWF  68
0ABB:  MOVF   78,W
0ABC:  MOVWF  67
....................    for(;t>0;t--) 
0ABD:  BTFSC  68.7
0ABE:  GOTO   30F
0ABF:  MOVF   68,F
0AC0:  BTFSS  03.2
0AC1:  GOTO   2C6
0AC2:  MOVF   67,W
0AC3:  SUBLW  00
0AC4:  BTFSC  03.0
0AC5:  GOTO   30F
....................    { 
....................       // phat xung trong 20ms 
....................     if(servo==1) 
0AC6:  DECFSZ 69,W
0AC7:  GOTO   2E7
....................     { 
....................       output_bit(PIN_D1,1); 
0AC8:  BSF    08.1
0AC9:  BSF    03.5
0ACA:  BCF    08.1
....................       Delay4us(Ton); 
0ACB:  BCF    03.5
0ACC:  MOVF   62,W
0ACD:  MOVWF  6D
0ACE:  MOVF   61,W
0ACF:  MOVWF  6C
0AD0:  BCF    0A.3
0AD1:  CALL   794
0AD2:  BSF    0A.3
....................       output_bit(PIN_D1,0); 
0AD3:  BCF    08.1
0AD4:  BSF    03.5
0AD5:  BCF    08.1
....................       Delay4us(ChuKy-Ton); 
0AD6:  BCF    03.5
0AD7:  MOVF   61,W
0AD8:  SUBWF  63,W
0AD9:  MOVWF  6A
0ADA:  MOVF   64,W
0ADB:  MOVWF  6B
0ADC:  MOVF   62,W
0ADD:  BTFSS  03.0
0ADE:  INCFSZ 62,W
0ADF:  SUBWF  6B,F
0AE0:  MOVF   6B,W
0AE1:  MOVWF  6D
0AE2:  MOVF   6A,W
0AE3:  MOVWF  6C
0AE4:  BCF    0A.3
0AE5:  CALL   794
0AE6:  BSF    0A.3
....................     } 
....................      if(servo==2) 
0AE7:  MOVF   69,W
0AE8:  SUBLW  02
0AE9:  BTFSS  03.2
0AEA:  GOTO   30A
....................     { 
....................       output_bit(PIN_D0,1); 
0AEB:  BSF    08.0
0AEC:  BSF    03.5
0AED:  BCF    08.0
....................       Delay4us(Ton); 
0AEE:  BCF    03.5
0AEF:  MOVF   62,W
0AF0:  MOVWF  6D
0AF1:  MOVF   61,W
0AF2:  MOVWF  6C
0AF3:  BCF    0A.3
0AF4:  CALL   794
0AF5:  BSF    0A.3
....................       output_bit(PIN_D0,0); 
0AF6:  BCF    08.0
0AF7:  BSF    03.5
0AF8:  BCF    08.0
....................       Delay4us(ChuKy-Ton); 
0AF9:  BCF    03.5
0AFA:  MOVF   61,W
0AFB:  SUBWF  63,W
0AFC:  MOVWF  6A
0AFD:  MOVF   64,W
0AFE:  MOVWF  6B
0AFF:  MOVF   62,W
0B00:  BTFSS  03.0
0B01:  INCFSZ 62,W
0B02:  SUBWF  6B,F
0B03:  MOVF   6B,W
0B04:  MOVWF  6D
0B05:  MOVF   6A,W
0B06:  MOVWF  6C
0B07:  BCF    0A.3
0B08:  CALL   794
0B09:  BSF    0A.3
....................     } 
0B0A:  MOVF   67,W
0B0B:  BTFSC  03.2
0B0C:  DECF   68,F
0B0D:  DECF   67,F
0B0E:  GOTO   2BD
....................    } 
0B0F:  RETURN
.................... } 
....................  
.................... void DC_motor_run() 
.................... { 
....................  
....................    setup_timer_2(T2_DIV_BY_16,207,1);      //665 us overflow, 665 us interrupt 
*
050C:  MOVLW  00
050D:  MOVWF  78
050E:  IORLW  06
050F:  MOVWF  12
0510:  MOVLW  CF
0511:  BSF    03.5
0512:  MOVWF  12
....................  
....................    setup_ccp1(CCP_PWM); 
0513:  BCF    03.5
0514:  BCF    32.2
0515:  MOVF   32,W
0516:  BSF    03.5
0517:  MOVWF  07
0518:  BCF    03.5
0519:  BCF    07.2
051A:  MOVLW  0C
051B:  MOVWF  17
....................    set_pwm1_duty((int16)249); 
051C:  MOVLW  3E
051D:  MOVWF  15
051E:  MOVF   17,W
051F:  ANDLW  CF
0520:  IORLW  10
0521:  MOVWF  17
....................    output_bit(PIN_C2,0); 
0522:  BCF    07.2
0523:  BCF    32.2
0524:  MOVF   32,W
0525:  BSF    03.5
0526:  MOVWF  07
0527:  BCF    03.5
0528:  BSF    0A.3
0529:  BCF    0A.4
052A:  GOTO   368 (RETURN)
.................... } 
.................... void DC_motor_off() 
.................... { 
.................... setup_ccp1(CCP_OFF); 
052B:  MOVLW  F0
052C:  ANDWF  17,F
052D:  BSF    0A.3
052E:  BCF    0A.4
052F:  GOTO   39E (RETURN)
....................  
.................... } 
.................... void WriteBack() 
.................... {  
....................    output_bit(PIN_D1,0); 
*
07A0:  BCF    08.1
07A1:  BSF    03.5
07A2:  BCF    08.1
....................    output_bit(PIN_D0,0); 
07A3:  BCF    03.5
07A4:  BCF    08.0
07A5:  BSF    03.5
07A6:  BCF    08.0
07A7:  BCF    03.5
07A8:  RETURN
.................... } 
....................  
.................... #INT_EXT 
.................... void  EXT_isr(void)  
.................... {   
....................    count=count+1.0; 
*
01AE:  BCF    03.1
01AF:  MOVF   54,W
01B0:  BSF    03.5
01B1:  MOVWF  43
01B2:  BCF    03.5
01B3:  MOVF   53,W
01B4:  BSF    03.5
01B5:  MOVWF  42
01B6:  BCF    03.5
01B7:  MOVF   52,W
01B8:  BSF    03.5
01B9:  MOVWF  41
01BA:  BCF    03.5
01BB:  MOVF   51,W
01BC:  BSF    03.5
01BD:  MOVWF  40
01BE:  CLRF   47
01BF:  CLRF   46
01C0:  CLRF   45
01C1:  MOVLW  7F
01C2:  MOVWF  44
01C3:  BCF    03.5
01C4:  CALL   068
01C5:  MOVF   7A,W
01C6:  MOVWF  54
01C7:  MOVF   79,W
01C8:  MOVWF  53
01C9:  MOVF   78,W
01CA:  MOVWF  52
01CB:  MOVF   77,W
01CC:  MOVWF  51
.................... } 
....................  
01CD:  BCF    0B.1
01CE:  BCF    0A.3
01CF:  BCF    0A.4
01D0:  GOTO   03B
.................... #INT_RB 
.................... void Stop() 
.................... { 
....................    if(Input(Pin_B5)==0) 
01D1:  BSF    03.5
01D2:  BSF    06.5
01D3:  BCF    03.5
01D4:  BTFSS  06.5
....................       {   
....................          isFromButtonPressed=0;      
01D5:  CLRF   35
....................       } 
.................... } 
....................  
01D6:  BCF    0B.0
01D7:  BCF    0A.3
01D8:  BCF    0A.4
01D9:  GOTO   03B
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  
.................... {  
....................    switch(color_flag) 
*
0207:  MOVF   4A,W
0208:  ADDLW  FC
0209:  BTFSC  03.0
020A:  GOTO   23F
020B:  ADDLW  04
020C:  GOTO   243
....................       {   
....................       case 0:  
....................               TCS_mode(0,0);               
020D:  BSF    03.5
020E:  CLRF   40
020F:  CLRF   41
0210:  BCF    03.5
0211:  CALL   1DA
....................               break; 
0212:  GOTO   23F
....................       case 1: red_freq=count; 
0213:  MOVF   54,W
0214:  MOVWF  58
0215:  MOVF   53,W
0216:  MOVWF  57
0217:  MOVF   52,W
0218:  MOVWF  56
0219:  MOVF   51,W
021A:  MOVWF  55
....................               TCS_mode(1,1);             
021B:  MOVLW  01
021C:  BSF    03.5
021D:  MOVWF  40
021E:  MOVWF  41
021F:  BCF    03.5
0220:  CALL   1DA
....................               break; 
0221:  GOTO   23F
....................       case 2: green_freq=count; 
0222:  MOVF   54,W
0223:  MOVWF  60
0224:  MOVF   53,W
0225:  MOVWF  5F
0226:  MOVF   52,W
0227:  MOVWF  5E
0228:  MOVF   51,W
0229:  MOVWF  5D
....................               TCS_mode(0,1); 
022A:  BSF    03.5
022B:  CLRF   40
022C:  MOVLW  01
022D:  MOVWF  41
022E:  BCF    03.5
022F:  CALL   1DA
....................               break; 
0230:  GOTO   23F
....................       case 3: blue_freq=count; 
0231:  MOVF   54,W
0232:  MOVWF  5C
0233:  MOVF   53,W
0234:  MOVWF  5B
0235:  MOVF   52,W
0236:  MOVWF  5A
0237:  MOVF   51,W
0238:  MOVWF  59
....................               TCS_mode(1,0); 
0239:  MOVLW  01
023A:  BSF    03.5
023B:  MOVWF  40
023C:  CLRF   41
023D:  BCF    03.5
023E:  CALL   1DA
....................               break; 
....................       } 
.................... } 
023F:  BCF    0C.0
0240:  BCF    0A.3
0241:  BCF    0A.4
0242:  GOTO   03B
.................... #INT_RDA 
.................... void data_rec() 
.................... { 
....................  
....................    memset(&data_received[0],0,sizeof(data_received)); 
*
034D:  MOVLW  38
034E:  MOVWF  04
034F:  BCF    03.7
0350:  CLRF   77
0351:  MOVLW  05
0352:  MOVWF  78
....................    get_data(); 
....................    on_off=atoi(&data_received[0]); 
*
037F:  BSF    03.5
0380:  CLRF   41
0381:  MOVLW  38
0382:  MOVWF  40
0383:  BCF    03.5
0384:  CALL   24B
0385:  MOVF   78,W
0386:  MOVWF  4B
....................    sp_stop=atoi(&data_received[3]); 
0387:  BSF    03.5
0388:  CLRF   41
0389:  MOVLW  3B
038A:  MOVWF  40
038B:  BCF    03.5
038C:  CALL   24B
038D:  MOVF   78,W
038E:  MOVWF  4E
....................    time_stop=atoi(&data_received[4]); 
038F:  BSF    03.5
0390:  CLRF   41
0391:  MOVLW  3C
0392:  MOVWF  40
0393:  BCF    03.5
0394:  CALL   24B
0395:  MOVF   78,W
0396:  MOVWF  4F
....................    switch(data_received[1]) 
0397:  MOVF   39,W
0398:  XORLW  4C
0399:  BTFSC  03.2
039A:  GOTO   3A2
039B:  XORLW  01
039C:  BTFSC  03.2
039D:  GOTO   3A5
039E:  XORLW  05
039F:  BTFSC  03.2
03A0:  GOTO   3A8
03A1:  GOTO   3AA
....................    {   
....................       case 'L' :speed_mode=LOW_;break; 
03A2:  MOVLW  01
03A3:  MOVWF  4C
03A4:  GOTO   3AA
....................       case 'M' :speed_mode=MEDIUM;break; 
03A5:  MOVLW  02
03A6:  MOVWF  4C
03A7:  GOTO   3AA
....................       case 'H' :speed_mode=HIGH_;break; 
03A8:  MOVLW  03
03A9:  MOVWF  4C
....................    } 
....................    switch(data_received[2]) 
03AA:  MOVF   3A,W
03AB:  XORLW  6C
03AC:  BTFSC  03.2
03AD:  GOTO   3B5
03AE:  XORLW  01
03AF:  BTFSC  03.2
03B0:  GOTO   3B8
03B1:  XORLW  05
03B2:  BTFSC  03.2
03B3:  GOTO   3BB
03B4:  GOTO   3BD
....................    {   
....................       case 'l' :freq_mode=LOW_;break; 
03B5:  MOVLW  01
03B6:  MOVWF  4D
03B7:  GOTO   3BD
....................       case 'm' :freq_mode=MEDIUM;break; 
03B8:  MOVLW  02
03B9:  MOVWF  4D
03BA:  GOTO   3BD
....................       case 'h' :freq_mode=HIGH_;break; 
03BB:  MOVLW  03
03BC:  MOVWF  4D
....................    } 
....................  
03BD:  BCF    0C.5
03BE:  BCF    0A.3
03BF:  BCF    0A.4
03C0:  GOTO   03B
.................... } 
.................... unsigned char TCS3200_getcolor() 
.................... { done=0; 
*
0673:  CLRF   36
....................   setup_timer_1(T1_internal | T1_div_by_8); 
0674:  MOVLW  B5
0675:  MOVWF  10
....................   set_timer1(3036); 
0676:  CLRF   0E
0677:  MOVLW  0B
0678:  MOVWF  0F
0679:  MOVLW  DC
067A:  MOVWF  0E
....................    
....................   while(!done){}; 
067B:  MOVF   36,F
067C:  BTFSC  03.2
067D:  GOTO   67B
....................            /*red_freq= Map(red_freq,500,1650,0,255); 
....................            blue_freq= Map(blue_freq,600,1600,0,255); 
....................            green_freq= Map(green_freq,400,1000,0,255);*/ 
....................            cycle++;     
067E:  INCF   37,F
....................            sum=red_product+blue_product+green_product; 
067F:  MOVF   47,W
0680:  ADDWF  46,W
0681:  ADDWF  48,W
0682:  MOVWF  49
....................            printf("%d|%d|%d|%d\r\n",red_product,blue_product,green_product,sum); 
0683:  MOVF   46,W
0684:  MOVWF  65
0685:  MOVLW  18
0686:  MOVWF  66
0687:  CALL   5D9
0688:  MOVLW  7C
0689:  BTFSS  0C.4
068A:  GOTO   689
068B:  MOVWF  19
068C:  MOVF   47,W
068D:  MOVWF  65
068E:  MOVLW  18
068F:  MOVWF  66
0690:  CALL   5D9
0691:  MOVLW  7C
0692:  BTFSS  0C.4
0693:  GOTO   692
0694:  MOVWF  19
0695:  MOVF   48,W
0696:  MOVWF  65
0697:  MOVLW  18
0698:  MOVWF  66
0699:  CALL   5D9
069A:  MOVLW  7C
069B:  BTFSS  0C.4
069C:  GOTO   69B
069D:  MOVWF  19
069E:  MOVF   49,W
069F:  MOVWF  65
06A0:  MOVLW  18
06A1:  MOVWF  66
06A2:  CALL   5D9
06A3:  MOVLW  0D
06A4:  BTFSS  0C.4
06A5:  GOTO   6A4
06A6:  MOVWF  19
06A7:  MOVLW  0A
06A8:  BTFSS  0C.4
06A9:  GOTO   6A8
06AA:  MOVWF  19
....................             
....................              
....................   if (((red_freq < 150) && (blue_freq < 150)) || ((green_freq < 150) && (blue_freq < 150)) || ((red_freq < 150) && (green_freq < 150))) 
06AB:  MOVF   58,W
06AC:  MOVWF  68
06AD:  MOVF   57,W
06AE:  MOVWF  67
06AF:  MOVF   56,W
06B0:  MOVWF  66
06B1:  MOVF   55,W
06B2:  MOVWF  65
06B3:  CLRF   6C
06B4:  CLRF   6B
06B5:  MOVLW  16
06B6:  MOVWF  6A
06B7:  MOVLW  86
06B8:  MOVWF  69
06B9:  CALL   634
06BA:  BTFSS  03.0
06BB:  GOTO   6CD
06BC:  MOVF   5C,W
06BD:  MOVWF  68
06BE:  MOVF   5B,W
06BF:  MOVWF  67
06C0:  MOVF   5A,W
06C1:  MOVWF  66
06C2:  MOVF   59,W
06C3:  MOVWF  65
06C4:  CLRF   6C
06C5:  CLRF   6B
06C6:  MOVLW  16
06C7:  MOVWF  6A
06C8:  MOVLW  86
06C9:  MOVWF  69
06CA:  CALL   634
06CB:  BTFSC  03.0
06CC:  GOTO   711
06CD:  MOVF   60,W
06CE:  MOVWF  68
06CF:  MOVF   5F,W
06D0:  MOVWF  67
06D1:  MOVF   5E,W
06D2:  MOVWF  66
06D3:  MOVF   5D,W
06D4:  MOVWF  65
06D5:  CLRF   6C
06D6:  CLRF   6B
06D7:  MOVLW  16
06D8:  MOVWF  6A
06D9:  MOVLW  86
06DA:  MOVWF  69
06DB:  CALL   634
06DC:  BTFSS  03.0
06DD:  GOTO   6EF
06DE:  MOVF   5C,W
06DF:  MOVWF  68
06E0:  MOVF   5B,W
06E1:  MOVWF  67
06E2:  MOVF   5A,W
06E3:  MOVWF  66
06E4:  MOVF   59,W
06E5:  MOVWF  65
06E6:  CLRF   6C
06E7:  CLRF   6B
06E8:  MOVLW  16
06E9:  MOVWF  6A
06EA:  MOVLW  86
06EB:  MOVWF  69
06EC:  CALL   634
06ED:  BTFSC  03.0
06EE:  GOTO   711
06EF:  MOVF   58,W
06F0:  MOVWF  68
06F1:  MOVF   57,W
06F2:  MOVWF  67
06F3:  MOVF   56,W
06F4:  MOVWF  66
06F5:  MOVF   55,W
06F6:  MOVWF  65
06F7:  CLRF   6C
06F8:  CLRF   6B
06F9:  MOVLW  16
06FA:  MOVWF  6A
06FB:  MOVLW  86
06FC:  MOVWF  69
06FD:  CALL   634
06FE:  BTFSS  03.0
06FF:  GOTO   715
0700:  MOVF   60,W
0701:  MOVWF  68
0702:  MOVF   5F,W
0703:  MOVWF  67
0704:  MOVF   5E,W
0705:  MOVWF  66
0706:  MOVF   5D,W
0707:  MOVWF  65
0708:  CLRF   6C
0709:  CLRF   6B
070A:  MOVLW  16
070B:  MOVWF  6A
070C:  MOVLW  86
070D:  MOVWF  69
070E:  CALL   634
070F:  BTFSS  03.0
0710:  GOTO   715
....................         return UNIDENTIFIED; 
0711:  MOVLW  00
0712:  MOVWF  78
0713:  GOTO   791
0714:  GOTO   791
....................   else 
....................     { 
....................         if ((red_freq > blue_freq) && (red_freq > green_freq)) 
0715:  MOVF   5C,W
0716:  MOVWF  68
0717:  MOVF   5B,W
0718:  MOVWF  67
0719:  MOVF   5A,W
071A:  MOVWF  66
071B:  MOVF   59,W
071C:  MOVWF  65
071D:  MOVF   58,W
071E:  MOVWF  6C
071F:  MOVF   57,W
0720:  MOVWF  6B
0721:  MOVF   56,W
0722:  MOVWF  6A
0723:  MOVF   55,W
0724:  MOVWF  69
0725:  CALL   634
0726:  BTFSS  03.0
0727:  GOTO   73F
0728:  MOVF   60,W
0729:  MOVWF  68
072A:  MOVF   5F,W
072B:  MOVWF  67
072C:  MOVF   5E,W
072D:  MOVWF  66
072E:  MOVF   5D,W
072F:  MOVWF  65
0730:  MOVF   58,W
0731:  MOVWF  6C
0732:  MOVF   57,W
0733:  MOVWF  6B
0734:  MOVF   56,W
0735:  MOVWF  6A
0736:  MOVF   55,W
0737:  MOVWF  69
0738:  CALL   634
0739:  BTFSS  03.0
073A:  GOTO   73F
....................             return COLOR_RED; 
073B:  MOVLW  01
073C:  MOVWF  78
073D:  GOTO   791
073E:  GOTO   791
....................         else if ((blue_freq > red_freq) && (blue_freq > green_freq)) 
073F:  MOVF   58,W
0740:  MOVWF  68
0741:  MOVF   57,W
0742:  MOVWF  67
0743:  MOVF   56,W
0744:  MOVWF  66
0745:  MOVF   55,W
0746:  MOVWF  65
0747:  MOVF   5C,W
0748:  MOVWF  6C
0749:  MOVF   5B,W
074A:  MOVWF  6B
074B:  MOVF   5A,W
074C:  MOVWF  6A
074D:  MOVF   59,W
074E:  MOVWF  69
074F:  CALL   634
0750:  BTFSS  03.0
0751:  GOTO   769
0752:  MOVF   60,W
0753:  MOVWF  68
0754:  MOVF   5F,W
0755:  MOVWF  67
0756:  MOVF   5E,W
0757:  MOVWF  66
0758:  MOVF   5D,W
0759:  MOVWF  65
075A:  MOVF   5C,W
075B:  MOVWF  6C
075C:  MOVF   5B,W
075D:  MOVWF  6B
075E:  MOVF   5A,W
075F:  MOVWF  6A
0760:  MOVF   59,W
0761:  MOVWF  69
0762:  CALL   634
0763:  BTFSS  03.0
0764:  GOTO   769
....................             return COLOR_BLUE; 
0765:  MOVLW  02
0766:  MOVWF  78
0767:  GOTO   791
0768:  GOTO   791
....................         else if ((green_freq > red_freq) && (green_freq > blue_freq)) 
0769:  MOVF   58,W
076A:  MOVWF  68
076B:  MOVF   57,W
076C:  MOVWF  67
076D:  MOVF   56,W
076E:  MOVWF  66
076F:  MOVF   55,W
0770:  MOVWF  65
0771:  MOVF   60,W
0772:  MOVWF  6C
0773:  MOVF   5F,W
0774:  MOVWF  6B
0775:  MOVF   5E,W
0776:  MOVWF  6A
0777:  MOVF   5D,W
0778:  MOVWF  69
0779:  CALL   634
077A:  BTFSS  03.0
077B:  GOTO   791
077C:  MOVF   5C,W
077D:  MOVWF  68
077E:  MOVF   5B,W
077F:  MOVWF  67
0780:  MOVF   5A,W
0781:  MOVWF  66
0782:  MOVF   59,W
0783:  MOVWF  65
0784:  MOVF   60,W
0785:  MOVWF  6C
0786:  MOVF   5F,W
0787:  MOVWF  6B
0788:  MOVF   5E,W
0789:  MOVWF  6A
078A:  MOVF   5D,W
078B:  MOVWF  69
078C:  CALL   634
078D:  BTFSS  03.0
078E:  GOTO   791
....................             return COLOR_GREEN; 
078F:  MOVLW  03
0790:  MOVWF  78
....................     }     
0791:  BSF    0A.3
0792:  BCF    0A.4
0793:  GOTO   3D1 (RETURN)
.................... } 
....................  
.................... void main() 
*
0B10:  MOVF   03,W
0B11:  ANDLW  1F
0B12:  MOVWF  03
0B13:  MOVLW  81
0B14:  BSF    03.5
0B15:  MOVWF  19
0B16:  MOVLW  A6
0B17:  MOVWF  18
0B18:  MOVLW  90
0B19:  BCF    03.5
0B1A:  MOVWF  18
0B1B:  MOVLW  FF
0B1C:  MOVWF  32
0B1D:  CLRF   33
0B1E:  CLRF   34
0B1F:  CLRF   35
0B20:  CLRF   36
0B21:  CLRF   41
0B22:  CLRF   42
0B23:  CLRF   43
0B24:  CLRF   44
0B25:  CLRF   45
0B26:  CLRF   46
0B27:  CLRF   47
0B28:  CLRF   48
0B29:  MOVLW  27
0B2A:  MOVWF  64
0B2B:  MOVLW  10
0B2C:  MOVWF  63
0B2D:  BSF    03.5
0B2E:  BSF    1F.0
0B2F:  BSF    1F.1
0B30:  BSF    1F.2
0B31:  BCF    1F.3
0B32:  MOVLW  07
0B33:  MOVWF  1C
0B34:  BCF    03.7
....................  
.................... {  port_b_pullups(true); 
*
0B48:  BSF    03.5
0B49:  BCF    01.7
....................    lcd_init();  
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  GOTO   4C0
0B4D:  BSF    0A.3
....................    enable_interrupts(INT_EXT); 
0B4E:  BSF    0B.4
....................    enable_interrupts(INT_rb); 
0B4F:  BSF    0B.3
....................    enable_interrupts(INT_RDA); 
0B50:  BSF    03.5
0B51:  BSF    0C.5
....................    enable_interrupts(INT_TIMER1); 
0B52:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0B53:  MOVLW  C0
0B54:  BCF    03.5
0B55:  IORWF  0B,F
....................    set_tris_b(0x31); 
0B56:  MOVLW  31
0B57:  BSF    03.5
0B58:  MOVWF  06
....................  
.................... while (1){ 
....................     
....................       if(Input(Pin_B4)==0) 
0B59:  BSF    06.4
0B5A:  BCF    03.5
0B5B:  BTFSC  06.4
0B5C:  GOTO   35F
....................       {       
....................          isFromButtonPressed=1;      
0B5D:  MOVLW  01
0B5E:  MOVWF  35
....................       }      
....................       
....................       if ((on_off==ON_) && !is_running)         
0B5F:  DECFSZ 4B,W
0B60:  GOTO   394
0B61:  MOVF   50,F
0B62:  BTFSS  03.2
0B63:  GOTO   394
....................           {  is_running=1; 
0B64:  MOVLW  01
0B65:  MOVWF  50
....................              DC_motor_run(); 
0B66:  BCF    0A.3
0B67:  GOTO   50C
0B68:  BSF    0A.3
....................              count_enable = 1; 
0B69:  MOVLW  01
0B6A:  MOVWF  34
....................              switch(freq_mode) 
0B6B:  MOVF   4D,W
0B6C:  XORLW  01
0B6D:  BTFSC  03.2
0B6E:  GOTO   376
0B6F:  XORLW  03
0B70:  BTFSC  03.2
0B71:  GOTO   380
0B72:  XORLW  01
0B73:  BTFSC  03.2
0B74:  GOTO   38A
0B75:  GOTO   393
....................              { 
....................              case LOW_: output_low(S_0); 
0B76:  MOVLW  E0
0B77:  BSF    03.5
0B78:  MOVWF  05
0B79:  BCF    03.5
0B7A:  BCF    05.0
....................                         output_high(S_1); 
0B7B:  BSF    03.5
0B7C:  MOVWF  05
0B7D:  BCF    03.5
0B7E:  BSF    05.1
....................                         break; 
0B7F:  GOTO   393
....................              case MEDIUM: output_low(S_1); 
0B80:  MOVLW  E0
0B81:  BSF    03.5
0B82:  MOVWF  05
0B83:  BCF    03.5
0B84:  BCF    05.1
....................                           output_high(S_0); 
0B85:  BSF    03.5
0B86:  MOVWF  05
0B87:  BCF    03.5
0B88:  BSF    05.0
....................                         break; 
0B89:  GOTO   393
....................              case HIGH_: output_high(S_0); 
0B8A:  MOVLW  E0
0B8B:  BSF    03.5
0B8C:  MOVWF  05
0B8D:  BCF    03.5
0B8E:  BSF    05.0
....................                         output_high(S_1); 
0B8F:  BSF    03.5
0B90:  MOVWF  05
0B91:  BCF    03.5
0B92:  BSF    05.1
....................                         break;  
....................              }          
....................           } 
0B93:  GOTO   3CC
....................                      
....................       else if ((on_off==OFF_)&&is_running) 
0B94:  MOVF   4B,F
0B95:  BTFSS  03.2
0B96:  GOTO   3CC
0B97:  MOVF   50,F
0B98:  BTFSC  03.2
0B99:  GOTO   3CC
....................       {     is_running=0; 
0B9A:  CLRF   50
....................             count_enable = 0; 
0B9B:  CLRF   34
....................             DC_motor_off(); 
0B9C:  BCF    0A.3
0B9D:  GOTO   52B
0B9E:  BSF    0A.3
....................             color_count = red_count = blue_count = green_count = blind_count = 0; 
0B9F:  CLRF   45
0BA0:  MOVF   45,W
0BA1:  MOVWF  44
0BA2:  MOVWF  43
0BA3:  MOVWF  42
0BA4:  MOVWF  41
....................             red_product = blue_product = green_product = 0; 
0BA5:  CLRF   48
0BA6:  MOVF   48,W
0BA7:  MOVWF  47
0BA8:  MOVWF  46
....................             has_product = 0; 
0BA9:  CLRF   33
....................             {  
....................                lcd_putc("\f"); 
0BAA:  MOVLW  C1
0BAB:  BSF    03.6
0BAC:  MOVWF  0D
0BAD:  MOVLW  03
0BAE:  MOVWF  0F
0BAF:  BCF    0A.3
0BB0:  BCF    03.6
0BB1:  CALL   56E
0BB2:  BSF    0A.3
....................                lcd_gotoxy(5,1); 
0BB3:  MOVLW  05
0BB4:  MOVWF  69
0BB5:  MOVLW  01
0BB6:  MOVWF  6A
0BB7:  BCF    0A.3
0BB8:  CALL   530
0BB9:  BSF    0A.3
....................                printf(lcd_putc,"STOPP !!!"); 
0BBA:  MOVLW  C2
0BBB:  BSF    03.6
0BBC:  MOVWF  0D
0BBD:  MOVLW  03
0BBE:  MOVWF  0F
0BBF:  BCF    0A.3
0BC0:  BCF    03.6
0BC1:  CALL   56E
0BC2:  BSF    0A.3
....................                delay_ms(500); 
0BC3:  MOVLW  02
0BC4:  MOVWF  65
0BC5:  MOVLW  FA
0BC6:  MOVWF  6A
0BC7:  BCF    0A.3
0BC8:  CALL   3DF
0BC9:  BSF    0A.3
0BCA:  DECFSZ 65,F
0BCB:  GOTO   3C5
....................             } 
....................       } 
....................        
....................       if (count_enable) 
0BCC:  MOVF   34,F
0BCD:  BTFSC  03.2
0BCE:  GOTO   4C1
....................       {             
....................             switch(TCS3200_getColor()) 
0BCF:  BCF    0A.3
0BD0:  GOTO   673
0BD1:  BSF    0A.3
0BD2:  MOVF   78,W
0BD3:  ADDLW  FC
0BD4:  BTFSC  03.0
0BD5:  GOTO   3DF
0BD6:  ADDLW  04
0BD7:  GOTO   4E3
....................             { 
....................             case COLOR_RED : 
....................                 red_count++; 
0BD8:  INCF   42,F
....................                 break; 
0BD9:  GOTO   3DF
....................             case COLOR_BLUE : 
....................                 blue_count++; 
0BDA:  INCF   43,F
....................                 break; 
0BDB:  GOTO   3DF
....................             case COLOR_GREEN : 
....................                 green_count++; 
0BDC:  INCF   44,F
....................                 break; 
0BDD:  GOTO   3DF
....................             case UNIDENTIFIED : 
....................                 blind_count++; 
0BDE:  INCF   45,F
....................                 break; 
....................             } 
....................          
....................             color_count++; 
0BDF:  INCF   41,F
.................... //!                        lcd_putc("\f"); 
.................... //!                        lcd_gotoxy(7,2); 
.................... //!                        lcd_putc(red_count+0x30);        
.................... //!                        lcd_gotoxy(1,2); 
.................... //!                        lcd_putc(has_product+0x30);      
....................             if (color_count >= COLOR_COUNT_MAX) 
0BE0:  MOVF   41,W
0BE1:  SUBLW  03
0BE2:  BTFSC  03.0
0BE3:  GOTO   439
....................             { 
....................                 color_count = 0; 
0BE4:  CLRF   41
....................                  
....................                 if (!has_product) 
0BE5:  MOVF   33,F
0BE6:  BTFSS  03.2
0BE7:  GOTO   428
....................                 {             
....................                     if ((red_count > blue_count) && (red_count > green_count) && (red_count > blind_count)) 
0BE8:  MOVF   42,W
0BE9:  SUBWF  43,W
0BEA:  BTFSC  03.0
0BEB:  GOTO   3F9
0BEC:  MOVF   42,W
0BED:  SUBWF  44,W
0BEE:  BTFSC  03.0
0BEF:  GOTO   3F9
0BF0:  MOVF   42,W
0BF1:  SUBWF  45,W
0BF2:  BTFSC  03.0
0BF3:  GOTO   3F9
....................                      {  
....................                       
....................                         red_product++; 
0BF4:  INCF   46,F
....................                         has_product = 1; 
0BF5:  MOVLW  01
0BF6:  MOVWF  33
....................                         has_red=1; 
0BF7:  MOVWF  3E
....................                     }                  
0BF8:  GOTO   427
....................                     else if ((blue_count > red_count) && (blue_count > green_count) && (blue_count > blind_count)) 
0BF9:  MOVF   43,W
0BFA:  SUBWF  42,W
0BFB:  BTFSC  03.0
0BFC:  GOTO   40A
0BFD:  MOVF   43,W
0BFE:  SUBWF  44,W
0BFF:  BTFSC  03.0
0C00:  GOTO   40A
0C01:  MOVF   43,W
0C02:  SUBWF  45,W
0C03:  BTFSC  03.0
0C04:  GOTO   40A
....................                     { 
....................  
....................                         blue_product++; 
0C05:  INCF   47,F
....................                         has_product = 1; 
0C06:  MOVLW  01
0C07:  MOVWF  33
....................                         has_blue=1; 
0C08:  MOVWF  3F
....................                     } 
0C09:  GOTO   427
....................                     else if ((green_count > red_count) && (green_count > blue_count) && (green_count > blind_count)) 
0C0A:  MOVF   44,W
0C0B:  SUBWF  42,W
0C0C:  BTFSC  03.0
0C0D:  GOTO   41B
0C0E:  MOVF   44,W
0C0F:  SUBWF  43,W
0C10:  BTFSC  03.0
0C11:  GOTO   41B
0C12:  MOVF   44,W
0C13:  SUBWF  45,W
0C14:  BTFSC  03.0
0C15:  GOTO   41B
....................                     { 
....................  
....................                         green_product++; 
0C16:  INCF   48,F
....................                         has_product = 1; 
0C17:  MOVLW  01
0C18:  MOVWF  33
....................                         has_green=1; 
0C19:  MOVWF  40
....................                     } 
0C1A:  GOTO   427
....................                     else if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0C1B:  MOVF   45,W
0C1C:  SUBWF  42,W
0C1D:  BTFSC  03.0
0C1E:  GOTO   427
0C1F:  MOVF   45,W
0C20:  SUBWF  44,W
0C21:  BTFSC  03.0
0C22:  GOTO   427
0C23:  MOVF   45,W
0C24:  SUBWF  43,W
0C25:  BTFSC  03.0
0C26:  GOTO   427
....................                     { 
....................  
....................                     } 
....................                 } 
0C27:  GOTO   434
....................                 else 
....................                 { 
....................                     if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0C28:  MOVF   45,W
0C29:  SUBWF  42,W
0C2A:  BTFSC  03.0
0C2B:  GOTO   434
0C2C:  MOVF   45,W
0C2D:  SUBWF  44,W
0C2E:  BTFSC  03.0
0C2F:  GOTO   434
0C30:  MOVF   45,W
0C31:  SUBWF  43,W
0C32:  BTFSS  03.0
....................                         has_product = 0; 
0C33:  CLRF   33
....................                         
....................                 } 
....................                              
....................                 red_count = blue_count = green_count = blind_count = 0; 
0C34:  CLRF   45
0C35:  MOVF   45,W
0C36:  MOVWF  44
0C37:  MOVWF  43
0C38:  MOVWF  42
....................                 
....................             } 
....................         
....................             lcd_putc("\f"); 
0C39:  MOVLW  C7
0C3A:  BSF    03.6
0C3B:  MOVWF  0D
0C3C:  MOVLW  03
0C3D:  MOVWF  0F
0C3E:  BCF    0A.3
0C3F:  BCF    03.6
0C40:  CALL   56E
0C41:  BSF    0A.3
....................             lcd_putc("RD   BL  GR "); 
0C42:  MOVLW  C8
0C43:  BSF    03.6
0C44:  MOVWF  0D
0C45:  MOVLW  03
0C46:  MOVWF  0F
0C47:  BCF    0A.3
0C48:  BCF    03.6
0C49:  CALL   56E
0C4A:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
0C4B:  MOVLW  01
0C4C:  MOVWF  69
0C4D:  MOVLW  02
0C4E:  MOVWF  6A
0C4F:  BCF    0A.3
0C50:  CALL   530
0C51:  BSF    0A.3
....................             lcd_putc(red_product+0x30); 
0C52:  MOVLW  30
0C53:  ADDWF  46,W
0C54:  MOVWF  65
0C55:  MOVWF  68
0C56:  BCF    0A.3
0C57:  CALL   542
0C58:  BSF    0A.3
....................             lcd_gotoxy(5,2); 
0C59:  MOVLW  05
0C5A:  MOVWF  69
0C5B:  MOVLW  02
0C5C:  MOVWF  6A
0C5D:  BCF    0A.3
0C5E:  CALL   530
0C5F:  BSF    0A.3
....................             lcd_putc(blue_product+0x30); 
0C60:  MOVLW  30
0C61:  ADDWF  47,W
0C62:  MOVWF  65
0C63:  MOVWF  68
0C64:  BCF    0A.3
0C65:  CALL   542
0C66:  BSF    0A.3
....................             lcd_gotoxy(9,2); 
0C67:  MOVLW  09
0C68:  MOVWF  69
0C69:  MOVLW  02
0C6A:  MOVWF  6A
0C6B:  BCF    0A.3
0C6C:  CALL   530
0C6D:  BSF    0A.3
....................             lcd_putc(green_product+0x30);  
0C6E:  MOVLW  30
0C6F:  ADDWF  48,W
0C70:  MOVWF  65
0C71:  MOVWF  68
0C72:  BCF    0A.3
0C73:  CALL   542
0C74:  BSF    0A.3
....................             lcd_gotoxy(4,1); 
0C75:  MOVLW  04
0C76:  MOVWF  69
0C77:  MOVLW  01
0C78:  MOVWF  6A
0C79:  BCF    0A.3
0C7A:  CALL   530
0C7B:  BSF    0A.3
....................             lcd_putc(input_state(pin_C2)+0x30); 
0C7C:  MOVLW  00
0C7D:  BTFSC  07.2
0C7E:  MOVLW  01
0C7F:  ADDLW  30
0C80:  MOVWF  65
0C81:  MOVWF  68
0C82:  BCF    0A.3
0C83:  CALL   542
0C84:  BSF    0A.3
....................            if(has_red) 
0C85:  MOVF   3E,F
0C86:  BTFSC  03.2
0C87:  GOTO   4A1
....................             { 
....................               if(!input_state(pin_E0)) 
0C88:  BTFSC  09.0
0C89:  GOTO   4A1
....................              {//servo1  
....................                Write(120,1000,1); 
0C8A:  CLRF   66
0C8B:  MOVLW  78
0C8C:  MOVWF  65
0C8D:  MOVLW  03
0C8E:  MOVWF  68
0C8F:  MOVLW  E8
0C90:  MOVWF  67
0C91:  MOVLW  01
0C92:  MOVWF  69
0C93:  CALL   000
....................                Write(0,1000,1); 
0C94:  CLRF   66
0C95:  CLRF   65
0C96:  MOVLW  03
0C97:  MOVWF  68
0C98:  MOVLW  E8
0C99:  MOVWF  67
0C9A:  MOVLW  01
0C9B:  MOVWF  69
0C9C:  CALL   000
....................                WriteBack();                 
0C9D:  BCF    0A.3
0C9E:  CALL   7A0
0C9F:  BSF    0A.3
....................                has_red=0; 
0CA0:  CLRF   3E
....................  
....................              } 
....................                 
....................             } 
....................              
....................             if(has_blue) 
0CA1:  MOVF   3F,F
0CA2:  BTFSC  03.2
0CA3:  GOTO   4BD
....................              {  
....................              if(!input_state(pin_C2)){has_blue=0;} 
0CA4:  BTFSS  07.2
0CA5:  CLRF   3F
....................               //Oservo2 
....................               { 
....................                Write(120,1000,2); 
0CA6:  CLRF   66
0CA7:  MOVLW  78
0CA8:  MOVWF  65
0CA9:  MOVLW  03
0CAA:  MOVWF  68
0CAB:  MOVLW  E8
0CAC:  MOVWF  67
0CAD:  MOVLW  02
0CAE:  MOVWF  69
0CAF:  CALL   000
....................                Write(0,1000,2); 
0CB0:  CLRF   66
0CB1:  CLRF   65
0CB2:  MOVLW  03
0CB3:  MOVWF  68
0CB4:  MOVLW  E8
0CB5:  MOVWF  67
0CB6:  MOVLW  02
0CB7:  MOVWF  69
0CB8:  CALL   000
....................                WriteBack();                 
0CB9:  BCF    0A.3
0CBA:  CALL   7A0
0CBB:  BSF    0A.3
....................                has_blue=0; 
0CBC:  CLRF   3F
....................               } 
....................              } 
....................              if(has_green) 
0CBD:  MOVF   40,F
0CBE:  BTFSS  03.2
....................              { 
....................                has_green=0; 
0CBF:  CLRF   40
....................              } 
....................                       
....................      //LCD 
....................       } 
0CC0:  GOTO   4E0
....................       else 
....................       {      
....................             lcd_gotoxy(1,1); 
0CC1:  MOVLW  01
0CC2:  MOVWF  69
0CC3:  MOVWF  6A
0CC4:  BCF    0A.3
0CC5:  CALL   530
0CC6:  BSF    0A.3
....................             lcd_putc("    MACH DEM SP"); 
0CC7:  MOVLW  CF
0CC8:  BSF    03.6
0CC9:  MOVWF  0D
0CCA:  MOVLW  03
0CCB:  MOVWF  0F
0CCC:  BCF    0A.3
0CCD:  BCF    03.6
0CCE:  CALL   56E
0CCF:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
0CD0:  MOVLW  01
0CD1:  MOVWF  69
0CD2:  MOVLW  02
0CD3:  MOVWF  6A
0CD4:  BCF    0A.3
0CD5:  CALL   530
0CD6:  BSF    0A.3
....................             lcd_putc("  CAM BIEN MAU"); 
0CD7:  MOVLW  D7
0CD8:  BSF    03.6
0CD9:  MOVWF  0D
0CDA:  MOVLW  03
0CDB:  MOVWF  0F
0CDC:  BCF    0A.3
0CDD:  BCF    03.6
0CDE:  CALL   56E
0CDF:  BSF    0A.3
....................       } 
0CE0:  BSF    03.5
0CE1:  GOTO   359
....................        
.................... } 
....................  
.................... } 
0CE2:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
