CCS PCM C Compiler, Version 5.025, 54110               23-Jul-20 15:40

               Filename:   C:\Users\Admin\Desktop\DoAnXuLyTin\color_sensor.lst

               ROM used:   3292 words (40%)
                           Largest free fragment is 2048
               RAM used:   75 (20%) at main() level
                           144 (39%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   67C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   05C
002B:  BTFSS  0B.4
002C:  GOTO   02F
002D:  BTFSC  0B.1
002E:  GOTO   05F
002F:  MOVLW  8C
0030:  MOVWF  04
0031:  BTFSS  00.5
0032:  GOTO   035
0033:  BTFSC  0C.5
0034:  GOTO   062
0035:  MOVLW  8C
0036:  MOVWF  04
0037:  BTFSS  00.0
0038:  GOTO   03B
0039:  BTFSC  0C.0
003A:  GOTO   065
003B:  MOVF   22,W
003C:  MOVWF  04
003D:  MOVF   23,W
003E:  MOVWF  77
003F:  MOVF   24,W
0040:  MOVWF  78
0041:  MOVF   25,W
0042:  MOVWF  79
0043:  MOVF   26,W
0044:  MOVWF  7A
0045:  MOVF   27,W
0046:  BSF    03.6
0047:  MOVWF  0D
0048:  BCF    03.6
0049:  MOVF   28,W
004A:  BSF    03.6
004B:  MOVWF  0F
004C:  BCF    03.6
004D:  MOVF   29,W
004E:  BSF    03.6
004F:  MOVWF  0C
0050:  BCF    03.6
0051:  MOVF   2A,W
0052:  BSF    03.6
0053:  MOVWF  0E
0054:  BCF    03.6
0055:  MOVF   20,W
0056:  MOVWF  0A
0057:  SWAPF  21,W
0058:  MOVWF  03
0059:  SWAPF  7F,F
005A:  SWAPF  7F,W
005B:  RETFIE
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   1D1
005F:  BCF    0A.3
0060:  BCF    0A.4
0061:  GOTO   1AE
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   353
0065:  BCF    0A.3
0066:  BCF    0A.4
0067:  GOTO   207
.................... #include <color_sensor.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0068:  MOVLW  80
0069:  BTFSS  03.1
006A:  GOTO   06E
006B:  BSF    03.5
006C:  XORWF  45,F
006D:  BCF    03.5
006E:  BSF    03.5
006F:  CLRF   4A
0070:  CLRF   4B
0071:  MOVF   41,W
0072:  MOVWF  49
0073:  MOVF   45,W
0074:  XORWF  49,F
0075:  MOVF   40,W
0076:  BTFSC  03.2
0077:  GOTO   15C
0078:  MOVWF  48
0079:  MOVWF  77
007A:  MOVF   44,W
007B:  BTFSC  03.2
007C:  GOTO   165
007D:  SUBWF  48,F
007E:  BTFSC  03.2
007F:  GOTO   101
0080:  BTFSS  03.0
0081:  GOTO   0BF
0082:  MOVF   45,W
0083:  MOVWF  4E
0084:  BSF    4E.7
0085:  MOVF   46,W
0086:  MOVWF  4D
0087:  MOVF   47,W
0088:  MOVWF  4C
0089:  CLRF   4B
008A:  BCF    03.0
008B:  RRF    4E,F
008C:  RRF    4D,F
008D:  RRF    4C,F
008E:  RRF    4B,F
008F:  DECFSZ 48,F
0090:  GOTO   089
0091:  BTFSS  49.7
0092:  GOTO   096
0093:  BSF    4A.0
0094:  GOTO   179
0095:  BCF    4A.0
0096:  BCF    48.0
0097:  BSF    4A.4
0098:  MOVLW  C3
0099:  MOVWF  04
009A:  BCF    03.7
009B:  GOTO   18E
009C:  BCF    4A.4
009D:  BTFSC  49.7
009E:  GOTO   0A9
009F:  BTFSS  48.0
00A0:  GOTO   0B4
00A1:  RRF    4E,F
00A2:  RRF    4D,F
00A3:  RRF    4C,F
00A4:  RRF    4B,F
00A5:  INCF   77,F
00A6:  BTFSC  03.2
00A7:  GOTO   174
00A8:  GOTO   0B4
00A9:  BTFSC  4E.7
00AA:  GOTO   0B7
00AB:  BCF    03.0
00AC:  RLF    4B,F
00AD:  RLF    4C,F
00AE:  RLF    4D,F
00AF:  RLF    4E,F
00B0:  DECF   77,F
00B1:  BTFSC  03.2
00B2:  GOTO   174
00B3:  GOTO   0A9
00B4:  BSF    4A.6
00B5:  GOTO   121
00B6:  BCF    4A.6
00B7:  MOVF   41,W
00B8:  MOVWF  49
00B9:  BTFSS  49.7
00BA:  GOTO   0BD
00BB:  BSF    4E.7
00BC:  GOTO   16D
00BD:  BCF    4E.7
00BE:  GOTO   16D
00BF:  MOVF   44,W
00C0:  MOVWF  48
00C1:  MOVWF  77
00C2:  MOVF   40,W
00C3:  SUBWF  48,F
00C4:  MOVF   41,W
00C5:  MOVWF  4E
00C6:  BSF    4E.7
00C7:  MOVF   42,W
00C8:  MOVWF  4D
00C9:  MOVF   43,W
00CA:  MOVWF  4C
00CB:  CLRF   4B
00CC:  BCF    03.0
00CD:  RRF    4E,F
00CE:  RRF    4D,F
00CF:  RRF    4C,F
00D0:  RRF    4B,F
00D1:  DECFSZ 48,F
00D2:  GOTO   0CB
00D3:  BTFSS  49.7
00D4:  GOTO   0D8
00D5:  BSF    4A.1
00D6:  GOTO   179
00D7:  BCF    4A.1
00D8:  BCF    48.0
00D9:  BSF    4A.5
00DA:  MOVLW  C7
00DB:  MOVWF  04
00DC:  BCF    03.7
00DD:  GOTO   18E
00DE:  BCF    4A.5
00DF:  BTFSC  49.7
00E0:  GOTO   0EB
00E1:  BTFSS  48.0
00E2:  GOTO   0F6
00E3:  RRF    4E,F
00E4:  RRF    4D,F
00E5:  RRF    4C,F
00E6:  RRF    4B,F
00E7:  INCF   77,F
00E8:  BTFSC  03.2
00E9:  GOTO   174
00EA:  GOTO   0F6
00EB:  BTFSC  4E.7
00EC:  GOTO   0F9
00ED:  BCF    03.0
00EE:  RLF    4B,F
00EF:  RLF    4C,F
00F0:  RLF    4D,F
00F1:  RLF    4E,F
00F2:  DECF   77,F
00F3:  BTFSC  03.2
00F4:  GOTO   174
00F5:  GOTO   0EB
00F6:  BSF    4A.7
00F7:  GOTO   121
00F8:  BCF    4A.7
00F9:  MOVF   45,W
00FA:  MOVWF  49
00FB:  BTFSS  49.7
00FC:  GOTO   0FF
00FD:  BSF    4E.7
00FE:  GOTO   16D
00FF:  BCF    4E.7
0100:  GOTO   16D
0101:  MOVF   45,W
0102:  MOVWF  4E
0103:  BSF    4E.7
0104:  MOVF   46,W
0105:  MOVWF  4D
0106:  MOVF   47,W
0107:  MOVWF  4C
0108:  BTFSS  49.7
0109:  GOTO   10E
010A:  BCF    4E.7
010B:  BSF    4A.2
010C:  GOTO   179
010D:  BCF    4A.2
010E:  CLRF   4B
010F:  BCF    48.0
0110:  MOVLW  C3
0111:  MOVWF  04
0112:  BCF    03.7
0113:  GOTO   18E
0114:  BTFSC  49.7
0115:  GOTO   137
0116:  MOVF   41,W
0117:  MOVWF  49
0118:  BTFSS  48.0
0119:  GOTO   121
011A:  RRF    4E,F
011B:  RRF    4D,F
011C:  RRF    4C,F
011D:  RRF    4B,F
011E:  INCF   77,F
011F:  BTFSC  03.2
0120:  GOTO   174
0121:  BTFSS  4B.7
0122:  GOTO   132
0123:  INCF   4C,F
0124:  BTFSS  03.2
0125:  GOTO   132
0126:  INCF   4D,F
0127:  BTFSS  03.2
0128:  GOTO   132
0129:  INCF   4E,F
012A:  BTFSS  03.2
012B:  GOTO   132
012C:  RRF    4E,F
012D:  RRF    4D,F
012E:  RRF    4C,F
012F:  INCF   77,F
0130:  BTFSC  03.2
0131:  GOTO   174
0132:  BTFSC  4A.6
0133:  GOTO   0B6
0134:  BTFSC  4A.7
0135:  GOTO   0F8
0136:  GOTO   156
0137:  MOVLW  80
0138:  XORWF  4E,F
0139:  BTFSS  4E.7
013A:  GOTO   13F
013B:  GOTO   179
013C:  MOVF   45,W
013D:  MOVWF  49
013E:  GOTO   14C
013F:  MOVF   41,W
0140:  MOVWF  49
0141:  MOVF   4E,F
0142:  BTFSS  03.2
0143:  GOTO   14C
0144:  MOVF   4D,F
0145:  BTFSS  03.2
0146:  GOTO   14C
0147:  MOVF   4C,F
0148:  BTFSS  03.2
0149:  GOTO   14C
014A:  CLRF   77
014B:  GOTO   16D
014C:  BTFSC  4E.7
014D:  GOTO   156
014E:  BCF    03.0
014F:  RLF    4B,F
0150:  RLF    4C,F
0151:  RLF    4D,F
0152:  RLF    4E,F
0153:  DECFSZ 77,F
0154:  GOTO   14C
0155:  GOTO   174
0156:  BTFSS  49.7
0157:  GOTO   15A
0158:  BSF    4E.7
0159:  GOTO   16D
015A:  BCF    4E.7
015B:  GOTO   16D
015C:  MOVF   44,W
015D:  MOVWF  77
015E:  MOVF   45,W
015F:  MOVWF  4E
0160:  MOVF   46,W
0161:  MOVWF  4D
0162:  MOVF   47,W
0163:  MOVWF  4C
0164:  GOTO   16D
0165:  MOVF   40,W
0166:  MOVWF  77
0167:  MOVF   41,W
0168:  MOVWF  4E
0169:  MOVF   42,W
016A:  MOVWF  4D
016B:  MOVF   43,W
016C:  MOVWF  4C
016D:  MOVF   4E,W
016E:  MOVWF  78
016F:  MOVF   4D,W
0170:  MOVWF  79
0171:  MOVF   4C,W
0172:  MOVWF  7A
0173:  GOTO   1AC
0174:  CLRF   77
0175:  CLRF   78
0176:  CLRF   79
0177:  CLRF   7A
0178:  GOTO   1AC
0179:  CLRF   4B
017A:  COMF   4C,F
017B:  COMF   4D,F
017C:  COMF   4E,F
017D:  COMF   4B,F
017E:  INCF   4B,F
017F:  BTFSS  03.2
0180:  GOTO   187
0181:  INCF   4C,F
0182:  BTFSS  03.2
0183:  GOTO   187
0184:  INCF   4D,F
0185:  BTFSC  03.2
0186:  INCF   4E,F
0187:  BTFSC  4A.0
0188:  GOTO   095
0189:  BTFSC  4A.1
018A:  GOTO   0D7
018B:  BTFSC  4A.2
018C:  GOTO   10D
018D:  GOTO   13C
018E:  MOVF   00,W
018F:  ADDWF  4C,F
0190:  BTFSS  03.0
0191:  GOTO   198
0192:  INCF   4D,F
0193:  BTFSS  03.2
0194:  GOTO   198
0195:  INCF   4E,F
0196:  BTFSC  03.2
0197:  BSF    48.0
0198:  DECF   04,F
0199:  MOVF   00,W
019A:  ADDWF  4D,F
019B:  BTFSS  03.0
019C:  GOTO   1A0
019D:  INCF   4E,F
019E:  BTFSC  03.2
019F:  BSF    48.0
01A0:  DECF   04,F
01A1:  MOVF   00,W
01A2:  BTFSS  00.7
01A3:  XORLW  80
01A4:  ADDWF  4E,F
01A5:  BTFSC  03.0
01A6:  BSF    48.0
01A7:  BTFSC  4A.4
01A8:  GOTO   09C
01A9:  BTFSC  4A.5
01AA:  GOTO   0DE
01AB:  GOTO   114
01AC:  BCF    03.5
01AD:  RETURN
*
0249:  BCF    0A.0
024A:  BSF    0A.1
024B:  BCF    0A.2
024C:  ADDWF  02,F
024D:  GOTO   20D
024E:  GOTO   213
024F:  GOTO   228
0250:  GOTO   237
*
02C0:  CLRF   77
02C1:  CLRF   78
02C2:  MOVF   47,W
02C3:  BCF    03.0
02C4:  BTFSC  48.0
02C5:  ADDWF  77,F
02C6:  RRF    77,F
02C7:  RRF    78,F
02C8:  BTFSC  48.1
02C9:  ADDWF  77,F
02CA:  RRF    77,F
02CB:  RRF    78,F
02CC:  BTFSC  48.2
02CD:  ADDWF  77,F
02CE:  RRF    77,F
02CF:  RRF    78,F
02D0:  BTFSC  48.3
02D1:  ADDWF  77,F
02D2:  RRF    77,F
02D3:  RRF    78,F
02D4:  BTFSC  48.4
02D5:  ADDWF  77,F
02D6:  RRF    77,F
02D7:  RRF    78,F
02D8:  BTFSC  48.5
02D9:  ADDWF  77,F
02DA:  RRF    77,F
02DB:  RRF    78,F
02DC:  BTFSC  48.6
02DD:  ADDWF  77,F
02DE:  RRF    77,F
02DF:  RRF    78,F
02E0:  BTFSC  48.7
02E1:  ADDWF  77,F
02E2:  RRF    77,F
02E3:  RRF    78,F
*
0359:  MOVF   78,W
035A:  BTFSC  03.2
035B:  GOTO   361
035C:  MOVF   77,W
035D:  MOVWF  00
035E:  INCF   04,F
035F:  DECFSZ 78,F
0360:  GOTO   35C
*
03C7:  DATA 52,22
03C8:  DATA 20,10
03C9:  DATA 20,21
03CA:  DATA 4C,10
03CB:  DATA A0,23
03CC:  DATA 52,10
03CD:  DATA 00,00
03CE:  DATA 0C,00
03CF:  DATA 52,22
03D0:  DATA 20,10
03D1:  DATA 20,21
03D2:  DATA 4C,10
03D3:  DATA A0,23
03D4:  DATA 52,10
03D5:  DATA 00,00
*
0541:  MOVF   0B,W
0542:  MOVWF  65
0543:  BCF    0B.7
0544:  BSF    03.5
0545:  BSF    03.6
0546:  BSF    0C.7
0547:  BSF    0C.0
0548:  NOP
0549:  NOP
054A:  BCF    03.5
054B:  BCF    03.6
054C:  BTFSC  65.7
054D:  BSF    0B.7
054E:  BSF    03.6
054F:  MOVF   0C,W
0550:  ANDLW  7F
0551:  BTFSC  03.2
0552:  GOTO   595
0553:  BCF    03.6
0554:  MOVWF  65
0555:  BSF    03.6
0556:  MOVF   0D,W
0557:  BCF    03.6
0558:  MOVWF  66
0559:  BSF    03.6
055A:  MOVF   0F,W
055B:  BCF    03.6
055C:  MOVWF  67
055D:  MOVF   65,W
055E:  MOVWF  68
055F:  CALL   515
0560:  MOVF   66,W
0561:  BSF    03.6
0562:  MOVWF  0D
0563:  BCF    03.6
0564:  MOVF   67,W
0565:  BSF    03.6
0566:  MOVWF  0F
0567:  BCF    03.6
0568:  MOVF   0B,W
0569:  MOVWF  68
056A:  BCF    0B.7
056B:  BSF    03.5
056C:  BSF    03.6
056D:  BSF    0C.7
056E:  BSF    0C.0
056F:  NOP
0570:  NOP
0571:  BCF    03.5
0572:  BCF    03.6
0573:  BTFSC  68.7
0574:  BSF    0B.7
0575:  BSF    03.6
0576:  RLF    0C,W
0577:  RLF    0E,W
0578:  ANDLW  7F
0579:  BTFSC  03.2
057A:  GOTO   595
057B:  BCF    03.6
057C:  MOVWF  65
057D:  BSF    03.6
057E:  MOVF   0D,W
057F:  BCF    03.6
0580:  MOVWF  66
0581:  BSF    03.6
0582:  MOVF   0F,W
0583:  BCF    03.6
0584:  MOVWF  67
0585:  MOVF   65,W
0586:  MOVWF  68
0587:  CALL   515
0588:  MOVF   66,W
0589:  BSF    03.6
058A:  MOVWF  0D
058B:  BCF    03.6
058C:  MOVF   67,W
058D:  BSF    03.6
058E:  MOVWF  0F
058F:  INCF   0D,F
0590:  BTFSC  03.2
0591:  INCF   0F,F
0592:  BCF    03.6
0593:  GOTO   541
0594:  BSF    03.6
0595:  BCF    03.6
0596:  RETURN
0597:  MOVLW  8E
0598:  MOVWF  77
0599:  BSF    03.5
059A:  MOVF   2C,W
059B:  SUBWF  77,F
059C:  MOVF   2D,W
059D:  MOVWF  79
059E:  MOVF   2E,W
059F:  MOVWF  78
05A0:  BSF    79.7
05A1:  MOVF   77,F
05A2:  BTFSC  03.2
05A3:  GOTO   5AF
05A4:  BCF    03.0
05A5:  MOVF   79,F
05A6:  BTFSS  03.2
05A7:  GOTO   5AB
05A8:  MOVF   78,F
05A9:  BTFSC  03.2
05AA:  GOTO   5AF
05AB:  RRF    79,F
05AC:  RRF    78,F
05AD:  DECFSZ 77,F
05AE:  GOTO   5A4
05AF:  BTFSS  2D.7
05B0:  GOTO   5B6
05B1:  COMF   78,F
05B2:  COMF   79,F
05B3:  INCF   78,F
05B4:  BTFSC  03.2
05B5:  INCF   79,F
05B6:  BCF    03.5
05B7:  RETURN
05B8:  MOVF   6C,W
05B9:  CLRF   78
05BA:  SUBWF  6B,W
05BB:  BTFSC  03.0
05BC:  GOTO   5C0
05BD:  MOVF   6B,W
05BE:  MOVWF  77
05BF:  GOTO   5CC
05C0:  CLRF   77
05C1:  MOVLW  08
05C2:  MOVWF  6D
05C3:  RLF    6B,F
05C4:  RLF    77,F
05C5:  MOVF   6C,W
05C6:  SUBWF  77,W
05C7:  BTFSC  03.0
05C8:  MOVWF  77
05C9:  RLF    78,F
05CA:  DECFSZ 6D,F
05CB:  GOTO   5C3
05CC:  RETURN
05CD:  MOVLW  20
05CE:  BTFSS  66.4
05CF:  MOVLW  30
05D0:  MOVWF  67
05D1:  MOVF   65,W
05D2:  MOVWF  77
05D3:  BTFSS  65.7
05D4:  GOTO   5DD
05D5:  COMF   77,F
05D6:  INCF   77,F
05D7:  MOVF   77,W
05D8:  MOVWF  65
05D9:  MOVLW  2D
05DA:  MOVWF  67
05DB:  BSF    66.7
05DC:  BSF    66.0
05DD:  MOVF   65,W
05DE:  MOVWF  6B
05DF:  MOVLW  64
05E0:  MOVWF  6C
05E1:  CALL   5B8
05E2:  MOVF   77,W
05E3:  MOVWF  65
05E4:  MOVLW  30
05E5:  ADDWF  78,W
05E6:  MOVWF  68
05E7:  MOVF   65,W
05E8:  MOVWF  6B
05E9:  MOVLW  0A
05EA:  MOVWF  6C
05EB:  CALL   5B8
05EC:  MOVLW  30
05ED:  ADDWF  77,W
05EE:  MOVWF  6A
05EF:  MOVLW  30
05F0:  ADDWF  78,W
05F1:  MOVWF  69
05F2:  MOVF   67,W
05F3:  MOVWF  77
05F4:  MOVLW  30
05F5:  SUBWF  68,W
05F6:  BTFSC  03.2
05F7:  GOTO   5FC
05F8:  BSF    66.1
05F9:  BTFSC  66.7
05FA:  BSF    66.2
05FB:  GOTO   610
05FC:  MOVF   67,W
05FD:  MOVWF  68
05FE:  MOVLW  20
05FF:  MOVWF  67
0600:  MOVLW  30
0601:  SUBWF  69,W
0602:  BTFSC  03.2
0603:  GOTO   608
0604:  BSF    66.0
0605:  BTFSC  66.7
0606:  BSF    66.1
0607:  GOTO   610
0608:  BTFSS  03.2
0609:  BSF    66.0
060A:  BTFSS  03.2
060B:  GOTO   610
060C:  MOVF   68,W
060D:  MOVWF  69
060E:  MOVLW  20
060F:  MOVWF  68
0610:  BTFSC  66.2
0611:  GOTO   617
0612:  BTFSC  66.1
0613:  GOTO   61B
0614:  BTFSC  66.0
0615:  GOTO   61F
0616:  GOTO   623
0617:  MOVF   67,W
0618:  BTFSS  0C.4
0619:  GOTO   618
061A:  MOVWF  19
061B:  MOVF   68,W
061C:  BTFSS  0C.4
061D:  GOTO   61C
061E:  MOVWF  19
061F:  MOVF   69,W
0620:  BTFSS  0C.4
0621:  GOTO   620
0622:  MOVWF  19
0623:  MOVF   6A,W
0624:  BTFSS  0C.4
0625:  GOTO   624
0626:  MOVWF  19
0627:  RETURN
0628:  MOVF   66,W
0629:  MOVWF  6D
062A:  MOVF   6A,W
062B:  XORWF  6D,F
062C:  BTFSS  6D.7
062D:  GOTO   633
062E:  BCF    03.2
062F:  BCF    03.0
0630:  BTFSC  66.7
0631:  BSF    03.0
0632:  GOTO   666
0633:  MOVF   66,W
0634:  MOVWF  6D
0635:  MOVF   69,W
0636:  MOVWF  6E
0637:  MOVF   65,W
0638:  SUBWF  6E,F
0639:  BTFSC  03.2
063A:  GOTO   641
063B:  BTFSS  6D.7
063C:  GOTO   666
063D:  MOVF   03,W
063E:  XORLW  01
063F:  MOVWF  03
0640:  GOTO   666
0641:  MOVF   6A,W
0642:  MOVWF  6E
0643:  MOVF   66,W
0644:  SUBWF  6E,F
0645:  BTFSC  03.2
0646:  GOTO   64D
0647:  BTFSS  6D.7
0648:  GOTO   666
0649:  MOVF   03,W
064A:  XORLW  01
064B:  MOVWF  03
064C:  GOTO   666
064D:  MOVF   6B,W
064E:  MOVWF  6E
064F:  MOVF   67,W
0650:  SUBWF  6E,F
0651:  BTFSC  03.2
0652:  GOTO   659
0653:  BTFSS  6D.7
0654:  GOTO   666
0655:  MOVF   03,W
0656:  XORLW  01
0657:  MOVWF  03
0658:  GOTO   666
0659:  MOVF   6C,W
065A:  MOVWF  6E
065B:  MOVF   68,W
065C:  SUBWF  6E,F
065D:  BTFSC  03.2
065E:  GOTO   665
065F:  BTFSS  6D.7
0660:  GOTO   666
0661:  MOVF   03,W
0662:  XORLW  01
0663:  MOVWF  03
0664:  GOTO   666
0665:  BCF    03.0
0666:  RETURN
*
07E1:  BSF    0A.0
07E2:  BSF    0A.1
07E3:  BSF    0A.2
07E4:  ADDWF  02,F
07E5:  GOTO   70C
07E6:  GOTO   706
07E7:  GOTO   708
07E8:  GOTO   70A
*
0A02:  MOVLW  8E
0A03:  MOVWF  77
0A04:  MOVF   6B,W
0A05:  MOVWF  78
0A06:  MOVF   6A,W
0A07:  MOVWF  79
0A08:  CLRF   7A
0A09:  MOVF   78,F
0A0A:  BTFSS  03.2
0A0B:  GOTO   216
0A0C:  MOVF   79,W
0A0D:  MOVWF  78
0A0E:  CLRF   79
0A0F:  MOVLW  08
0A10:  SUBWF  77,F
0A11:  MOVF   78,F
0A12:  BTFSS  03.2
0A13:  GOTO   216
0A14:  CLRF   77
0A15:  GOTO   21E
0A16:  BCF    03.0
0A17:  BTFSC  78.7
0A18:  GOTO   21D
0A19:  RLF    79,F
0A1A:  RLF    78,F
0A1B:  DECF   77,F
0A1C:  GOTO   216
0A1D:  BCF    78.7
*
0A9A:  MOVF   30,W
0A9B:  BTFSC  03.2
0A9C:  GOTO   35F
0A9D:  MOVWF  3C
0A9E:  MOVF   34,W
0A9F:  BTFSC  03.2
0AA0:  GOTO   35F
0AA1:  SUBWF  3C,F
0AA2:  BTFSS  03.0
0AA3:  GOTO   2A9
0AA4:  MOVLW  7F
0AA5:  ADDWF  3C,F
0AA6:  BTFSC  03.0
0AA7:  GOTO   35F
0AA8:  GOTO   2AF
0AA9:  MOVLW  81
0AAA:  SUBWF  3C,F
0AAB:  BTFSS  03.0
0AAC:  GOTO   35F
0AAD:  BTFSC  03.2
0AAE:  GOTO   35F
0AAF:  MOVF   3C,W
0AB0:  MOVWF  77
0AB1:  CLRF   78
0AB2:  CLRF   79
0AB3:  CLRF   7A
0AB4:  CLRF   3B
0AB5:  MOVF   31,W
0AB6:  MOVWF  3A
0AB7:  BSF    3A.7
0AB8:  MOVF   32,W
0AB9:  MOVWF  39
0ABA:  MOVF   33,W
0ABB:  MOVWF  38
0ABC:  MOVLW  19
0ABD:  MOVWF  3C
0ABE:  MOVF   37,W
0ABF:  SUBWF  38,F
0AC0:  BTFSC  03.0
0AC1:  GOTO   2D2
0AC2:  MOVLW  01
0AC3:  SUBWF  39,F
0AC4:  BTFSC  03.0
0AC5:  GOTO   2D2
0AC6:  SUBWF  3A,F
0AC7:  BTFSC  03.0
0AC8:  GOTO   2D2
0AC9:  SUBWF  3B,F
0ACA:  BTFSC  03.0
0ACB:  GOTO   2D2
0ACC:  INCF   3B,F
0ACD:  INCF   3A,F
0ACE:  INCF   39,F
0ACF:  MOVF   37,W
0AD0:  ADDWF  38,F
0AD1:  GOTO   304
0AD2:  MOVF   36,W
0AD3:  SUBWF  39,F
0AD4:  BTFSC  03.0
0AD5:  GOTO   2ED
0AD6:  MOVLW  01
0AD7:  SUBWF  3A,F
0AD8:  BTFSC  03.0
0AD9:  GOTO   2ED
0ADA:  SUBWF  3B,F
0ADB:  BTFSC  03.0
0ADC:  GOTO   2ED
0ADD:  INCF   3B,F
0ADE:  INCF   3A,F
0ADF:  MOVF   36,W
0AE0:  ADDWF  39,F
0AE1:  MOVF   37,W
0AE2:  ADDWF  38,F
0AE3:  BTFSS  03.0
0AE4:  GOTO   304
0AE5:  INCF   39,F
0AE6:  BTFSS  03.2
0AE7:  GOTO   304
0AE8:  INCF   3A,F
0AE9:  BTFSS  03.2
0AEA:  GOTO   304
0AEB:  INCF   3B,F
0AEC:  GOTO   304
0AED:  MOVF   35,W
0AEE:  IORLW  80
0AEF:  SUBWF  3A,F
0AF0:  BTFSC  03.0
0AF1:  GOTO   303
0AF2:  MOVLW  01
0AF3:  SUBWF  3B,F
0AF4:  BTFSC  03.0
0AF5:  GOTO   303
0AF6:  INCF   3B,F
0AF7:  MOVF   35,W
0AF8:  IORLW  80
0AF9:  ADDWF  3A,F
0AFA:  MOVF   36,W
0AFB:  ADDWF  39,F
0AFC:  BTFSS  03.0
0AFD:  GOTO   2E1
0AFE:  INCF   3A,F
0AFF:  BTFSS  03.2
0B00:  GOTO   2E1
0B01:  INCF   3B,F
0B02:  GOTO   2E1
0B03:  BSF    7A.0
0B04:  DECFSZ 3C,F
0B05:  GOTO   307
0B06:  GOTO   312
0B07:  BCF    03.0
0B08:  RLF    38,F
0B09:  RLF    39,F
0B0A:  RLF    3A,F
0B0B:  RLF    3B,F
0B0C:  BCF    03.0
0B0D:  RLF    7A,F
0B0E:  RLF    79,F
0B0F:  RLF    78,F
0B10:  RLF    3D,F
0B11:  GOTO   2BE
0B12:  BTFSS  3D.0
0B13:  GOTO   31A
0B14:  BCF    03.0
0B15:  RRF    78,F
0B16:  RRF    79,F
0B17:  RRF    7A,F
0B18:  RRF    3D,F
0B19:  GOTO   31D
0B1A:  DECF   77,F
0B1B:  BTFSC  03.2
0B1C:  GOTO   35F
0B1D:  BTFSC  3D.7
0B1E:  GOTO   346
0B1F:  BCF    03.0
0B20:  RLF    38,F
0B21:  RLF    39,F
0B22:  RLF    3A,F
0B23:  RLF    3B,F
0B24:  MOVF   37,W
0B25:  SUBWF  38,F
0B26:  BTFSC  03.0
0B27:  GOTO   332
0B28:  MOVLW  01
0B29:  SUBWF  39,F
0B2A:  BTFSC  03.0
0B2B:  GOTO   332
0B2C:  SUBWF  3A,F
0B2D:  BTFSC  03.0
0B2E:  GOTO   332
0B2F:  SUBWF  3B,F
0B30:  BTFSS  03.0
0B31:  GOTO   355
0B32:  MOVF   36,W
0B33:  SUBWF  39,F
0B34:  BTFSC  03.0
0B35:  GOTO   33D
0B36:  MOVLW  01
0B37:  SUBWF  3A,F
0B38:  BTFSC  03.0
0B39:  GOTO   33D
0B3A:  SUBWF  3B,F
0B3B:  BTFSS  03.0
0B3C:  GOTO   355
0B3D:  MOVF   35,W
0B3E:  IORLW  80
0B3F:  SUBWF  3A,F
0B40:  BTFSC  03.0
0B41:  GOTO   346
0B42:  MOVLW  01
0B43:  SUBWF  3B,F
0B44:  BTFSS  03.0
0B45:  GOTO   355
0B46:  INCF   7A,F
0B47:  BTFSS  03.2
0B48:  GOTO   355
0B49:  INCF   79,F
0B4A:  BTFSS  03.2
0B4B:  GOTO   355
0B4C:  INCF   78,F
0B4D:  BTFSS  03.2
0B4E:  GOTO   355
0B4F:  INCF   77,F
0B50:  BTFSC  03.2
0B51:  GOTO   35F
0B52:  RRF    78,F
0B53:  RRF    79,F
0B54:  RRF    7A,F
0B55:  MOVF   31,W
0B56:  MOVWF  3C
0B57:  MOVF   35,W
0B58:  XORWF  3C,F
0B59:  BTFSS  3C.7
0B5A:  GOTO   35D
0B5B:  BSF    78.7
0B5C:  GOTO   363
0B5D:  BCF    78.7
0B5E:  GOTO   363
0B5F:  CLRF   77
0B60:  CLRF   78
0B61:  CLRF   79
0B62:  CLRF   7A
*
0BA5:  MOVF   30,W
0BA6:  BTFSC  03.2
0BA7:  GOTO   415
0BA8:  MOVWF  38
0BA9:  MOVF   34,W
0BAA:  BTFSC  03.2
0BAB:  GOTO   415
0BAC:  ADDWF  38,F
0BAD:  BTFSC  03.0
0BAE:  GOTO   3B6
0BAF:  MOVLW  7F
0BB0:  SUBWF  38,F
0BB1:  BTFSS  03.0
0BB2:  GOTO   415
0BB3:  BTFSC  03.2
0BB4:  GOTO   415
0BB5:  GOTO   3BA
0BB6:  MOVLW  81
0BB7:  ADDWF  38,F
0BB8:  BTFSC  03.0
0BB9:  GOTO   415
0BBA:  MOVF   38,W
0BBB:  MOVWF  77
0BBC:  CLRF   78
0BBD:  CLRF   79
0BBE:  CLRF   7A
0BBF:  MOVF   31,W
0BC0:  MOVWF  3C
0BC1:  BSF    3C.7
0BC2:  MOVF   32,W
0BC3:  MOVWF  3B
0BC4:  MOVF   33,W
0BC5:  MOVWF  3A
0BC6:  MOVLW  18
0BC7:  MOVWF  38
0BC8:  CLRF   39
0BC9:  BTFSS  3A.0
0BCA:  GOTO   3E3
0BCB:  MOVF   37,W
0BCC:  ADDWF  7A,F
0BCD:  BTFSS  03.0
0BCE:  GOTO   3D5
0BCF:  INCF   79,F
0BD0:  BTFSS  03.2
0BD1:  GOTO   3D5
0BD2:  INCF   78,F
0BD3:  BTFSC  03.2
0BD4:  BSF    39.7
0BD5:  MOVF   36,W
0BD6:  ADDWF  79,F
0BD7:  BTFSS  03.0
0BD8:  GOTO   3DC
0BD9:  INCF   78,F
0BDA:  BTFSC  03.2
0BDB:  BSF    39.7
0BDC:  MOVF   35,W
0BDD:  MOVWF  32
0BDE:  BSF    32.7
0BDF:  MOVF   32,W
0BE0:  ADDWF  78,F
0BE1:  BTFSC  03.0
0BE2:  BSF    39.7
0BE3:  RLF    39,F
0BE4:  RRF    78,F
0BE5:  RRF    79,F
0BE6:  RRF    7A,F
0BE7:  RRF    3C,F
0BE8:  RRF    3B,F
0BE9:  RRF    3A,F
0BEA:  BCF    03.0
0BEB:  DECFSZ 38,F
0BEC:  GOTO   3C8
0BED:  MOVLW  01
0BEE:  ADDWF  77,F
0BEF:  BTFSC  03.0
0BF0:  GOTO   415
0BF1:  BTFSC  78.7
0BF2:  GOTO   3FA
0BF3:  RLF    3C,F
0BF4:  RLF    7A,F
0BF5:  RLF    79,F
0BF6:  RLF    78,F
0BF7:  DECF   77,F
0BF8:  BTFSC  03.2
0BF9:  GOTO   415
0BFA:  BTFSS  3C.7
0BFB:  GOTO   40B
0BFC:  INCF   7A,F
0BFD:  BTFSS  03.2
0BFE:  GOTO   40B
0BFF:  INCF   79,F
0C00:  BTFSS  03.2
0C01:  GOTO   40B
0C02:  INCF   78,F
0C03:  BTFSS  03.2
0C04:  GOTO   40B
0C05:  RRF    78,F
0C06:  RRF    79,F
0C07:  RRF    7A,F
0C08:  INCF   77,F
0C09:  BTFSC  03.2
0C0A:  GOTO   415
0C0B:  MOVF   31,W
0C0C:  MOVWF  39
0C0D:  MOVF   35,W
0C0E:  XORWF  39,F
0C0F:  BTFSS  39.7
0C10:  GOTO   413
0C11:  BSF    78.7
0C12:  GOTO   419
0C13:  BCF    78.7
0C14:  GOTO   419
0C15:  CLRF   77
0C16:  CLRF   78
0C17:  CLRF   79
0C18:  CLRF   7A
*
0C5F:  MOVF   6B,W
0C60:  XORWF  6D,W
0C61:  ANDLW  80
0C62:  MOVWF  6F
0C63:  BTFSS  6B.7
0C64:  GOTO   46A
0C65:  COMF   6A,F
0C66:  COMF   6B,F
0C67:  INCF   6A,F
0C68:  BTFSC  03.2
0C69:  INCF   6B,F
0C6A:  BTFSS  6D.7
0C6B:  GOTO   471
0C6C:  COMF   6C,F
0C6D:  COMF   6D,F
0C6E:  INCF   6C,F
0C6F:  BTFSC  03.2
0C70:  INCF   6D,F
0C71:  CLRF   78
0C72:  CLRF   79
0C73:  CLRF   77
0C74:  CLRF   7A
0C75:  MOVF   6D,W
0C76:  BTFSS  03.2
0C77:  GOTO   47B
0C78:  MOVF   6C,W
0C79:  BTFSC  03.2
0C7A:  GOTO   495
0C7B:  MOVLW  10
0C7C:  MOVWF  6E
0C7D:  BCF    03.0
0C7E:  RLF    6A,F
0C7F:  RLF    6B,F
0C80:  RLF    77,F
0C81:  RLF    7A,F
0C82:  MOVF   6D,W
0C83:  SUBWF  7A,W
0C84:  BTFSS  03.2
0C85:  GOTO   488
0C86:  MOVF   6C,W
0C87:  SUBWF  77,W
0C88:  BTFSS  03.0
0C89:  GOTO   491
0C8A:  MOVF   6C,W
0C8B:  SUBWF  77,F
0C8C:  BTFSS  03.0
0C8D:  DECF   7A,F
0C8E:  MOVF   6D,W
0C8F:  SUBWF  7A,F
0C90:  BSF    03.0
0C91:  RLF    78,F
0C92:  RLF    79,F
0C93:  DECFSZ 6E,F
0C94:  GOTO   47D
0C95:  BTFSS  6F.7
0C96:  GOTO   49C
0C97:  COMF   78,F
0C98:  COMF   79,F
0C99:  INCF   78,F
0C9A:  BTFSC  03.2
0C9B:  INCF   79,F
....................  
.................... #list 
....................  
.................... #device ADC=16 
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
06A4:  BCF    03.5
06A5:  CLRF   2C
06A6:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0251:  BSF    03.5
0252:  CLRF   45
....................    sign = 0; 
0253:  CLRF   43
....................    base = 10; 
0254:  MOVLW  0A
0255:  MOVWF  44
....................    result = 0; 
0256:  CLRF   42
....................  
....................    if (!s) 
0257:  MOVF   40,W
0258:  IORWF  41,W
0259:  BTFSS  03.2
025A:  GOTO   25E
....................       return 0; 
025B:  MOVLW  00
025C:  MOVWF  78
025D:  GOTO   351
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
025E:  MOVF   45,W
025F:  INCF   45,F
0260:  ADDWF  40,W
0261:  MOVWF  04
0262:  BCF    03.7
0263:  BTFSC  41.0
0264:  BSF    03.7
0265:  MOVF   00,W
0266:  MOVWF  46
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0267:  MOVF   46,W
0268:  SUBLW  2D
0269:  BTFSS  03.2
026A:  GOTO   277
....................    { 
....................       sign = 1;         // Set the sign to negative 
026B:  MOVLW  01
026C:  MOVWF  43
....................       c = s[index++]; 
026D:  MOVF   45,W
026E:  INCF   45,F
026F:  ADDWF  40,W
0270:  MOVWF  04
0271:  BCF    03.7
0272:  BTFSC  41.0
0273:  BSF    03.7
0274:  MOVF   00,W
0275:  MOVWF  46
....................    } 
0276:  GOTO   284
....................    else if (c == '+') 
0277:  MOVF   46,W
0278:  SUBLW  2B
0279:  BTFSS  03.2
027A:  GOTO   284
....................    { 
....................       c = s[index++]; 
027B:  MOVF   45,W
027C:  INCF   45,F
027D:  ADDWF  40,W
027E:  MOVWF  04
027F:  BCF    03.7
0280:  BTFSC  41.0
0281:  BSF    03.7
0282:  MOVF   00,W
0283:  MOVWF  46
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0284:  MOVF   46,W
0285:  SUBLW  2F
0286:  BTFSC  03.0
0287:  GOTO   347
0288:  MOVF   46,W
0289:  SUBLW  39
028A:  BTFSS  03.0
028B:  GOTO   347
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
028C:  MOVF   46,W
028D:  SUBLW  30
028E:  BTFSS  03.2
028F:  GOTO   2B0
0290:  MOVF   45,W
0291:  ADDWF  40,W
0292:  MOVWF  04
0293:  BCF    03.7
0294:  BTFSC  41.0
0295:  BSF    03.7
0296:  MOVF   00,W
0297:  SUBLW  78
0298:  BTFSC  03.2
0299:  GOTO   2A4
029A:  MOVF   45,W
029B:  ADDWF  40,W
029C:  MOVWF  04
029D:  BCF    03.7
029E:  BTFSC  41.0
029F:  BSF    03.7
02A0:  MOVF   00,W
02A1:  SUBLW  58
02A2:  BTFSS  03.2
02A3:  GOTO   2B0
....................       { 
....................          base = 16; 
02A4:  MOVLW  10
02A5:  MOVWF  44
....................          index++; 
02A6:  INCF   45,F
....................          c = s[index++]; 
02A7:  MOVF   45,W
02A8:  INCF   45,F
02A9:  ADDWF  40,W
02AA:  MOVWF  04
02AB:  BCF    03.7
02AC:  BTFSC  41.0
02AD:  BSF    03.7
02AE:  MOVF   00,W
02AF:  MOVWF  46
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02B0:  MOVF   44,W
02B1:  SUBLW  0A
02B2:  BTFSS  03.2
02B3:  GOTO   2F5
....................       { 
....................          while (c >= '0' && c <= '9') 
02B4:  MOVF   46,W
02B5:  SUBLW  2F
02B6:  BTFSC  03.0
02B7:  GOTO   2F4
02B8:  MOVF   46,W
02B9:  SUBLW  39
02BA:  BTFSS  03.0
02BB:  GOTO   2F4
....................          { 
....................             result = 10*result + (c - '0'); 
02BC:  MOVLW  0A
02BD:  MOVWF  47
02BE:  MOVF   42,W
02BF:  MOVWF  48
*
02E4:  MOVF   78,W
02E5:  MOVWF  47
02E6:  MOVLW  30
02E7:  SUBWF  46,W
02E8:  ADDWF  47,W
02E9:  MOVWF  42
....................             c = s[index++]; 
02EA:  MOVF   45,W
02EB:  INCF   45,F
02EC:  ADDWF  40,W
02ED:  MOVWF  04
02EE:  BCF    03.7
02EF:  BTFSC  41.0
02F0:  BSF    03.7
02F1:  MOVF   00,W
02F2:  MOVWF  46
02F3:  GOTO   2B4
....................          } 
....................       } 
02F4:  GOTO   347
....................       else if (base == 16)    // The number is a hexa number 
02F5:  MOVF   44,W
02F6:  SUBLW  10
02F7:  BTFSS  03.2
02F8:  GOTO   347
....................       { 
....................          c = toupper(c); 
02F9:  MOVF   46,W
02FA:  SUBLW  60
02FB:  BTFSC  03.0
02FC:  GOTO   304
02FD:  MOVF   46,W
02FE:  SUBLW  7A
02FF:  BTFSS  03.0
0300:  GOTO   304
0301:  MOVF   46,W
0302:  ANDLW  DF
0303:  GOTO   305
0304:  MOVF   46,W
0305:  MOVWF  46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0306:  MOVF   46,W
0307:  SUBLW  2F
0308:  BTFSC  03.0
0309:  GOTO   30E
030A:  MOVF   46,W
030B:  SUBLW  39
030C:  BTFSC  03.0
030D:  GOTO   316
030E:  MOVF   46,W
030F:  SUBLW  40
0310:  BTFSC  03.0
0311:  GOTO   347
0312:  MOVF   46,W
0313:  SUBLW  46
0314:  BTFSS  03.0
0315:  GOTO   347
....................          { 
....................             if (c >= '0' && c <= '9') 
0316:  MOVF   46,W
0317:  SUBLW  2F
0318:  BTFSC  03.0
0319:  GOTO   327
031A:  MOVF   46,W
031B:  SUBLW  39
031C:  BTFSS  03.0
031D:  GOTO   327
....................                result = (result << 4) + (c - '0'); 
031E:  SWAPF  42,W
031F:  MOVWF  47
0320:  MOVLW  F0
0321:  ANDWF  47,F
0322:  MOVLW  30
0323:  SUBWF  46,W
0324:  ADDWF  47,W
0325:  MOVWF  42
0326:  GOTO   330
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0327:  SWAPF  42,W
0328:  MOVWF  47
0329:  MOVLW  F0
032A:  ANDWF  47,F
032B:  MOVLW  41
032C:  SUBWF  46,W
032D:  ADDLW  0A
032E:  ADDWF  47,W
032F:  MOVWF  42
....................  
....................             c = s[index++]; 
0330:  MOVF   45,W
0331:  INCF   45,F
0332:  ADDWF  40,W
0333:  MOVWF  04
0334:  BCF    03.7
0335:  BTFSC  41.0
0336:  BSF    03.7
0337:  MOVF   00,W
0338:  MOVWF  46
....................             c = toupper(c); 
0339:  MOVF   46,W
033A:  SUBLW  60
033B:  BTFSC  03.0
033C:  GOTO   344
033D:  MOVF   46,W
033E:  SUBLW  7A
033F:  BTFSS  03.0
0340:  GOTO   344
0341:  MOVF   46,W
0342:  ANDLW  DF
0343:  GOTO   345
0344:  MOVF   46,W
0345:  MOVWF  46
0346:  GOTO   306
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0347:  DECFSZ 43,W
0348:  GOTO   34F
0349:  MOVF   44,W
034A:  SUBLW  0A
034B:  BTFSS  03.2
034C:  GOTO   34F
....................        result = -result; 
034D:  COMF   42,F
034E:  INCF   42,F
....................  
....................    return(result); 
034F:  MOVF   42,W
0350:  MOVWF  78
0351:  BCF    03.5
0352:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE<string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS 
....................  
.................... #use delay(crystal=20000000) 
*
03D6:  MOVLW  6A
03D7:  MOVWF  04
03D8:  BCF    03.7
03D9:  MOVF   00,W
03DA:  BTFSC  03.2
03DB:  GOTO   3E9
03DC:  MOVLW  06
03DD:  MOVWF  78
03DE:  CLRF   77
03DF:  DECFSZ 77,F
03E0:  GOTO   3DF
03E1:  DECFSZ 78,F
03E2:  GOTO   3DE
03E3:  MOVLW  7B
03E4:  MOVWF  77
03E5:  DECFSZ 77,F
03E6:  GOTO   3E5
03E7:  DECFSZ 00,F
03E8:  GOTO   3DC
03E9:  RETURN
.................... #use FIXED_IO( A_outputs=PIN_A3,PIN_A2,PIN_A1,PIN_A0,PIN_A4 ) 
.................... #use rs232(stream=com1,baud=9600,xmit=PIN_C6,rcv=PIN_c7)) 
....................  
.................... #define S_0   PIN_A0 
.................... #define S_1   PIN_A1 
.................... #define S_2   PIN_A2 
.................... #define S_3   PIN_A3 
.................... #define READ   PIN_B0 
....................  
....................  
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_D6 
.................... #define LCD_RS_PIN PIN_D7 
.................... #define LCD_RW_PIN PIN_C4 
.................... #define LCD_DATA4 PIN_D5 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D3 
.................... #define LCD_DATA7 PIN_D2 
....................  
.................... #define UNIDENTIFIED    0 
.................... #define COLOR_RED       1 
.................... #define COLOR_BLUE      2 
.................... #define COLOR_GREEN     3 
.................... #define COLOR_COUNT_MAX     4 
.................... #define LOW_   1 
.................... #define MEDIUM    2 
.................... #define HIGH_   3 
.................... #define ON_    1 
.................... #define OFF_   0 
.................... #include<lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
045D:  BSF    08.5
....................    output_float(LCD_DATA5); 
045E:  BSF    08.4
....................    output_float(LCD_DATA6); 
045F:  BSF    08.3
....................    output_float(LCD_DATA7); 
0460:  BSF    08.2
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0461:  BCF    03.5
0462:  BSF    07.4
0463:  BCF    32.4
0464:  MOVF   32,W
0465:  BSF    03.5
0466:  MOVWF  07
....................    delay_cycles(1); 
0467:  NOP
....................    lcd_output_enable(1); 
0468:  BCF    03.5
0469:  BSF    08.6
046A:  BSF    03.5
046B:  BCF    08.6
....................    delay_cycles(1); 
046C:  NOP
....................    high = lcd_read_nibble(); 
046D:  BCF    03.5
046E:  CALL   420
046F:  MOVF   78,W
0470:  MOVWF  70
....................        
....................    lcd_output_enable(0); 
0471:  BCF    08.6
0472:  BSF    03.5
0473:  BCF    08.6
....................    delay_cycles(1); 
0474:  NOP
....................    lcd_output_enable(1); 
0475:  BCF    03.5
0476:  BSF    08.6
0477:  BSF    03.5
0478:  BCF    08.6
....................    delay_us(1); 
0479:  GOTO   47A
047A:  GOTO   47B
047B:  NOP
....................    low = lcd_read_nibble(); 
047C:  BCF    03.5
047D:  CALL   420
047E:  MOVF   78,W
047F:  MOVWF  6F
....................        
....................    lcd_output_enable(0); 
0480:  BCF    08.6
0481:  BSF    03.5
0482:  BCF    08.6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0483:  BCF    08.5
....................    output_drive(LCD_DATA5); 
0484:  BCF    08.4
....................    output_drive(LCD_DATA6); 
0485:  BCF    08.3
....................    output_drive(LCD_DATA7); 
0486:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0487:  SWAPF  70,W
0488:  MOVWF  77
0489:  MOVLW  F0
048A:  ANDWF  77,F
048B:  MOVF   77,W
048C:  BCF    03.5
048D:  IORWF  6F,W
048E:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0420:  CLRF   71
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0421:  BSF    03.5
0422:  BSF    08.5
0423:  MOVLW  00
0424:  BCF    03.5
0425:  BTFSC  08.5
0426:  MOVLW  01
0427:  IORWF  71,F
....................    n |= input(LCD_DATA5) << 1; 
0428:  BSF    03.5
0429:  BSF    08.4
042A:  MOVLW  00
042B:  BCF    03.5
042C:  BTFSC  08.4
042D:  MOVLW  01
042E:  MOVWF  77
042F:  BCF    03.0
0430:  RLF    77,F
0431:  MOVF   77,W
0432:  IORWF  71,F
....................    n |= input(LCD_DATA6) << 2; 
0433:  BSF    03.5
0434:  BSF    08.3
0435:  MOVLW  00
0436:  BCF    03.5
0437:  BTFSC  08.3
0438:  MOVLW  01
0439:  MOVWF  77
043A:  RLF    77,F
043B:  RLF    77,F
043C:  MOVLW  FC
043D:  ANDWF  77,F
043E:  MOVF   77,W
043F:  IORWF  71,F
....................    n |= input(LCD_DATA7) << 3; 
0440:  BSF    03.5
0441:  BSF    08.2
0442:  MOVLW  00
0443:  BCF    03.5
0444:  BTFSC  08.2
0445:  MOVLW  01
0446:  MOVWF  77
0447:  RLF    77,F
0448:  RLF    77,F
0449:  RLF    77,F
044A:  MOVLW  F8
044B:  ANDWF  77,F
044C:  MOVF   77,W
044D:  IORWF  71,F
....................     
....................    return(n); 
044E:  MOVF   71,W
044F:  MOVWF  78
....................   #else 
0450:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
03EA:  BTFSC  70.0
03EB:  GOTO   3EE
03EC:  BCF    08.5
03ED:  GOTO   3EF
03EE:  BSF    08.5
03EF:  BSF    03.5
03F0:  BCF    08.5
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
03F1:  BTFSC  70.1
03F2:  GOTO   3F7
03F3:  BCF    03.5
03F4:  BCF    08.4
03F5:  GOTO   3F9
03F6:  BSF    03.5
03F7:  BCF    03.5
03F8:  BSF    08.4
03F9:  BSF    03.5
03FA:  BCF    08.4
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
03FB:  BTFSC  70.2
03FC:  GOTO   401
03FD:  BCF    03.5
03FE:  BCF    08.3
03FF:  GOTO   403
0400:  BSF    03.5
0401:  BCF    03.5
0402:  BSF    08.3
0403:  BSF    03.5
0404:  BCF    08.3
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0405:  BTFSC  70.3
0406:  GOTO   40B
0407:  BCF    03.5
0408:  BCF    08.2
0409:  GOTO   40D
040A:  BSF    03.5
040B:  BCF    03.5
040C:  BSF    08.2
040D:  BSF    03.5
040E:  BCF    08.2
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
040F:  NOP
....................    lcd_output_enable(1); 
0410:  BCF    03.5
0411:  BSF    08.6
0412:  BSF    03.5
0413:  BCF    08.6
....................    delay_us(2); 
0414:  MOVLW  02
0415:  MOVWF  77
0416:  DECFSZ 77,F
0417:  GOTO   416
0418:  GOTO   419
0419:  NOP
....................    lcd_output_enable(0); 
041A:  BCF    03.5
041B:  BCF    08.6
041C:  BSF    03.5
041D:  BCF    08.6
041E:  BCF    03.5
041F:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0451:  BSF    03.5
0452:  BCF    08.6
....................    lcd_rs_tris(); 
0453:  BCF    08.7
....................    lcd_rw_tris(); 
0454:  BCF    03.5
0455:  BCF    32.4
0456:  MOVF   32,W
0457:  BSF    03.5
0458:  MOVWF  07
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0459:  BCF    03.5
045A:  BCF    08.7
045B:  BSF    03.5
045C:  BCF    08.7
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
048F:  MOVF   78,W
0490:  MOVWF  6F
0491:  BTFSS  6F.7
0492:  GOTO   495
0493:  BSF    03.5
0494:  GOTO   45D
....................    lcd_output_rs(address); 
0495:  MOVF   6D,F
0496:  BTFSS  03.2
0497:  GOTO   49A
0498:  BCF    08.7
0499:  GOTO   49B
049A:  BSF    08.7
049B:  BSF    03.5
049C:  BCF    08.7
....................    delay_cycles(1); 
049D:  NOP
....................    lcd_output_rw(0); 
049E:  BCF    03.5
049F:  BCF    07.4
04A0:  BCF    32.4
04A1:  MOVF   32,W
04A2:  BSF    03.5
04A3:  MOVWF  07
....................    delay_cycles(1); 
04A4:  NOP
....................    lcd_output_enable(0); 
04A5:  BCF    03.5
04A6:  BCF    08.6
04A7:  BSF    03.5
04A8:  BCF    08.6
....................    lcd_send_nibble(n >> 4); 
04A9:  BCF    03.5
04AA:  SWAPF  6E,W
04AB:  MOVWF  6F
04AC:  MOVLW  0F
04AD:  ANDWF  6F,F
04AE:  MOVF   6F,W
04AF:  MOVWF  70
04B0:  CALL   3EA
....................    lcd_send_nibble(n & 0xf); 
04B1:  MOVF   6E,W
04B2:  ANDLW  0F
04B3:  MOVWF  6F
04B4:  MOVWF  70
04B5:  CALL   3EA
04B6:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
04B7:  MOVLW  28
04B8:  MOVWF  66
04B9:  MOVLW  0C
04BA:  MOVWF  67
04BB:  MOVLW  01
04BC:  MOVWF  68
04BD:  MOVLW  06
04BE:  MOVWF  69
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
04BF:  BCF    08.6
04C0:  BSF    03.5
04C1:  BCF    08.6
....................    lcd_output_rs(0); 
04C2:  BCF    03.5
04C3:  BCF    08.7
04C4:  BSF    03.5
04C5:  BCF    08.7
....................    lcd_output_rw(0); 
04C6:  BCF    03.5
04C7:  BCF    07.4
04C8:  BCF    32.4
04C9:  MOVF   32,W
04CA:  BSF    03.5
04CB:  MOVWF  07
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
04CC:  BCF    08.5
....................    output_drive(LCD_DATA5); 
04CD:  BCF    08.4
....................    output_drive(LCD_DATA6); 
04CE:  BCF    08.3
....................    output_drive(LCD_DATA7); 
04CF:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
04D0:  BCF    08.6
....................    lcd_rs_tris(); 
04D1:  BCF    08.7
....................    lcd_rw_tris(); 
04D2:  BCF    03.5
04D3:  BCF    32.4
04D4:  MOVF   32,W
04D5:  BSF    03.5
04D6:  MOVWF  07
....................  #endif 
....................      
....................    delay_ms(15); 
04D7:  MOVLW  0F
04D8:  BCF    03.5
04D9:  MOVWF  6A
04DA:  CALL   3D6
....................    for(i=1;i<=3;++i) 
04DB:  MOVLW  01
04DC:  MOVWF  65
04DD:  MOVF   65,W
04DE:  SUBLW  03
04DF:  BTFSS  03.0
04E0:  GOTO   4E9
....................    { 
....................        lcd_send_nibble(3); 
04E1:  MOVLW  03
04E2:  MOVWF  70
04E3:  CALL   3EA
....................        delay_ms(5); 
04E4:  MOVLW  05
04E5:  MOVWF  6A
04E6:  CALL   3D6
04E7:  INCF   65,F
04E8:  GOTO   4DD
....................    } 
....................     
....................    lcd_send_nibble(2); 
04E9:  MOVLW  02
04EA:  MOVWF  70
04EB:  CALL   3EA
....................    delay_ms(5); 
04EC:  MOVLW  05
04ED:  MOVWF  6A
04EE:  CALL   3D6
....................    for(i=0;i<=3;++i) 
04EF:  CLRF   65
04F0:  MOVF   65,W
04F1:  SUBLW  03
04F2:  BTFSS  03.0
04F3:  GOTO   500
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
04F4:  MOVLW  66
04F5:  ADDWF  65,W
04F6:  MOVWF  04
04F7:  BCF    03.7
04F8:  MOVF   00,W
04F9:  MOVWF  6A
04FA:  CLRF   6D
04FB:  MOVF   6A,W
04FC:  MOVWF  6E
04FD:  CALL   451
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
04FE:  INCF   65,F
04FF:  GOTO   4F0
0500:  BCF    0A.3
0501:  BCF    0A.4
0502:  GOTO   6BB (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0503:  DECFSZ 6A,W
0504:  GOTO   506
0505:  GOTO   509
....................       address=LCD_LINE_TWO; 
0506:  MOVLW  40
0507:  MOVWF  6B
0508:  GOTO   50A
....................    else 
....................       address=0; 
0509:  CLRF   6B
....................       
....................    address+=x-1; 
050A:  MOVLW  01
050B:  SUBWF  69,W
050C:  ADDWF  6B,F
....................    lcd_send_byte(0,0x80|address); 
050D:  MOVF   6B,W
050E:  IORLW  80
050F:  MOVWF  6C
0510:  CLRF   6D
0511:  MOVF   6C,W
0512:  MOVWF  6E
0513:  CALL   451
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0514:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0515:  MOVF   68,W
0516:  XORLW  07
0517:  BTFSC  03.2
0518:  GOTO   523
0519:  XORLW  0B
051A:  BTFSC  03.2
051B:  GOTO   528
051C:  XORLW  06
051D:  BTFSC  03.2
051E:  GOTO   530
051F:  XORLW  02
0520:  BTFSC  03.2
0521:  GOTO   536
0522:  GOTO   53B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0523:  MOVLW  01
0524:  MOVWF  69
0525:  MOVWF  6A
0526:  CALL   503
0527:  GOTO   540
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0528:  CLRF   6D
0529:  MOVLW  01
052A:  MOVWF  6E
052B:  CALL   451
....................                      delay_ms(2); 
052C:  MOVLW  02
052D:  MOVWF  6A
052E:  CALL   3D6
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
052F:  GOTO   540
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0530:  MOVLW  01
0531:  MOVWF  69
0532:  MOVLW  02
0533:  MOVWF  6A
0534:  CALL   503
0535:  GOTO   540
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0536:  CLRF   6D
0537:  MOVLW  10
0538:  MOVWF  6E
0539:  CALL   451
053A:  GOTO   540
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
053B:  MOVLW  01
053C:  MOVWF  6D
053D:  MOVF   68,W
053E:  MOVWF  6E
053F:  CALL   451
....................      #endif 
....................    } 
0540:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... unsigned char has_product = 0, count_enable = 0, isFromButtonPressed = 0,done=0,cycle,data_received[5],c,has_red,has_blue,has_green; 
.................... int color_count = 0, red_count = 0, blue_count = 0, green_count = 0, blind_count = 0; 
.................... unsigned int red_product = 0, blue_product = 0, green_product = 0,sum;  
.................... int color_flag=0,on_off=0,speed_mode,freq_mode,sp_stop,time_stop,is_running=0; 
.................... static  float  count, red_freq, blue_freq, green_freq; 
*
06A7:  CLRF   51
06A8:  CLRF   52
06A9:  CLRF   53
06AA:  CLRF   54
06AB:  CLRF   55
06AC:  CLRF   56
06AD:  CLRF   57
06AE:  CLRF   58
06AF:  CLRF   59
06B0:  CLRF   5A
06B1:  CLRF   5B
06B2:  CLRF   5C
06B3:  CLRF   5D
06B4:  CLRF   5E
06B5:  CLRF   5F
06B6:  CLRF   60
.................... int16 Ton, ChuKy=10000; 
.................... float Map(float x, float in_min, float in_max, float out_min, float out_max) 
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
....................    tam =  tam + out_min; 
....................    return tam; 
.................... } 
....................  
.................... void Hien_thi(int16 value) 
.................... { 
....................    lcd_putc(value/10000 + 0x30) ; // chuc nghin 
....................    lcd_putc(value%10000/1000 + 0x30) ;  // nghin 
....................    lcd_putc(value%10000%1000/100 + 0x30) ; // tram 
....................    lcd_putc(value%10000%1000%100/10 + 0x30) ; // chuc 
....................    lcd_putc(value%10 + 0x30) ; // don vi 
....................     
.................... } 
.................... void TCS_mode(int8 s2, int8 s3) 
.................... { 
....................    count=0; 
*
01DA:  CLRF   54
01DB:  CLRF   53
01DC:  CLRF   52
01DD:  CLRF   51
....................    color_flag++; 
01DE:  INCF   4A,F
....................    OUTPUT_BIT(S_2,s2); 
01DF:  BSF    03.5
01E0:  MOVF   40,F
01E1:  BTFSS  03.2
01E2:  GOTO   1E7
01E3:  BCF    03.5
01E4:  BCF    05.2
01E5:  GOTO   1E9
01E6:  BSF    03.5
01E7:  BCF    03.5
01E8:  BSF    05.2
01E9:  MOVLW  E0
01EA:  BSF    03.5
01EB:  MOVWF  05
....................    OUTPUT_BIT(S_3,s3); 
01EC:  MOVF   41,F
01ED:  BTFSS  03.2
01EE:  GOTO   1F3
01EF:  BCF    03.5
01F0:  BCF    05.3
01F1:  GOTO   1F5
01F2:  BSF    03.5
01F3:  BCF    03.5
01F4:  BSF    05.3
01F5:  MOVLW  E0
01F6:  BSF    03.5
01F7:  MOVWF  05
....................    set_timer1(3036); 
01F8:  BCF    03.5
01F9:  CLRF   0E
01FA:  MOVLW  0B
01FB:  MOVWF  0F
01FC:  MOVLW  DC
01FD:  MOVWF  0E
....................     
....................    if(color_flag==4) 
01FE:  MOVF   4A,W
01FF:  SUBLW  04
0200:  BTFSS  03.2
0201:  GOTO   206
....................       { 
....................         
....................        color_flag=0; 
0202:  CLRF   4A
....................        setup_timer_1(T1_DISABLED); 
0203:  CLRF   10
....................        done=1; 
0204:  MOVLW  01
0205:  MOVWF  36
....................         
....................       } 
0206:  RETURN
.................... } 
.................... void get_data() 
*
0361:  BSF    03.5
0362:  CLRF   40
.................... { 
.................... int i=0; 
.................... c=fgetc(com1); 
0363:  BCF    03.5
0364:  BTFSS  0C.5
0365:  GOTO   364
0366:  MOVF   1A,W
0367:  MOVWF  3D
.................... if(c=='<') 
0368:  MOVF   3D,W
0369:  SUBLW  3C
036A:  BTFSS  03.2
036B:  GOTO   385
....................    { do{ c=fgetc(com1); 
036C:  BTFSS  0C.5
036D:  GOTO   36C
036E:  MOVF   1A,W
036F:  MOVWF  3D
....................          if(c!='-'&& c!='>') data_received[i++]=c; 
0370:  MOVF   3D,W
0371:  SUBLW  2D
0372:  BTFSC  03.2
0373:  GOTO   381
0374:  MOVF   3D,W
0375:  SUBLW  3E
0376:  BTFSC  03.2
0377:  GOTO   381
0378:  BSF    03.5
0379:  MOVF   40,W
037A:  INCF   40,F
037B:  ADDLW  38
037C:  MOVWF  04
037D:  BCF    03.7
037E:  BCF    03.5
037F:  MOVF   3D,W
0380:  MOVWF  00
....................        } 
....................        while(c!='>'); 
0381:  MOVF   3D,W
0382:  SUBLW  3E
0383:  BTFSS  03.2
0384:  GOTO   36C
....................    } 
....................     
.................... } 
....................  
.................... void Delay4us(int16 t) 
.................... { 
....................    while(t>0) t--; 
*
0667:  MOVF   6C,F
0668:  BTFSS  03.2
0669:  GOTO   66D
066A:  MOVF   6D,F
066B:  BTFSC  03.2
066C:  GOTO   672
066D:  MOVF   6C,W
066E:  BTFSC  03.2
066F:  DECF   6D,F
0670:  DECF   6C,F
0671:  GOTO   667
0672:  RETURN
.................... } 
....................  
.................... long Convert(float x, float in_min, float in_max, float out_min, float out_max) 
*
0A46:  BSF    03.1
0A47:  BCF    03.5
0A48:  CLRF   2B
0A49:  BTFSC  0B.7
0A4A:  BSF    2B.7
0A4B:  BCF    0B.7
0A4C:  BSF    03.5
0A4D:  MOVF   27,W
0A4E:  MOVWF  43
0A4F:  MOVF   26,W
0A50:  MOVWF  42
0A51:  MOVF   25,W
0A52:  MOVWF  41
0A53:  MOVF   24,W
0A54:  MOVWF  40
0A55:  MOVF   23,W
0A56:  MOVWF  47
0A57:  MOVF   22,W
0A58:  MOVWF  46
0A59:  MOVF   21,W
0A5A:  MOVWF  45
0A5B:  MOVF   20,W
0A5C:  MOVWF  44
0A5D:  BCF    0A.3
0A5E:  BCF    03.5
0A5F:  CALL   068
0A60:  BSF    0A.3
0A61:  BTFSC  2B.7
0A62:  BSF    0B.7
0A63:  MOVF   7A,W
0A64:  BSF    03.5
0A65:  MOVWF  2F
0A66:  MOVF   79,W
0A67:  MOVWF  2E
0A68:  MOVF   78,W
0A69:  MOVWF  2D
0A6A:  MOVF   77,W
0A6B:  MOVWF  2C
0A6C:  BSF    03.1
0A6D:  BCF    03.5
0A6E:  CLRF   2B
0A6F:  BTFSC  0B.7
0A70:  BSF    2B.7
0A71:  BCF    0B.7
0A72:  MOVF   7E,W
0A73:  BSF    03.5
0A74:  MOVWF  43
0A75:  MOVF   7D,W
0A76:  MOVWF  42
0A77:  MOVF   7C,W
0A78:  MOVWF  41
0A79:  MOVF   7B,W
0A7A:  MOVWF  40
0A7B:  MOVF   75,W
0A7C:  MOVWF  47
0A7D:  MOVF   74,W
0A7E:  MOVWF  46
0A7F:  MOVF   73,W
0A80:  MOVWF  45
0A81:  MOVF   72,W
0A82:  MOVWF  44
0A83:  BCF    0A.3
0A84:  BCF    03.5
0A85:  CALL   068
0A86:  BSF    0A.3
0A87:  BTFSC  2B.7
0A88:  BSF    0B.7
0A89:  BSF    03.5
0A8A:  MOVF   2F,W
0A8B:  MOVWF  33
0A8C:  MOVF   2E,W
0A8D:  MOVWF  32
0A8E:  MOVF   2D,W
0A8F:  MOVWF  31
0A90:  MOVF   2C,W
0A91:  MOVWF  30
0A92:  MOVF   7A,W
0A93:  MOVWF  37
0A94:  MOVF   79,W
0A95:  MOVWF  36
0A96:  MOVF   78,W
0A97:  MOVWF  35
0A98:  MOVF   77,W
0A99:  MOVWF  34
*
0B63:  MOVF   7A,W
0B64:  MOVWF  2B
0B65:  MOVF   79,W
0B66:  MOVWF  2A
0B67:  MOVF   78,W
0B68:  MOVWF  29
0B69:  MOVF   77,W
0B6A:  MOVWF  28
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
0B6B:  BSF    03.1
0B6C:  BCF    03.5
0B6D:  CLRF   2B
0B6E:  BTFSC  0B.7
0B6F:  BSF    2B.7
0B70:  BCF    0B.7
0B71:  MOVF   71,W
0B72:  BSF    03.5
0B73:  MOVWF  43
0B74:  MOVF   70,W
0B75:  MOVWF  42
0B76:  BCF    03.5
0B77:  MOVF   6F,W
0B78:  BSF    03.5
0B79:  MOVWF  41
0B7A:  BCF    03.5
0B7B:  MOVF   6E,W
0B7C:  BSF    03.5
0B7D:  MOVWF  40
0B7E:  MOVF   75,W
0B7F:  MOVWF  47
0B80:  MOVF   74,W
0B81:  MOVWF  46
0B82:  MOVF   73,W
0B83:  MOVWF  45
0B84:  MOVF   72,W
0B85:  MOVWF  44
0B86:  BCF    0A.3
0B87:  BCF    03.5
0B88:  CALL   068
0B89:  BSF    0A.3
0B8A:  BTFSC  2B.7
0B8B:  BSF    0B.7
0B8C:  MOVF   7A,W
0B8D:  BSF    03.5
0B8E:  MOVWF  2F
0B8F:  MOVF   79,W
0B90:  MOVWF  2E
0B91:  MOVF   78,W
0B92:  MOVWF  2D
0B93:  MOVF   77,W
0B94:  MOVWF  2C
0B95:  MOVF   2F,W
0B96:  MOVWF  33
0B97:  MOVF   2E,W
0B98:  MOVWF  32
0B99:  MOVF   2D,W
0B9A:  MOVWF  31
0B9B:  MOVF   2C,W
0B9C:  MOVWF  30
0B9D:  MOVF   2B,W
0B9E:  MOVWF  37
0B9F:  MOVF   2A,W
0BA0:  MOVWF  36
0BA1:  MOVF   29,W
0BA2:  MOVWF  35
0BA3:  MOVF   28,W
0BA4:  MOVWF  34
*
0C19:  MOVF   7A,W
0C1A:  MOVWF  2B
0C1B:  MOVF   79,W
0C1C:  MOVWF  2A
0C1D:  MOVF   78,W
0C1E:  MOVWF  29
0C1F:  MOVF   77,W
0C20:  MOVWF  28
....................    tam = tam + out_min; 
0C21:  BCF    03.1
0C22:  BCF    03.5
0C23:  CLRF   2B
0C24:  BTFSC  0B.7
0C25:  BSF    2B.7
0C26:  BCF    0B.7
0C27:  BSF    03.5
0C28:  MOVF   2B,W
0C29:  MOVWF  43
0C2A:  MOVF   2A,W
0C2B:  MOVWF  42
0C2C:  MOVF   29,W
0C2D:  MOVWF  41
0C2E:  MOVF   28,W
0C2F:  MOVWF  40
0C30:  MOVF   23,W
0C31:  MOVWF  47
0C32:  MOVF   22,W
0C33:  MOVWF  46
0C34:  MOVF   21,W
0C35:  MOVWF  45
0C36:  MOVF   20,W
0C37:  MOVWF  44
0C38:  BCF    0A.3
0C39:  BCF    03.5
0C3A:  CALL   068
0C3B:  BSF    0A.3
0C3C:  BTFSC  2B.7
0C3D:  BSF    0B.7
0C3E:  MOVF   7A,W
0C3F:  BSF    03.5
0C40:  MOVWF  2B
0C41:  MOVF   79,W
0C42:  MOVWF  2A
0C43:  MOVF   78,W
0C44:  MOVWF  29
0C45:  MOVF   77,W
0C46:  MOVWF  28
....................    return tam; 
0C47:  MOVF   2B,W
0C48:  MOVWF  2F
0C49:  MOVF   2A,W
0C4A:  MOVWF  2E
0C4B:  MOVF   29,W
0C4C:  MOVWF  2D
0C4D:  MOVF   28,W
0C4E:  MOVWF  2C
0C4F:  BCF    0A.3
0C50:  BCF    03.5
0C51:  CALL   597
0C52:  BSF    0A.3
0C53:  MOVF   79,W
.................... } 
....................  
.................... void Write(long Goc, signed long t,int servo) 
.................... { 
....................    Ton = Convert(Goc,0,180, 247,1250); 
*
09FE:  MOVF   66,W
09FF:  MOVWF  6B
0A00:  MOVF   65,W
0A01:  MOVWF  6A
*
0A1E:  MOVF   7A,W
0A1F:  MOVWF  6D
0A20:  MOVF   79,W
0A21:  MOVWF  6C
0A22:  MOVF   78,W
0A23:  MOVWF  6B
0A24:  MOVF   77,W
0A25:  MOVWF  6A
0A26:  MOVF   6D,W
0A27:  MOVWF  71
0A28:  MOVF   6C,W
0A29:  MOVWF  70
0A2A:  MOVF   6B,W
0A2B:  MOVWF  6F
0A2C:  MOVF   6A,W
0A2D:  MOVWF  6E
0A2E:  CLRF   75
0A2F:  CLRF   74
0A30:  CLRF   73
0A31:  CLRF   72
0A32:  CLRF   7E
0A33:  CLRF   7D
0A34:  MOVLW  34
0A35:  MOVWF  7C
0A36:  MOVLW  86
0A37:  MOVWF  7B
0A38:  BSF    03.5
0A39:  CLRF   23
0A3A:  CLRF   22
0A3B:  MOVLW  77
0A3C:  MOVWF  21
0A3D:  MOVLW  86
0A3E:  MOVWF  20
0A3F:  CLRF   27
0A40:  MOVLW  40
0A41:  MOVWF  26
0A42:  MOVLW  1C
0A43:  MOVWF  25
0A44:  MOVLW  89
0A45:  MOVWF  24
*
0C54:  MOVF   79,W
0C55:  MOVWF  62
0C56:  MOVF   78,W
0C57:  MOVWF  61
....................    t=t/20; 
0C58:  MOVF   68,W
0C59:  MOVWF  6B
0C5A:  MOVF   67,W
0C5B:  MOVWF  6A
0C5C:  CLRF   6D
0C5D:  MOVLW  14
0C5E:  MOVWF  6C
*
0C9C:  MOVF   79,W
0C9D:  MOVWF  68
0C9E:  MOVF   78,W
0C9F:  MOVWF  67
....................    for(;t>0;t--) 
0CA0:  BTFSC  68.7
0CA1:  GOTO   4F2
0CA2:  MOVF   68,F
0CA3:  BTFSS  03.2
0CA4:  GOTO   4A9
0CA5:  MOVF   67,W
0CA6:  SUBLW  00
0CA7:  BTFSC  03.0
0CA8:  GOTO   4F2
....................    { 
....................       // phat xung trong 20ms 
....................     if(servo==1) 
0CA9:  DECFSZ 69,W
0CAA:  GOTO   4CA
....................     { 
....................       output_bit(PIN_D1,1); 
0CAB:  BSF    08.1
0CAC:  BSF    03.5
0CAD:  BCF    08.1
....................       Delay4us(Ton); 
0CAE:  BCF    03.5
0CAF:  MOVF   62,W
0CB0:  MOVWF  6D
0CB1:  MOVF   61,W
0CB2:  MOVWF  6C
0CB3:  BCF    0A.3
0CB4:  CALL   667
0CB5:  BSF    0A.3
....................       output_bit(PIN_D1,0); 
0CB6:  BCF    08.1
0CB7:  BSF    03.5
0CB8:  BCF    08.1
....................       Delay4us(ChuKy-Ton); 
0CB9:  BCF    03.5
0CBA:  MOVF   61,W
0CBB:  SUBWF  63,W
0CBC:  MOVWF  6A
0CBD:  MOVF   64,W
0CBE:  MOVWF  6B
0CBF:  MOVF   62,W
0CC0:  BTFSS  03.0
0CC1:  INCFSZ 62,W
0CC2:  SUBWF  6B,F
0CC3:  MOVF   6B,W
0CC4:  MOVWF  6D
0CC5:  MOVF   6A,W
0CC6:  MOVWF  6C
0CC7:  BCF    0A.3
0CC8:  CALL   667
0CC9:  BSF    0A.3
....................     } 
....................      if(servo==2) 
0CCA:  MOVF   69,W
0CCB:  SUBLW  02
0CCC:  BTFSS  03.2
0CCD:  GOTO   4ED
....................     { 
....................       output_bit(PIN_D0,1); 
0CCE:  BSF    08.0
0CCF:  BSF    03.5
0CD0:  BCF    08.0
....................       Delay4us(Ton); 
0CD1:  BCF    03.5
0CD2:  MOVF   62,W
0CD3:  MOVWF  6D
0CD4:  MOVF   61,W
0CD5:  MOVWF  6C
0CD6:  BCF    0A.3
0CD7:  CALL   667
0CD8:  BSF    0A.3
....................       output_bit(PIN_D0,0); 
0CD9:  BCF    08.0
0CDA:  BSF    03.5
0CDB:  BCF    08.0
....................       Delay4us(ChuKy-Ton); 
0CDC:  BCF    03.5
0CDD:  MOVF   61,W
0CDE:  SUBWF  63,W
0CDF:  MOVWF  6A
0CE0:  MOVF   64,W
0CE1:  MOVWF  6B
0CE2:  MOVF   62,W
0CE3:  BTFSS  03.0
0CE4:  INCFSZ 62,W
0CE5:  SUBWF  6B,F
0CE6:  MOVF   6B,W
0CE7:  MOVWF  6D
0CE8:  MOVF   6A,W
0CE9:  MOVWF  6C
0CEA:  BCF    0A.3
0CEB:  CALL   667
0CEC:  BSF    0A.3
....................     } 
0CED:  MOVF   67,W
0CEE:  BTFSC  03.2
0CEF:  DECF   68,F
0CF0:  DECF   67,F
0CF1:  GOTO   4A0
....................    } 
0CF2:  RETURN
.................... } 
....................  
.................... void DC_motor_run() 
.................... { 
....................  
....................    setup_timer_2(T2_DIV_BY_16,249,1);      //800 us overflow, 800 us interrupt 
....................    setup_ccp2(CCP_PWM); 
....................    set_pwm2_duty((int16)299); 
....................    output_bit(PIN_C3,0); 
.................... } 
.................... void DC_motor_off() 
.................... { 
.................... setup_ccp2(CCP_OFF); 
....................  
.................... } 
.................... void WriteBack() 
.................... {  
....................    output_bit(PIN_D1,0); 
*
0673:  BCF    08.1
0674:  BSF    03.5
0675:  BCF    08.1
....................    output_bit(PIN_D0,0); 
0676:  BCF    03.5
0677:  BCF    08.0
0678:  BSF    03.5
0679:  BCF    08.0
067A:  BCF    03.5
067B:  RETURN
.................... } 
....................  
.................... #INT_EXT 
.................... void  EXT_isr(void)  
.................... {   
....................    count=count+1.0; 
*
01AE:  BCF    03.1
01AF:  MOVF   54,W
01B0:  BSF    03.5
01B1:  MOVWF  43
01B2:  BCF    03.5
01B3:  MOVF   53,W
01B4:  BSF    03.5
01B5:  MOVWF  42
01B6:  BCF    03.5
01B7:  MOVF   52,W
01B8:  BSF    03.5
01B9:  MOVWF  41
01BA:  BCF    03.5
01BB:  MOVF   51,W
01BC:  BSF    03.5
01BD:  MOVWF  40
01BE:  CLRF   47
01BF:  CLRF   46
01C0:  CLRF   45
01C1:  MOVLW  7F
01C2:  MOVWF  44
01C3:  BCF    03.5
01C4:  CALL   068
01C5:  MOVF   7A,W
01C6:  MOVWF  54
01C7:  MOVF   79,W
01C8:  MOVWF  53
01C9:  MOVF   78,W
01CA:  MOVWF  52
01CB:  MOVF   77,W
01CC:  MOVWF  51
.................... } 
....................  
01CD:  BCF    0B.1
01CE:  BCF    0A.3
01CF:  BCF    0A.4
01D0:  GOTO   03B
.................... #INT_RB 
.................... void Stop() 
.................... { 
....................    if(Input(Pin_B5)==0) 
01D1:  BSF    03.5
01D2:  BSF    06.5
01D3:  BCF    03.5
01D4:  BTFSS  06.5
....................       {   
....................          isFromButtonPressed=0;      
01D5:  CLRF   35
....................       } 
.................... } 
....................  
01D6:  BCF    0B.0
01D7:  BCF    0A.3
01D8:  BCF    0A.4
01D9:  GOTO   03B
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  
.................... {   
....................    switch(color_flag) 
*
0207:  MOVF   4A,W
0208:  ADDLW  FC
0209:  BTFSC  03.0
020A:  GOTO   245
020B:  ADDLW  04
020C:  GOTO   249
....................       {   
....................       case 0:   
....................               TCS_mode(0,0);  
020D:  BSF    03.5
020E:  CLRF   40
020F:  CLRF   41
0210:  BCF    03.5
0211:  CALL   1DA
....................                
....................               break; 
0212:  GOTO   245
....................       case 1: red_freq=count; 
0213:  MOVF   54,W
0214:  MOVWF  58
0215:  MOVF   53,W
0216:  MOVWF  57
0217:  MOVF   52,W
0218:  MOVWF  56
0219:  MOVF   51,W
021A:  MOVWF  55
....................               TCS_mode(1,1);  
021B:  MOVLW  01
021C:  BSF    03.5
021D:  MOVWF  40
021E:  MOVWF  41
021F:  BCF    03.5
0220:  CALL   1DA
....................               output_bit(pin_c5,1); 
0221:  BSF    07.5
0222:  BCF    32.5
0223:  MOVF   32,W
0224:  BSF    03.5
0225:  MOVWF  07
....................               break; 
0226:  BCF    03.5
0227:  GOTO   245
....................       case 2: green_freq=count; 
0228:  MOVF   54,W
0229:  MOVWF  60
022A:  MOVF   53,W
022B:  MOVWF  5F
022C:  MOVF   52,W
022D:  MOVWF  5E
022E:  MOVF   51,W
022F:  MOVWF  5D
....................               TCS_mode(0,1); 
0230:  BSF    03.5
0231:  CLRF   40
0232:  MOVLW  01
0233:  MOVWF  41
0234:  BCF    03.5
0235:  CALL   1DA
....................               break; 
0236:  GOTO   245
....................       case 3: blue_freq=count; 
0237:  MOVF   54,W
0238:  MOVWF  5C
0239:  MOVF   53,W
023A:  MOVWF  5B
023B:  MOVF   52,W
023C:  MOVWF  5A
023D:  MOVF   51,W
023E:  MOVWF  59
....................               TCS_mode(1,0); 
023F:  MOVLW  01
0240:  BSF    03.5
0241:  MOVWF  40
0242:  CLRF   41
0243:  BCF    03.5
0244:  CALL   1DA
....................               break; 
....................       } 
.................... } 
0245:  BCF    0C.0
0246:  BCF    0A.3
0247:  BCF    0A.4
0248:  GOTO   03B
.................... #INT_RDA 
.................... void data_rec() 
.................... { 
....................     
....................    memset(&data_received[0],0,sizeof(data_received)); 
*
0353:  MOVLW  38
0354:  MOVWF  04
0355:  BCF    03.7
0356:  CLRF   77
0357:  MOVLW  05
0358:  MOVWF  78
....................    get_data(); 
....................    on_off=atoi(&data_received[0]); 
*
0385:  BSF    03.5
0386:  CLRF   41
0387:  MOVLW  38
0388:  MOVWF  40
0389:  BCF    03.5
038A:  CALL   251
038B:  MOVF   78,W
038C:  MOVWF  4B
....................    sp_stop=atoi(&data_received[3]); 
038D:  BSF    03.5
038E:  CLRF   41
038F:  MOVLW  3B
0390:  MOVWF  40
0391:  BCF    03.5
0392:  CALL   251
0393:  MOVF   78,W
0394:  MOVWF  4E
....................    time_stop=atoi(&data_received[4]); 
0395:  BSF    03.5
0396:  CLRF   41
0397:  MOVLW  3C
0398:  MOVWF  40
0399:  BCF    03.5
039A:  CALL   251
039B:  MOVF   78,W
039C:  MOVWF  4F
....................    switch(data_received[1]) 
039D:  MOVF   39,W
039E:  XORLW  4C
039F:  BTFSC  03.2
03A0:  GOTO   3A8
03A1:  XORLW  01
03A2:  BTFSC  03.2
03A3:  GOTO   3AB
03A4:  XORLW  05
03A5:  BTFSC  03.2
03A6:  GOTO   3AE
03A7:  GOTO   3B0
....................    {   
....................       case 'L' :speed_mode=LOW_;break; 
03A8:  MOVLW  01
03A9:  MOVWF  4C
03AA:  GOTO   3B0
....................       case 'M' :speed_mode=MEDIUM;break; 
03AB:  MOVLW  02
03AC:  MOVWF  4C
03AD:  GOTO   3B0
....................       case 'H' :speed_mode=HIGH_;break; 
03AE:  MOVLW  03
03AF:  MOVWF  4C
....................    } 
....................    switch(data_received[2]) 
03B0:  MOVF   3A,W
03B1:  XORLW  6C
03B2:  BTFSC  03.2
03B3:  GOTO   3BB
03B4:  XORLW  01
03B5:  BTFSC  03.2
03B6:  GOTO   3BE
03B7:  XORLW  05
03B8:  BTFSC  03.2
03B9:  GOTO   3C1
03BA:  GOTO   3C3
....................    {   
....................       case 'l' :freq_mode=LOW_;break; 
03BB:  MOVLW  01
03BC:  MOVWF  4D
03BD:  GOTO   3C3
....................       case 'm' :freq_mode=MEDIUM;break; 
03BE:  MOVLW  02
03BF:  MOVWF  4D
03C0:  GOTO   3C3
....................       case 'h' :freq_mode=HIGH_;break; 
03C1:  MOVLW  03
03C2:  MOVWF  4D
....................    } 
....................  
03C3:  BCF    0C.5
03C4:  BCF    0A.3
03C5:  BCF    0A.4
03C6:  GOTO   03B
.................... } 
.................... unsigned char TCS3200_getcolor() 
.................... {         
....................      
.................... done=0; 
*
0800:  CLRF   36
....................   setup_timer_1(T1_internal | T1_div_by_8); 
0801:  MOVLW  B5
0802:  MOVWF  10
....................   set_timer1(3036); 
0803:  CLRF   0E
0804:  MOVLW  0B
0805:  MOVWF  0F
0806:  MOVLW  DC
0807:  MOVWF  0E
....................   
....................   while(!done){}; 
0808:  MOVF   36,F
0809:  BTFSC  03.2
080A:  GOTO   008
....................               
....................             lcd_gotoxy(1,1); 
080B:  MOVLW  01
080C:  MOVWF  69
080D:  MOVWF  6A
080E:  BCF    0A.3
080F:  CALL   503
0810:  BSF    0A.3
....................             lcd_putc("RD   BL  GR "); 
0811:  MOVLW  C7
0812:  BSF    03.6
0813:  MOVWF  0D
0814:  MOVLW  03
0815:  MOVWF  0F
0816:  BCF    0A.3
0817:  BCF    03.6
0818:  CALL   541
0819:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
081A:  MOVLW  01
081B:  MOVWF  69
081C:  MOVLW  02
081D:  MOVWF  6A
081E:  BCF    0A.3
081F:  CALL   503
0820:  BSF    0A.3
....................             lcd_putc(red_freq+0x30); 
0821:  BCF    03.1
0822:  CLRF   2B
0823:  BTFSC  0B.7
0824:  BSF    2B.7
0825:  BCF    0B.7
0826:  MOVF   58,W
0827:  BSF    03.5
0828:  MOVWF  43
0829:  BCF    03.5
082A:  MOVF   57,W
082B:  BSF    03.5
082C:  MOVWF  42
082D:  BCF    03.5
082E:  MOVF   56,W
082F:  BSF    03.5
0830:  MOVWF  41
0831:  BCF    03.5
0832:  MOVF   55,W
0833:  BSF    03.5
0834:  MOVWF  40
0835:  CLRF   47
0836:  CLRF   46
0837:  MOVLW  40
0838:  MOVWF  45
0839:  MOVLW  84
083A:  MOVWF  44
083B:  BCF    0A.3
083C:  BCF    03.5
083D:  CALL   068
083E:  BSF    0A.3
083F:  BTFSC  2B.7
0840:  BSF    0B.7
0841:  MOVF   7A,W
0842:  BSF    03.5
0843:  MOVWF  2F
0844:  MOVF   79,W
0845:  MOVWF  2E
0846:  MOVF   78,W
0847:  MOVWF  2D
0848:  MOVF   77,W
0849:  MOVWF  2C
084A:  BCF    0A.3
084B:  BCF    03.5
084C:  CALL   597
084D:  BSF    0A.3
084E:  MOVF   78,W
084F:  MOVWF  65
0850:  MOVWF  68
0851:  BCF    0A.3
0852:  CALL   515
0853:  BSF    0A.3
....................             lcd_gotoxy(5,2); 
0854:  MOVLW  05
0855:  MOVWF  69
0856:  MOVLW  02
0857:  MOVWF  6A
0858:  BCF    0A.3
0859:  CALL   503
085A:  BSF    0A.3
....................             lcd_putc(blue_freq+0x30); 
085B:  BCF    03.1
085C:  CLRF   2B
085D:  BTFSC  0B.7
085E:  BSF    2B.7
085F:  BCF    0B.7
0860:  MOVF   5C,W
0861:  BSF    03.5
0862:  MOVWF  43
0863:  BCF    03.5
0864:  MOVF   5B,W
0865:  BSF    03.5
0866:  MOVWF  42
0867:  BCF    03.5
0868:  MOVF   5A,W
0869:  BSF    03.5
086A:  MOVWF  41
086B:  BCF    03.5
086C:  MOVF   59,W
086D:  BSF    03.5
086E:  MOVWF  40
086F:  CLRF   47
0870:  CLRF   46
0871:  MOVLW  40
0872:  MOVWF  45
0873:  MOVLW  84
0874:  MOVWF  44
0875:  BCF    0A.3
0876:  BCF    03.5
0877:  CALL   068
0878:  BSF    0A.3
0879:  BTFSC  2B.7
087A:  BSF    0B.7
087B:  MOVF   7A,W
087C:  BSF    03.5
087D:  MOVWF  2F
087E:  MOVF   79,W
087F:  MOVWF  2E
0880:  MOVF   78,W
0881:  MOVWF  2D
0882:  MOVF   77,W
0883:  MOVWF  2C
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  CALL   597
0887:  BSF    0A.3
0888:  MOVF   78,W
0889:  MOVWF  65
088A:  MOVWF  68
088B:  BCF    0A.3
088C:  CALL   515
088D:  BSF    0A.3
....................             lcd_gotoxy(9,2); 
088E:  MOVLW  09
088F:  MOVWF  69
0890:  MOVLW  02
0891:  MOVWF  6A
0892:  BCF    0A.3
0893:  CALL   503
0894:  BSF    0A.3
....................             lcd_putc(green_freq+0x30);  
0895:  BCF    03.1
0896:  CLRF   2B
0897:  BTFSC  0B.7
0898:  BSF    2B.7
0899:  BCF    0B.7
089A:  MOVF   60,W
089B:  BSF    03.5
089C:  MOVWF  43
089D:  BCF    03.5
089E:  MOVF   5F,W
089F:  BSF    03.5
08A0:  MOVWF  42
08A1:  BCF    03.5
08A2:  MOVF   5E,W
08A3:  BSF    03.5
08A4:  MOVWF  41
08A5:  BCF    03.5
08A6:  MOVF   5D,W
08A7:  BSF    03.5
08A8:  MOVWF  40
08A9:  CLRF   47
08AA:  CLRF   46
08AB:  MOVLW  40
08AC:  MOVWF  45
08AD:  MOVLW  84
08AE:  MOVWF  44
08AF:  BCF    0A.3
08B0:  BCF    03.5
08B1:  CALL   068
08B2:  BSF    0A.3
08B3:  BTFSC  2B.7
08B4:  BSF    0B.7
08B5:  MOVF   7A,W
08B6:  BSF    03.5
08B7:  MOVWF  2F
08B8:  MOVF   79,W
08B9:  MOVWF  2E
08BA:  MOVF   78,W
08BB:  MOVWF  2D
08BC:  MOVF   77,W
08BD:  MOVWF  2C
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   597
08C1:  BSF    0A.3
08C2:  MOVF   78,W
08C3:  MOVWF  65
08C4:  MOVWF  68
08C5:  BCF    0A.3
08C6:  CALL   515
08C7:  BSF    0A.3
....................             
....................            /*red_freq= Map(red_freq,500,1650,0,255); 
....................            blue_freq= Map(blue_freq,600,1600,0,255); 
....................            green_freq= Map(green_freq,400,1000,0,255);*/ 
....................            cycle++;     
08C8:  INCF   37,F
....................            sum=red_product+blue_product+green_product; 
08C9:  MOVF   47,W
08CA:  ADDWF  46,W
08CB:  ADDWF  48,W
08CC:  MOVWF  49
....................           printf("%d|%d|%d|%d\r\n",red_product,blue_product,green_product,sum); 
08CD:  MOVF   46,W
08CE:  MOVWF  65
08CF:  MOVLW  18
08D0:  MOVWF  66
08D1:  BCF    0A.3
08D2:  CALL   5CD
08D3:  BSF    0A.3
08D4:  MOVLW  7C
08D5:  BTFSS  0C.4
08D6:  GOTO   0D5
08D7:  MOVWF  19
08D8:  MOVF   47,W
08D9:  MOVWF  65
08DA:  MOVLW  18
08DB:  MOVWF  66
08DC:  BCF    0A.3
08DD:  CALL   5CD
08DE:  BSF    0A.3
08DF:  MOVLW  7C
08E0:  BTFSS  0C.4
08E1:  GOTO   0E0
08E2:  MOVWF  19
08E3:  MOVF   48,W
08E4:  MOVWF  65
08E5:  MOVLW  18
08E6:  MOVWF  66
08E7:  BCF    0A.3
08E8:  CALL   5CD
08E9:  BSF    0A.3
08EA:  MOVLW  7C
08EB:  BTFSS  0C.4
08EC:  GOTO   0EB
08ED:  MOVWF  19
08EE:  MOVF   49,W
08EF:  MOVWF  65
08F0:  MOVLW  18
08F1:  MOVWF  66
08F2:  BCF    0A.3
08F3:  CALL   5CD
08F4:  BSF    0A.3
08F5:  MOVLW  0D
08F6:  BTFSS  0C.4
08F7:  GOTO   0F6
08F8:  MOVWF  19
08F9:  MOVLW  0A
08FA:  BTFSS  0C.4
08FB:  GOTO   0FA
08FC:  MOVWF  19
....................             
....................              
....................   if (((red_freq < 150) && (blue_freq < 150)) || ((green_freq < 150) && (blue_freq < 150)) || ((red_freq < 150) && (green_freq < 150))) 
08FD:  MOVF   58,W
08FE:  MOVWF  68
08FF:  MOVF   57,W
0900:  MOVWF  67
0901:  MOVF   56,W
0902:  MOVWF  66
0903:  MOVF   55,W
0904:  MOVWF  65
0905:  CLRF   6C
0906:  CLRF   6B
0907:  MOVLW  16
0908:  MOVWF  6A
0909:  MOVLW  86
090A:  MOVWF  69
090B:  BCF    0A.3
090C:  CALL   628
090D:  BSF    0A.3
090E:  BTFSS  03.0
090F:  GOTO   123
0910:  MOVF   5C,W
0911:  MOVWF  68
0912:  MOVF   5B,W
0913:  MOVWF  67
0914:  MOVF   5A,W
0915:  MOVWF  66
0916:  MOVF   59,W
0917:  MOVWF  65
0918:  CLRF   6C
0919:  CLRF   6B
091A:  MOVLW  16
091B:  MOVWF  6A
091C:  MOVLW  86
091D:  MOVWF  69
091E:  BCF    0A.3
091F:  CALL   628
0920:  BSF    0A.3
0921:  BTFSC  03.0
0922:  GOTO   16F
0923:  MOVF   60,W
0924:  MOVWF  68
0925:  MOVF   5F,W
0926:  MOVWF  67
0927:  MOVF   5E,W
0928:  MOVWF  66
0929:  MOVF   5D,W
092A:  MOVWF  65
092B:  CLRF   6C
092C:  CLRF   6B
092D:  MOVLW  16
092E:  MOVWF  6A
092F:  MOVLW  86
0930:  MOVWF  69
0931:  BCF    0A.3
0932:  CALL   628
0933:  BSF    0A.3
0934:  BTFSS  03.0
0935:  GOTO   149
0936:  MOVF   5C,W
0937:  MOVWF  68
0938:  MOVF   5B,W
0939:  MOVWF  67
093A:  MOVF   5A,W
093B:  MOVWF  66
093C:  MOVF   59,W
093D:  MOVWF  65
093E:  CLRF   6C
093F:  CLRF   6B
0940:  MOVLW  16
0941:  MOVWF  6A
0942:  MOVLW  86
0943:  MOVWF  69
0944:  BCF    0A.3
0945:  CALL   628
0946:  BSF    0A.3
0947:  BTFSC  03.0
0948:  GOTO   16F
0949:  MOVF   58,W
094A:  MOVWF  68
094B:  MOVF   57,W
094C:  MOVWF  67
094D:  MOVF   56,W
094E:  MOVWF  66
094F:  MOVF   55,W
0950:  MOVWF  65
0951:  CLRF   6C
0952:  CLRF   6B
0953:  MOVLW  16
0954:  MOVWF  6A
0955:  MOVLW  86
0956:  MOVWF  69
0957:  BCF    0A.3
0958:  CALL   628
0959:  BSF    0A.3
095A:  BTFSS  03.0
095B:  GOTO   173
095C:  MOVF   60,W
095D:  MOVWF  68
095E:  MOVF   5F,W
095F:  MOVWF  67
0960:  MOVF   5E,W
0961:  MOVWF  66
0962:  MOVF   5D,W
0963:  MOVWF  65
0964:  CLRF   6C
0965:  CLRF   6B
0966:  MOVLW  16
0967:  MOVWF  6A
0968:  MOVLW  86
0969:  MOVWF  69
096A:  BCF    0A.3
096B:  CALL   628
096C:  BSF    0A.3
096D:  BTFSS  03.0
096E:  GOTO   173
....................         return UNIDENTIFIED; 
096F:  MOVLW  00
0970:  MOVWF  78
0971:  GOTO   1FB
0972:  GOTO   1FB
....................   else 
....................     { 
....................         if ((red_freq > blue_freq) && (red_freq > green_freq)) 
0973:  MOVF   5C,W
0974:  MOVWF  68
0975:  MOVF   5B,W
0976:  MOVWF  67
0977:  MOVF   5A,W
0978:  MOVWF  66
0979:  MOVF   59,W
097A:  MOVWF  65
097B:  MOVF   58,W
097C:  MOVWF  6C
097D:  MOVF   57,W
097E:  MOVWF  6B
097F:  MOVF   56,W
0980:  MOVWF  6A
0981:  MOVF   55,W
0982:  MOVWF  69
0983:  BCF    0A.3
0984:  CALL   628
0985:  BSF    0A.3
0986:  BTFSS  03.0
0987:  GOTO   1A1
0988:  MOVF   60,W
0989:  MOVWF  68
098A:  MOVF   5F,W
098B:  MOVWF  67
098C:  MOVF   5E,W
098D:  MOVWF  66
098E:  MOVF   5D,W
098F:  MOVWF  65
0990:  MOVF   58,W
0991:  MOVWF  6C
0992:  MOVF   57,W
0993:  MOVWF  6B
0994:  MOVF   56,W
0995:  MOVWF  6A
0996:  MOVF   55,W
0997:  MOVWF  69
0998:  BCF    0A.3
0999:  CALL   628
099A:  BSF    0A.3
099B:  BTFSS  03.0
099C:  GOTO   1A1
....................             return COLOR_RED; 
099D:  MOVLW  01
099E:  MOVWF  78
099F:  GOTO   1FB
09A0:  GOTO   1FB
....................         else if ((blue_freq > red_freq) && (blue_freq > green_freq)) 
09A1:  MOVF   58,W
09A2:  MOVWF  68
09A3:  MOVF   57,W
09A4:  MOVWF  67
09A5:  MOVF   56,W
09A6:  MOVWF  66
09A7:  MOVF   55,W
09A8:  MOVWF  65
09A9:  MOVF   5C,W
09AA:  MOVWF  6C
09AB:  MOVF   5B,W
09AC:  MOVWF  6B
09AD:  MOVF   5A,W
09AE:  MOVWF  6A
09AF:  MOVF   59,W
09B0:  MOVWF  69
09B1:  BCF    0A.3
09B2:  CALL   628
09B3:  BSF    0A.3
09B4:  BTFSS  03.0
09B5:  GOTO   1CF
09B6:  MOVF   60,W
09B7:  MOVWF  68
09B8:  MOVF   5F,W
09B9:  MOVWF  67
09BA:  MOVF   5E,W
09BB:  MOVWF  66
09BC:  MOVF   5D,W
09BD:  MOVWF  65
09BE:  MOVF   5C,W
09BF:  MOVWF  6C
09C0:  MOVF   5B,W
09C1:  MOVWF  6B
09C2:  MOVF   5A,W
09C3:  MOVWF  6A
09C4:  MOVF   59,W
09C5:  MOVWF  69
09C6:  BCF    0A.3
09C7:  CALL   628
09C8:  BSF    0A.3
09C9:  BTFSS  03.0
09CA:  GOTO   1CF
....................             return COLOR_BLUE; 
09CB:  MOVLW  02
09CC:  MOVWF  78
09CD:  GOTO   1FB
09CE:  GOTO   1FB
....................         else if ((green_freq > red_freq) && (green_freq > blue_freq)) 
09CF:  MOVF   58,W
09D0:  MOVWF  68
09D1:  MOVF   57,W
09D2:  MOVWF  67
09D3:  MOVF   56,W
09D4:  MOVWF  66
09D5:  MOVF   55,W
09D6:  MOVWF  65
09D7:  MOVF   60,W
09D8:  MOVWF  6C
09D9:  MOVF   5F,W
09DA:  MOVWF  6B
09DB:  MOVF   5E,W
09DC:  MOVWF  6A
09DD:  MOVF   5D,W
09DE:  MOVWF  69
09DF:  BCF    0A.3
09E0:  CALL   628
09E1:  BSF    0A.3
09E2:  BTFSS  03.0
09E3:  GOTO   1FB
09E4:  MOVF   5C,W
09E5:  MOVWF  68
09E6:  MOVF   5B,W
09E7:  MOVWF  67
09E8:  MOVF   5A,W
09E9:  MOVWF  66
09EA:  MOVF   59,W
09EB:  MOVWF  65
09EC:  MOVF   60,W
09ED:  MOVWF  6C
09EE:  MOVF   5F,W
09EF:  MOVWF  6B
09F0:  MOVF   5E,W
09F1:  MOVWF  6A
09F2:  MOVF   5D,W
09F3:  MOVWF  69
09F4:  BCF    0A.3
09F5:  CALL   628
09F6:  BSF    0A.3
09F7:  BTFSS  03.0
09F8:  GOTO   1FB
....................             return COLOR_GREEN; 
09F9:  MOVLW  03
09FA:  MOVWF  78
....................     }     
09FB:  BCF    0A.3
09FC:  BCF    0A.4
09FD:  GOTO   6FF (RETURN)
.................... } 
....................  
.................... void main() 
*
067C:  MOVF   03,W
067D:  ANDLW  1F
067E:  MOVWF  03
067F:  MOVLW  81
0680:  BSF    03.5
0681:  MOVWF  19
0682:  MOVLW  A6
0683:  MOVWF  18
0684:  MOVLW  90
0685:  BCF    03.5
0686:  MOVWF  18
0687:  MOVLW  FF
0688:  MOVWF  32
0689:  CLRF   33
068A:  CLRF   34
068B:  CLRF   35
068C:  CLRF   36
068D:  CLRF   41
068E:  CLRF   42
068F:  CLRF   43
0690:  CLRF   44
0691:  CLRF   45
0692:  CLRF   46
0693:  CLRF   47
0694:  CLRF   48
0695:  CLRF   4A
0696:  CLRF   4B
0697:  CLRF   50
0698:  MOVLW  27
0699:  MOVWF  64
069A:  MOVLW  10
069B:  MOVWF  63
069C:  BSF    03.5
069D:  BSF    1F.0
069E:  BSF    1F.1
069F:  BSF    1F.2
06A0:  BCF    1F.3
06A1:  MOVLW  07
06A2:  MOVWF  1C
06A3:  BCF    03.7
....................  
.................... {   
....................   port_b_pullups(true); 
*
06B7:  BSF    03.5
06B8:  BCF    01.7
....................    lcd_init();  
06B9:  BCF    03.5
06BA:  GOTO   4B7
....................    enable_interrupts(INT_EXT); 
06BB:  BSF    0B.4
....................    enable_interrupts(INT_rb); 
06BC:  BSF    0B.3
....................    enable_interrupts(INT_RDA); 
06BD:  BSF    03.5
06BE:  BSF    0C.5
....................    enable_interrupts(INT_TIMER1); 
06BF:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
06C0:  MOVLW  C0
06C1:  BCF    03.5
06C2:  IORWF  0B,F
....................    set_tris_b(0x31); 
06C3:  MOVLW  31
06C4:  BSF    03.5
06C5:  MOVWF  06
....................  
.................... while (1){ 
....................         
....................       if(Input(Pin_B4)==0) 
06C6:  BSF    06.4
06C7:  BCF    03.5
06C8:  BTFSC  06.4
06C9:  GOTO   6CC
....................       {       
....................          isFromButtonPressed=1;  
06CA:  MOVLW  01
06CB:  MOVWF  35
....................       }      
....................       
....................       if ( !is_running)         
06CC:  MOVF   50,F
06CD:  BTFSS  03.2
06CE:  GOTO   6FA
....................           {  
....................              
....................             is_running=1; 
06CF:  MOVLW  01
06D0:  MOVWF  50
....................              //DC_motor_run(); 
....................              count_enable = 1; 
06D1:  MOVWF  34
....................              switch(freq_mode) 
06D2:  MOVF   4D,W
06D3:  XORLW  01
06D4:  BTFSC  03.2
06D5:  GOTO   6DD
06D6:  XORLW  03
06D7:  BTFSC  03.2
06D8:  GOTO   6E7
06D9:  XORLW  01
06DA:  BTFSC  03.2
06DB:  GOTO   6F1
06DC:  GOTO   6FA
....................              { 
....................              case LOW_: output_low(S_0); 
06DD:  MOVLW  E0
06DE:  BSF    03.5
06DF:  MOVWF  05
06E0:  BCF    03.5
06E1:  BCF    05.0
....................                         output_high(S_1); 
06E2:  BSF    03.5
06E3:  MOVWF  05
06E4:  BCF    03.5
06E5:  BSF    05.1
....................                         break; 
06E6:  GOTO   6FA
....................              case MEDIUM: output_low(S_1); 
06E7:  MOVLW  E0
06E8:  BSF    03.5
06E9:  MOVWF  05
06EA:  BCF    03.5
06EB:  BCF    05.1
....................                           output_high(S_0); 
06EC:  BSF    03.5
06ED:  MOVWF  05
06EE:  BCF    03.5
06EF:  BSF    05.0
....................                         break; 
06F0:  GOTO   6FA
....................              case HIGH_: output_high(S_0); 
06F1:  MOVLW  E0
06F2:  BSF    03.5
06F3:  MOVWF  05
06F4:  BCF    03.5
06F5:  BSF    05.0
....................                         output_high(S_1); 
06F6:  BSF    03.5
06F7:  MOVWF  05
06F8:  BCF    03.5
06F9:  BSF    05.1
....................                         break;  
....................              }          
....................           } 
....................                      
....................      /* else if ((on_off==OFF_)&&is_running) 
....................       {     is_running=0; 
....................             count_enable = 0; 
....................             DC_motor_off(); 
....................             color_count = red_count = blue_count = green_count = blind_count = 0; 
....................             red_product = blue_product = green_product = 0; 
....................             has_product = 0; 
....................             {  
....................                lcd_putc("\f"); 
....................                lcd_gotoxy(5,1); 
....................                printf(lcd_putc,"STOPP !!!"); 
....................                delay_ms(500); 
....................             } 
....................       } 
....................       */ 
....................       if (count_enable) 
06FA:  MOVF   34,F
06FB:  BTFSC  03.2
06FC:  GOTO   7DE
....................       {        
....................          
....................             switch(TCS3200_getColor()) 
06FD:  BSF    0A.3
06FE:  GOTO   000
06FF:  BCF    0A.3
0700:  MOVF   78,W
0701:  ADDLW  FC
0702:  BTFSC  03.0
0703:  GOTO   70D
0704:  ADDLW  04
0705:  GOTO   7E1
....................             { 
....................             case COLOR_RED : 
....................                 red_count++; 
0706:  INCF   42,F
....................                 break; 
0707:  GOTO   70D
....................             case COLOR_BLUE : 
....................                 blue_count++; 
0708:  INCF   43,F
....................                 break; 
0709:  GOTO   70D
....................             case COLOR_GREEN : 
....................                 green_count++; 
070A:  INCF   44,F
....................                 break; 
070B:  GOTO   70D
....................             case UNIDENTIFIED : 
....................                 blind_count++; 
070C:  INCF   45,F
....................                 break; 
....................             } 
....................          
....................             color_count++; 
070D:  INCF   41,F
.................... //!                        lcd_putc("\f"); 
.................... //!                        lcd_gotoxy(7,2); 
.................... //!                        lcd_putc(red_count+0x30);        
.................... //!                        lcd_gotoxy(1,2); 
.................... //!                        lcd_putc(has_product+0x30);      
....................             if (color_count >= COLOR_COUNT_MAX) 
070E:  MOVF   41,W
070F:  SUBLW  03
0710:  BTFSC  03.0
0711:  GOTO   767
....................             { 
....................                 color_count = 0; 
0712:  CLRF   41
....................                  
....................                 if (!has_product) 
0713:  MOVF   33,F
0714:  BTFSS  03.2
0715:  GOTO   756
....................                 {             
....................                     if ((red_count > blue_count) && (red_count > green_count) && (red_count > blind_count)) 
0716:  MOVF   42,W
0717:  SUBWF  43,W
0718:  BTFSC  03.0
0719:  GOTO   727
071A:  MOVF   42,W
071B:  SUBWF  44,W
071C:  BTFSC  03.0
071D:  GOTO   727
071E:  MOVF   42,W
071F:  SUBWF  45,W
0720:  BTFSC  03.0
0721:  GOTO   727
....................                      {  
....................                       
....................                         red_product++; 
0722:  INCF   46,F
....................                         has_product = 1; 
0723:  MOVLW  01
0724:  MOVWF  33
....................                         has_red=1; 
0725:  MOVWF  3E
....................                     }                  
0726:  GOTO   755
....................                     else if ((blue_count > red_count) && (blue_count > green_count) && (blue_count > blind_count)) 
0727:  MOVF   43,W
0728:  SUBWF  42,W
0729:  BTFSC  03.0
072A:  GOTO   738
072B:  MOVF   43,W
072C:  SUBWF  44,W
072D:  BTFSC  03.0
072E:  GOTO   738
072F:  MOVF   43,W
0730:  SUBWF  45,W
0731:  BTFSC  03.0
0732:  GOTO   738
....................                     { 
....................  
....................                         blue_product++; 
0733:  INCF   47,F
....................                         has_product = 1; 
0734:  MOVLW  01
0735:  MOVWF  33
....................                         has_blue=1; 
0736:  MOVWF  3F
....................                     } 
0737:  GOTO   755
....................                     else if ((green_count > red_count) && (green_count > blue_count) && (green_count > blind_count)) 
0738:  MOVF   44,W
0739:  SUBWF  42,W
073A:  BTFSC  03.0
073B:  GOTO   749
073C:  MOVF   44,W
073D:  SUBWF  43,W
073E:  BTFSC  03.0
073F:  GOTO   749
0740:  MOVF   44,W
0741:  SUBWF  45,W
0742:  BTFSC  03.0
0743:  GOTO   749
....................                     { 
....................  
....................                         green_product++; 
0744:  INCF   48,F
....................                         has_product = 1; 
0745:  MOVLW  01
0746:  MOVWF  33
....................                         has_green=1; 
0747:  MOVWF  40
....................                     } 
0748:  GOTO   755
....................                     else if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0749:  MOVF   45,W
074A:  SUBWF  42,W
074B:  BTFSC  03.0
074C:  GOTO   755
074D:  MOVF   45,W
074E:  SUBWF  44,W
074F:  BTFSC  03.0
0750:  GOTO   755
0751:  MOVF   45,W
0752:  SUBWF  43,W
0753:  BTFSC  03.0
0754:  GOTO   755
....................                     { 
....................  
....................                     } 
....................                 } 
0755:  GOTO   762
....................                 else 
....................                 { 
....................                     if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0756:  MOVF   45,W
0757:  SUBWF  42,W
0758:  BTFSC  03.0
0759:  GOTO   762
075A:  MOVF   45,W
075B:  SUBWF  44,W
075C:  BTFSC  03.0
075D:  GOTO   762
075E:  MOVF   45,W
075F:  SUBWF  43,W
0760:  BTFSS  03.0
....................                         has_product = 0; 
0761:  CLRF   33
....................                         
....................                 } 
....................                              
....................                 red_count = blue_count = green_count = blind_count = 0; 
0762:  CLRF   45
0763:  MOVF   45,W
0764:  MOVWF  44
0765:  MOVWF  43
0766:  MOVWF  42
....................                 
....................             } 
....................         
....................                lcd_putc("\f"); 
0767:  MOVLW  CE
0768:  BSF    03.6
0769:  MOVWF  0D
076A:  MOVLW  03
076B:  MOVWF  0F
076C:  BCF    03.6
076D:  CALL   541
....................             lcd_putc("RD   BL  GR "); 
076E:  MOVLW  CF
076F:  BSF    03.6
0770:  MOVWF  0D
0771:  MOVLW  03
0772:  MOVWF  0F
0773:  BCF    03.6
0774:  CALL   541
....................             lcd_gotoxy(1,2); 
0775:  MOVLW  01
0776:  MOVWF  69
0777:  MOVLW  02
0778:  MOVWF  6A
0779:  CALL   503
....................             lcd_putc(red_product+0x30); 
077A:  MOVLW  30
077B:  ADDWF  46,W
077C:  MOVWF  65
077D:  MOVWF  68
077E:  CALL   515
....................             lcd_gotoxy(5,2); 
077F:  MOVLW  05
0780:  MOVWF  69
0781:  MOVLW  02
0782:  MOVWF  6A
0783:  CALL   503
....................             lcd_putc(blue_product+0x30); 
0784:  MOVLW  30
0785:  ADDWF  47,W
0786:  MOVWF  65
0787:  MOVWF  68
0788:  CALL   515
....................             lcd_gotoxy(9,2); 
0789:  MOVLW  09
078A:  MOVWF  69
078B:  MOVLW  02
078C:  MOVWF  6A
078D:  CALL   503
....................             lcd_putc(green_product+0x30);  
078E:  MOVLW  30
078F:  ADDWF  48,W
0790:  MOVWF  65
0791:  MOVWF  68
0792:  CALL   515
....................             lcd_gotoxy(4,1); 
0793:  MOVLW  04
0794:  MOVWF  69
0795:  MOVLW  01
0796:  MOVWF  6A
0797:  CALL   503
....................             lcd_putc(input_state(pin_C2)+0x30);   
0798:  MOVLW  00
0799:  BTFSC  07.2
079A:  MOVLW  01
079B:  ADDLW  30
079C:  MOVWF  65
079D:  MOVWF  68
079E:  CALL   515
....................            if(has_red) 
079F:  MOVF   3E,F
07A0:  BTFSC  03.2
07A1:  GOTO   7BD
....................             { 
....................               if(!input_state(pin_E0)) 
07A2:  BTFSC  09.0
07A3:  GOTO   7BD
....................              {//servo1  
....................                Write(120,1000,1); 
07A4:  CLRF   66
07A5:  MOVLW  78
07A6:  MOVWF  65
07A7:  MOVLW  03
07A8:  MOVWF  68
07A9:  MOVLW  E8
07AA:  MOVWF  67
07AB:  MOVLW  01
07AC:  MOVWF  69
07AD:  BSF    0A.3
07AE:  CALL   1FE
07AF:  BCF    0A.3
....................                Write(0,1000,1); 
07B0:  CLRF   66
07B1:  CLRF   65
07B2:  MOVLW  03
07B3:  MOVWF  68
07B4:  MOVLW  E8
07B5:  MOVWF  67
07B6:  MOVLW  01
07B7:  MOVWF  69
07B8:  BSF    0A.3
07B9:  CALL   1FE
07BA:  BCF    0A.3
....................                WriteBack();                 
07BB:  CALL   673
....................                has_red=0; 
07BC:  CLRF   3E
....................  
....................              } 
....................                 
....................             } 
....................              
....................             if(has_blue) 
07BD:  MOVF   3F,F
07BE:  BTFSC  03.2
07BF:  GOTO   7DB
....................              {  
....................              if(!input_state(pin_C2)){has_blue=0;} 
07C0:  BTFSS  07.2
07C1:  CLRF   3F
....................               //Oservo2 
....................               { 
....................                Write(120,1000,2); 
07C2:  CLRF   66
07C3:  MOVLW  78
07C4:  MOVWF  65
07C5:  MOVLW  03
07C6:  MOVWF  68
07C7:  MOVLW  E8
07C8:  MOVWF  67
07C9:  MOVLW  02
07CA:  MOVWF  69
07CB:  BSF    0A.3
07CC:  CALL   1FE
07CD:  BCF    0A.3
....................                Write(0,1000,2); 
07CE:  CLRF   66
07CF:  CLRF   65
07D0:  MOVLW  03
07D1:  MOVWF  68
07D2:  MOVLW  E8
07D3:  MOVWF  67
07D4:  MOVLW  02
07D5:  MOVWF  69
07D6:  BSF    0A.3
07D7:  CALL   1FE
07D8:  BCF    0A.3
....................                WriteBack();                 
07D9:  CALL   673
....................                has_blue=0; 
07DA:  CLRF   3F
....................               } 
....................              } 
....................              if(has_green) 
07DB:  MOVF   40,F
07DC:  BTFSS  03.2
....................              { 
....................                has_green=0; 
07DD:  CLRF   40
....................              } 
....................                       
....................      //LCD 
....................       } 
07DE:  BSF    03.5
07DF:  GOTO   6C6
....................    /*   else 
....................       {      
....................             lcd_gotoxy(1,1); 
....................             lcd_putc("    MACH DEM SP"); 
....................             lcd_gotoxy(1,2); 
....................             lcd_putc("  CAM BIEN MAU"); 
....................       } 
....................       */ 
.................... } 
....................  
.................... } 
07E0:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
