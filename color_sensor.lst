CCS PCM C Compiler, Version 5.025, 54110               23-Jul-20 01:24

               Filename:   C:\Users\Admin\Desktop\DoAnXuLyTin\color_sensor.lst

               ROM used:   3177 words (39%)
                           Largest free fragment is 2048
               RAM used:   75 (20%) at main() level
                           144 (39%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   310
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   05C
002B:  BTFSS  0B.4
002C:  GOTO   02F
002D:  BTFSC  0B.1
002E:  GOTO   05F
002F:  MOVLW  8C
0030:  MOVWF  04
0031:  BTFSS  00.5
0032:  GOTO   035
0033:  BTFSC  0C.5
0034:  GOTO   062
0035:  MOVLW  8C
0036:  MOVWF  04
0037:  BTFSS  00.0
0038:  GOTO   03B
0039:  BTFSC  0C.0
003A:  GOTO   065
003B:  MOVF   22,W
003C:  MOVWF  04
003D:  MOVF   23,W
003E:  MOVWF  77
003F:  MOVF   24,W
0040:  MOVWF  78
0041:  MOVF   25,W
0042:  MOVWF  79
0043:  MOVF   26,W
0044:  MOVWF  7A
0045:  MOVF   27,W
0046:  BSF    03.6
0047:  MOVWF  0D
0048:  BCF    03.6
0049:  MOVF   28,W
004A:  BSF    03.6
004B:  MOVWF  0F
004C:  BCF    03.6
004D:  MOVF   29,W
004E:  BSF    03.6
004F:  MOVWF  0C
0050:  BCF    03.6
0051:  MOVF   2A,W
0052:  BSF    03.6
0053:  MOVWF  0E
0054:  BCF    03.6
0055:  MOVF   20,W
0056:  MOVWF  0A
0057:  SWAPF  21,W
0058:  MOVWF  03
0059:  SWAPF  7F,F
005A:  SWAPF  7F,W
005B:  RETFIE
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   1D1
005F:  BCF    0A.3
0060:  BCF    0A.4
0061:  GOTO   1AE
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   34D
0065:  BCF    0A.3
0066:  BCF    0A.4
0067:  GOTO   207
.................... #include <color_sensor.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0068:  MOVLW  80
0069:  BTFSS  03.1
006A:  GOTO   06E
006B:  BSF    03.5
006C:  XORWF  45,F
006D:  BCF    03.5
006E:  BSF    03.5
006F:  CLRF   4A
0070:  CLRF   4B
0071:  MOVF   41,W
0072:  MOVWF  49
0073:  MOVF   45,W
0074:  XORWF  49,F
0075:  MOVF   40,W
0076:  BTFSC  03.2
0077:  GOTO   15C
0078:  MOVWF  48
0079:  MOVWF  77
007A:  MOVF   44,W
007B:  BTFSC  03.2
007C:  GOTO   165
007D:  SUBWF  48,F
007E:  BTFSC  03.2
007F:  GOTO   101
0080:  BTFSS  03.0
0081:  GOTO   0BF
0082:  MOVF   45,W
0083:  MOVWF  4E
0084:  BSF    4E.7
0085:  MOVF   46,W
0086:  MOVWF  4D
0087:  MOVF   47,W
0088:  MOVWF  4C
0089:  CLRF   4B
008A:  BCF    03.0
008B:  RRF    4E,F
008C:  RRF    4D,F
008D:  RRF    4C,F
008E:  RRF    4B,F
008F:  DECFSZ 48,F
0090:  GOTO   089
0091:  BTFSS  49.7
0092:  GOTO   096
0093:  BSF    4A.0
0094:  GOTO   179
0095:  BCF    4A.0
0096:  BCF    48.0
0097:  BSF    4A.4
0098:  MOVLW  C3
0099:  MOVWF  04
009A:  BCF    03.7
009B:  GOTO   18E
009C:  BCF    4A.4
009D:  BTFSC  49.7
009E:  GOTO   0A9
009F:  BTFSS  48.0
00A0:  GOTO   0B4
00A1:  RRF    4E,F
00A2:  RRF    4D,F
00A3:  RRF    4C,F
00A4:  RRF    4B,F
00A5:  INCF   77,F
00A6:  BTFSC  03.2
00A7:  GOTO   174
00A8:  GOTO   0B4
00A9:  BTFSC  4E.7
00AA:  GOTO   0B7
00AB:  BCF    03.0
00AC:  RLF    4B,F
00AD:  RLF    4C,F
00AE:  RLF    4D,F
00AF:  RLF    4E,F
00B0:  DECF   77,F
00B1:  BTFSC  03.2
00B2:  GOTO   174
00B3:  GOTO   0A9
00B4:  BSF    4A.6
00B5:  GOTO   121
00B6:  BCF    4A.6
00B7:  MOVF   41,W
00B8:  MOVWF  49
00B9:  BTFSS  49.7
00BA:  GOTO   0BD
00BB:  BSF    4E.7
00BC:  GOTO   16D
00BD:  BCF    4E.7
00BE:  GOTO   16D
00BF:  MOVF   44,W
00C0:  MOVWF  48
00C1:  MOVWF  77
00C2:  MOVF   40,W
00C3:  SUBWF  48,F
00C4:  MOVF   41,W
00C5:  MOVWF  4E
00C6:  BSF    4E.7
00C7:  MOVF   42,W
00C8:  MOVWF  4D
00C9:  MOVF   43,W
00CA:  MOVWF  4C
00CB:  CLRF   4B
00CC:  BCF    03.0
00CD:  RRF    4E,F
00CE:  RRF    4D,F
00CF:  RRF    4C,F
00D0:  RRF    4B,F
00D1:  DECFSZ 48,F
00D2:  GOTO   0CB
00D3:  BTFSS  49.7
00D4:  GOTO   0D8
00D5:  BSF    4A.1
00D6:  GOTO   179
00D7:  BCF    4A.1
00D8:  BCF    48.0
00D9:  BSF    4A.5
00DA:  MOVLW  C7
00DB:  MOVWF  04
00DC:  BCF    03.7
00DD:  GOTO   18E
00DE:  BCF    4A.5
00DF:  BTFSC  49.7
00E0:  GOTO   0EB
00E1:  BTFSS  48.0
00E2:  GOTO   0F6
00E3:  RRF    4E,F
00E4:  RRF    4D,F
00E5:  RRF    4C,F
00E6:  RRF    4B,F
00E7:  INCF   77,F
00E8:  BTFSC  03.2
00E9:  GOTO   174
00EA:  GOTO   0F6
00EB:  BTFSC  4E.7
00EC:  GOTO   0F9
00ED:  BCF    03.0
00EE:  RLF    4B,F
00EF:  RLF    4C,F
00F0:  RLF    4D,F
00F1:  RLF    4E,F
00F2:  DECF   77,F
00F3:  BTFSC  03.2
00F4:  GOTO   174
00F5:  GOTO   0EB
00F6:  BSF    4A.7
00F7:  GOTO   121
00F8:  BCF    4A.7
00F9:  MOVF   45,W
00FA:  MOVWF  49
00FB:  BTFSS  49.7
00FC:  GOTO   0FF
00FD:  BSF    4E.7
00FE:  GOTO   16D
00FF:  BCF    4E.7
0100:  GOTO   16D
0101:  MOVF   45,W
0102:  MOVWF  4E
0103:  BSF    4E.7
0104:  MOVF   46,W
0105:  MOVWF  4D
0106:  MOVF   47,W
0107:  MOVWF  4C
0108:  BTFSS  49.7
0109:  GOTO   10E
010A:  BCF    4E.7
010B:  BSF    4A.2
010C:  GOTO   179
010D:  BCF    4A.2
010E:  CLRF   4B
010F:  BCF    48.0
0110:  MOVLW  C3
0111:  MOVWF  04
0112:  BCF    03.7
0113:  GOTO   18E
0114:  BTFSC  49.7
0115:  GOTO   137
0116:  MOVF   41,W
0117:  MOVWF  49
0118:  BTFSS  48.0
0119:  GOTO   121
011A:  RRF    4E,F
011B:  RRF    4D,F
011C:  RRF    4C,F
011D:  RRF    4B,F
011E:  INCF   77,F
011F:  BTFSC  03.2
0120:  GOTO   174
0121:  BTFSS  4B.7
0122:  GOTO   132
0123:  INCF   4C,F
0124:  BTFSS  03.2
0125:  GOTO   132
0126:  INCF   4D,F
0127:  BTFSS  03.2
0128:  GOTO   132
0129:  INCF   4E,F
012A:  BTFSS  03.2
012B:  GOTO   132
012C:  RRF    4E,F
012D:  RRF    4D,F
012E:  RRF    4C,F
012F:  INCF   77,F
0130:  BTFSC  03.2
0131:  GOTO   174
0132:  BTFSC  4A.6
0133:  GOTO   0B6
0134:  BTFSC  4A.7
0135:  GOTO   0F8
0136:  GOTO   156
0137:  MOVLW  80
0138:  XORWF  4E,F
0139:  BTFSS  4E.7
013A:  GOTO   13F
013B:  GOTO   179
013C:  MOVF   45,W
013D:  MOVWF  49
013E:  GOTO   14C
013F:  MOVF   41,W
0140:  MOVWF  49
0141:  MOVF   4E,F
0142:  BTFSS  03.2
0143:  GOTO   14C
0144:  MOVF   4D,F
0145:  BTFSS  03.2
0146:  GOTO   14C
0147:  MOVF   4C,F
0148:  BTFSS  03.2
0149:  GOTO   14C
014A:  CLRF   77
014B:  GOTO   16D
014C:  BTFSC  4E.7
014D:  GOTO   156
014E:  BCF    03.0
014F:  RLF    4B,F
0150:  RLF    4C,F
0151:  RLF    4D,F
0152:  RLF    4E,F
0153:  DECFSZ 77,F
0154:  GOTO   14C
0155:  GOTO   174
0156:  BTFSS  49.7
0157:  GOTO   15A
0158:  BSF    4E.7
0159:  GOTO   16D
015A:  BCF    4E.7
015B:  GOTO   16D
015C:  MOVF   44,W
015D:  MOVWF  77
015E:  MOVF   45,W
015F:  MOVWF  4E
0160:  MOVF   46,W
0161:  MOVWF  4D
0162:  MOVF   47,W
0163:  MOVWF  4C
0164:  GOTO   16D
0165:  MOVF   40,W
0166:  MOVWF  77
0167:  MOVF   41,W
0168:  MOVWF  4E
0169:  MOVF   42,W
016A:  MOVWF  4D
016B:  MOVF   43,W
016C:  MOVWF  4C
016D:  MOVF   4E,W
016E:  MOVWF  78
016F:  MOVF   4D,W
0170:  MOVWF  79
0171:  MOVF   4C,W
0172:  MOVWF  7A
0173:  GOTO   1AC
0174:  CLRF   77
0175:  CLRF   78
0176:  CLRF   79
0177:  CLRF   7A
0178:  GOTO   1AC
0179:  CLRF   4B
017A:  COMF   4C,F
017B:  COMF   4D,F
017C:  COMF   4E,F
017D:  COMF   4B,F
017E:  INCF   4B,F
017F:  BTFSS  03.2
0180:  GOTO   187
0181:  INCF   4C,F
0182:  BTFSS  03.2
0183:  GOTO   187
0184:  INCF   4D,F
0185:  BTFSC  03.2
0186:  INCF   4E,F
0187:  BTFSC  4A.0
0188:  GOTO   095
0189:  BTFSC  4A.1
018A:  GOTO   0D7
018B:  BTFSC  4A.2
018C:  GOTO   10D
018D:  GOTO   13C
018E:  MOVF   00,W
018F:  ADDWF  4C,F
0190:  BTFSS  03.0
0191:  GOTO   198
0192:  INCF   4D,F
0193:  BTFSS  03.2
0194:  GOTO   198
0195:  INCF   4E,F
0196:  BTFSC  03.2
0197:  BSF    48.0
0198:  DECF   04,F
0199:  MOVF   00,W
019A:  ADDWF  4D,F
019B:  BTFSS  03.0
019C:  GOTO   1A0
019D:  INCF   4E,F
019E:  BTFSC  03.2
019F:  BSF    48.0
01A0:  DECF   04,F
01A1:  MOVF   00,W
01A2:  BTFSS  00.7
01A3:  XORLW  80
01A4:  ADDWF  4E,F
01A5:  BTFSC  03.0
01A6:  BSF    48.0
01A7:  BTFSC  4A.4
01A8:  GOTO   09C
01A9:  BTFSC  4A.5
01AA:  GOTO   0DE
01AB:  GOTO   114
01AC:  BCF    03.5
01AD:  RETURN
*
0243:  BCF    0A.0
0244:  BSF    0A.1
0245:  BCF    0A.2
0246:  ADDWF  02,F
0247:  GOTO   20D
0248:  GOTO   213
0249:  GOTO   222
024A:  GOTO   231
*
02BA:  CLRF   77
02BB:  CLRF   78
02BC:  MOVF   47,W
02BD:  BCF    03.0
02BE:  BTFSC  48.0
02BF:  ADDWF  77,F
02C0:  RRF    77,F
02C1:  RRF    78,F
02C2:  BTFSC  48.1
02C3:  ADDWF  77,F
02C4:  RRF    77,F
02C5:  RRF    78,F
02C6:  BTFSC  48.2
02C7:  ADDWF  77,F
02C8:  RRF    77,F
02C9:  RRF    78,F
02CA:  BTFSC  48.3
02CB:  ADDWF  77,F
02CC:  RRF    77,F
02CD:  RRF    78,F
02CE:  BTFSC  48.4
02CF:  ADDWF  77,F
02D0:  RRF    77,F
02D1:  RRF    78,F
02D2:  BTFSC  48.5
02D3:  ADDWF  77,F
02D4:  RRF    77,F
02D5:  RRF    78,F
02D6:  BTFSC  48.6
02D7:  ADDWF  77,F
02D8:  RRF    77,F
02D9:  RRF    78,F
02DA:  BTFSC  48.7
02DB:  ADDWF  77,F
02DC:  RRF    77,F
02DD:  RRF    78,F
*
0353:  MOVF   78,W
0354:  BTFSC  03.2
0355:  GOTO   35B
0356:  MOVF   77,W
0357:  MOVWF  00
0358:  INCF   04,F
0359:  DECFSZ 78,F
035A:  GOTO   356
*
03C1:  DATA 0C,00
03C2:  DATA 53,2A
03C3:  DATA 4F,28
03C4:  DATA 50,10
03C5:  DATA A1,10
03C6:  DATA 21,00
03C7:  DATA 0C,00
03C8:  DATA 52,22
03C9:  DATA 20,10
03CA:  DATA 20,21
03CB:  DATA 4C,10
03CC:  DATA A0,23
03CD:  DATA 52,10
03CE:  DATA 00,01
03CF:  DATA 20,10
03D0:  DATA 20,10
03D1:  DATA CD,20
03D2:  DATA 43,24
03D3:  DATA 20,22
03D4:  DATA C5,26
03D5:  DATA A0,29
03D6:  DATA 50,00
03D7:  DATA 20,10
03D8:  DATA C3,20
03D9:  DATA 4D,10
03DA:  DATA C2,24
03DB:  DATA 45,27
03DC:  DATA A0,26
03DD:  DATA C1,2A
03DE:  DATA 00,00
*
054A:  MOVF   0B,W
054B:  MOVWF  65
054C:  BCF    0B.7
054D:  BSF    03.5
054E:  BSF    03.6
054F:  BSF    0C.7
0550:  BSF    0C.0
0551:  NOP
0552:  NOP
0553:  BCF    03.5
0554:  BCF    03.6
0555:  BTFSC  65.7
0556:  BSF    0B.7
0557:  BSF    03.6
0558:  MOVF   0C,W
0559:  ANDLW  7F
055A:  BTFSC  03.2
055B:  GOTO   59E
055C:  BCF    03.6
055D:  MOVWF  65
055E:  BSF    03.6
055F:  MOVF   0D,W
0560:  BCF    03.6
0561:  MOVWF  66
0562:  BSF    03.6
0563:  MOVF   0F,W
0564:  BCF    03.6
0565:  MOVWF  67
0566:  MOVF   65,W
0567:  MOVWF  68
0568:  CALL   51E
0569:  MOVF   66,W
056A:  BSF    03.6
056B:  MOVWF  0D
056C:  BCF    03.6
056D:  MOVF   67,W
056E:  BSF    03.6
056F:  MOVWF  0F
0570:  BCF    03.6
0571:  MOVF   0B,W
0572:  MOVWF  68
0573:  BCF    0B.7
0574:  BSF    03.5
0575:  BSF    03.6
0576:  BSF    0C.7
0577:  BSF    0C.0
0578:  NOP
0579:  NOP
057A:  BCF    03.5
057B:  BCF    03.6
057C:  BTFSC  68.7
057D:  BSF    0B.7
057E:  BSF    03.6
057F:  RLF    0C,W
0580:  RLF    0E,W
0581:  ANDLW  7F
0582:  BTFSC  03.2
0583:  GOTO   59E
0584:  BCF    03.6
0585:  MOVWF  65
0586:  BSF    03.6
0587:  MOVF   0D,W
0588:  BCF    03.6
0589:  MOVWF  66
058A:  BSF    03.6
058B:  MOVF   0F,W
058C:  BCF    03.6
058D:  MOVWF  67
058E:  MOVF   65,W
058F:  MOVWF  68
0590:  CALL   51E
0591:  MOVF   66,W
0592:  BSF    03.6
0593:  MOVWF  0D
0594:  BCF    03.6
0595:  MOVF   67,W
0596:  BSF    03.6
0597:  MOVWF  0F
0598:  INCF   0D,F
0599:  BTFSC  03.2
059A:  INCF   0F,F
059B:  BCF    03.6
059C:  GOTO   54A
059D:  BSF    03.6
059E:  BCF    03.6
059F:  RETURN
05A0:  MOVF   6C,W
05A1:  CLRF   78
05A2:  SUBWF  6B,W
05A3:  BTFSC  03.0
05A4:  GOTO   5A8
05A5:  MOVF   6B,W
05A6:  MOVWF  77
05A7:  GOTO   5B4
05A8:  CLRF   77
05A9:  MOVLW  08
05AA:  MOVWF  6D
05AB:  RLF    6B,F
05AC:  RLF    77,F
05AD:  MOVF   6C,W
05AE:  SUBWF  77,W
05AF:  BTFSC  03.0
05B0:  MOVWF  77
05B1:  RLF    78,F
05B2:  DECFSZ 6D,F
05B3:  GOTO   5AB
05B4:  RETURN
05B5:  MOVLW  20
05B6:  BTFSS  66.4
05B7:  MOVLW  30
05B8:  MOVWF  67
05B9:  MOVF   65,W
05BA:  MOVWF  77
05BB:  BTFSS  65.7
05BC:  GOTO   5C5
05BD:  COMF   77,F
05BE:  INCF   77,F
05BF:  MOVF   77,W
05C0:  MOVWF  65
05C1:  MOVLW  2D
05C2:  MOVWF  67
05C3:  BSF    66.7
05C4:  BSF    66.0
05C5:  MOVF   65,W
05C6:  MOVWF  6B
05C7:  MOVLW  64
05C8:  MOVWF  6C
05C9:  CALL   5A0
05CA:  MOVF   77,W
05CB:  MOVWF  65
05CC:  MOVLW  30
05CD:  ADDWF  78,W
05CE:  MOVWF  68
05CF:  MOVF   65,W
05D0:  MOVWF  6B
05D1:  MOVLW  0A
05D2:  MOVWF  6C
05D3:  CALL   5A0
05D4:  MOVLW  30
05D5:  ADDWF  77,W
05D6:  MOVWF  6A
05D7:  MOVLW  30
05D8:  ADDWF  78,W
05D9:  MOVWF  69
05DA:  MOVF   67,W
05DB:  MOVWF  77
05DC:  MOVLW  30
05DD:  SUBWF  68,W
05DE:  BTFSC  03.2
05DF:  GOTO   5E4
05E0:  BSF    66.1
05E1:  BTFSC  66.7
05E2:  BSF    66.2
05E3:  GOTO   5F8
05E4:  MOVF   67,W
05E5:  MOVWF  68
05E6:  MOVLW  20
05E7:  MOVWF  67
05E8:  MOVLW  30
05E9:  SUBWF  69,W
05EA:  BTFSC  03.2
05EB:  GOTO   5F0
05EC:  BSF    66.0
05ED:  BTFSC  66.7
05EE:  BSF    66.1
05EF:  GOTO   5F8
05F0:  BTFSS  03.2
05F1:  BSF    66.0
05F2:  BTFSS  03.2
05F3:  GOTO   5F8
05F4:  MOVF   68,W
05F5:  MOVWF  69
05F6:  MOVLW  20
05F7:  MOVWF  68
05F8:  BTFSC  66.2
05F9:  GOTO   5FF
05FA:  BTFSC  66.1
05FB:  GOTO   603
05FC:  BTFSC  66.0
05FD:  GOTO   607
05FE:  GOTO   60B
05FF:  MOVF   67,W
0600:  BTFSS  0C.4
0601:  GOTO   600
0602:  MOVWF  19
0603:  MOVF   68,W
0604:  BTFSS  0C.4
0605:  GOTO   604
0606:  MOVWF  19
0607:  MOVF   69,W
0608:  BTFSS  0C.4
0609:  GOTO   608
060A:  MOVWF  19
060B:  MOVF   6A,W
060C:  BTFSS  0C.4
060D:  GOTO   60C
060E:  MOVWF  19
060F:  RETURN
0610:  MOVF   66,W
0611:  MOVWF  6D
0612:  MOVF   6A,W
0613:  XORWF  6D,F
0614:  BTFSS  6D.7
0615:  GOTO   61B
0616:  BCF    03.2
0617:  BCF    03.0
0618:  BTFSC  66.7
0619:  BSF    03.0
061A:  GOTO   64E
061B:  MOVF   66,W
061C:  MOVWF  6D
061D:  MOVF   69,W
061E:  MOVWF  6E
061F:  MOVF   65,W
0620:  SUBWF  6E,F
0621:  BTFSC  03.2
0622:  GOTO   629
0623:  BTFSS  6D.7
0624:  GOTO   64E
0625:  MOVF   03,W
0626:  XORLW  01
0627:  MOVWF  03
0628:  GOTO   64E
0629:  MOVF   6A,W
062A:  MOVWF  6E
062B:  MOVF   66,W
062C:  SUBWF  6E,F
062D:  BTFSC  03.2
062E:  GOTO   635
062F:  BTFSS  6D.7
0630:  GOTO   64E
0631:  MOVF   03,W
0632:  XORLW  01
0633:  MOVWF  03
0634:  GOTO   64E
0635:  MOVF   6B,W
0636:  MOVWF  6E
0637:  MOVF   67,W
0638:  SUBWF  6E,F
0639:  BTFSC  03.2
063A:  GOTO   641
063B:  BTFSS  6D.7
063C:  GOTO   64E
063D:  MOVF   03,W
063E:  XORLW  01
063F:  MOVWF  03
0640:  GOTO   64E
0641:  MOVF   6C,W
0642:  MOVWF  6E
0643:  MOVF   68,W
0644:  SUBWF  6E,F
0645:  BTFSC  03.2
0646:  GOTO   64D
0647:  BTFSS  6D.7
0648:  GOTO   64E
0649:  MOVF   03,W
064A:  XORLW  01
064B:  MOVWF  03
064C:  GOTO   64E
064D:  BCF    03.0
064E:  RETURN
*
0804:  MOVLW  8E
0805:  MOVWF  77
0806:  MOVF   6B,W
0807:  MOVWF  78
0808:  MOVF   6A,W
0809:  MOVWF  79
080A:  CLRF   7A
080B:  MOVF   78,F
080C:  BTFSS  03.2
080D:  GOTO   018
080E:  MOVF   79,W
080F:  MOVWF  78
0810:  CLRF   79
0811:  MOVLW  08
0812:  SUBWF  77,F
0813:  MOVF   78,F
0814:  BTFSS  03.2
0815:  GOTO   018
0816:  CLRF   77
0817:  GOTO   020
0818:  BCF    03.0
0819:  BTFSC  78.7
081A:  GOTO   01F
081B:  RLF    79,F
081C:  RLF    78,F
081D:  DECF   77,F
081E:  GOTO   018
081F:  BCF    78.7
*
089C:  MOVF   30,W
089D:  BTFSC  03.2
089E:  GOTO   161
089F:  MOVWF  3C
08A0:  MOVF   34,W
08A1:  BTFSC  03.2
08A2:  GOTO   161
08A3:  SUBWF  3C,F
08A4:  BTFSS  03.0
08A5:  GOTO   0AB
08A6:  MOVLW  7F
08A7:  ADDWF  3C,F
08A8:  BTFSC  03.0
08A9:  GOTO   161
08AA:  GOTO   0B1
08AB:  MOVLW  81
08AC:  SUBWF  3C,F
08AD:  BTFSS  03.0
08AE:  GOTO   161
08AF:  BTFSC  03.2
08B0:  GOTO   161
08B1:  MOVF   3C,W
08B2:  MOVWF  77
08B3:  CLRF   78
08B4:  CLRF   79
08B5:  CLRF   7A
08B6:  CLRF   3B
08B7:  MOVF   31,W
08B8:  MOVWF  3A
08B9:  BSF    3A.7
08BA:  MOVF   32,W
08BB:  MOVWF  39
08BC:  MOVF   33,W
08BD:  MOVWF  38
08BE:  MOVLW  19
08BF:  MOVWF  3C
08C0:  MOVF   37,W
08C1:  SUBWF  38,F
08C2:  BTFSC  03.0
08C3:  GOTO   0D4
08C4:  MOVLW  01
08C5:  SUBWF  39,F
08C6:  BTFSC  03.0
08C7:  GOTO   0D4
08C8:  SUBWF  3A,F
08C9:  BTFSC  03.0
08CA:  GOTO   0D4
08CB:  SUBWF  3B,F
08CC:  BTFSC  03.0
08CD:  GOTO   0D4
08CE:  INCF   3B,F
08CF:  INCF   3A,F
08D0:  INCF   39,F
08D1:  MOVF   37,W
08D2:  ADDWF  38,F
08D3:  GOTO   106
08D4:  MOVF   36,W
08D5:  SUBWF  39,F
08D6:  BTFSC  03.0
08D7:  GOTO   0EF
08D8:  MOVLW  01
08D9:  SUBWF  3A,F
08DA:  BTFSC  03.0
08DB:  GOTO   0EF
08DC:  SUBWF  3B,F
08DD:  BTFSC  03.0
08DE:  GOTO   0EF
08DF:  INCF   3B,F
08E0:  INCF   3A,F
08E1:  MOVF   36,W
08E2:  ADDWF  39,F
08E3:  MOVF   37,W
08E4:  ADDWF  38,F
08E5:  BTFSS  03.0
08E6:  GOTO   106
08E7:  INCF   39,F
08E8:  BTFSS  03.2
08E9:  GOTO   106
08EA:  INCF   3A,F
08EB:  BTFSS  03.2
08EC:  GOTO   106
08ED:  INCF   3B,F
08EE:  GOTO   106
08EF:  MOVF   35,W
08F0:  IORLW  80
08F1:  SUBWF  3A,F
08F2:  BTFSC  03.0
08F3:  GOTO   105
08F4:  MOVLW  01
08F5:  SUBWF  3B,F
08F6:  BTFSC  03.0
08F7:  GOTO   105
08F8:  INCF   3B,F
08F9:  MOVF   35,W
08FA:  IORLW  80
08FB:  ADDWF  3A,F
08FC:  MOVF   36,W
08FD:  ADDWF  39,F
08FE:  BTFSS  03.0
08FF:  GOTO   0E3
0900:  INCF   3A,F
0901:  BTFSS  03.2
0902:  GOTO   0E3
0903:  INCF   3B,F
0904:  GOTO   0E3
0905:  BSF    7A.0
0906:  DECFSZ 3C,F
0907:  GOTO   109
0908:  GOTO   114
0909:  BCF    03.0
090A:  RLF    38,F
090B:  RLF    39,F
090C:  RLF    3A,F
090D:  RLF    3B,F
090E:  BCF    03.0
090F:  RLF    7A,F
0910:  RLF    79,F
0911:  RLF    78,F
0912:  RLF    3D,F
0913:  GOTO   0C0
0914:  BTFSS  3D.0
0915:  GOTO   11C
0916:  BCF    03.0
0917:  RRF    78,F
0918:  RRF    79,F
0919:  RRF    7A,F
091A:  RRF    3D,F
091B:  GOTO   11F
091C:  DECF   77,F
091D:  BTFSC  03.2
091E:  GOTO   161
091F:  BTFSC  3D.7
0920:  GOTO   148
0921:  BCF    03.0
0922:  RLF    38,F
0923:  RLF    39,F
0924:  RLF    3A,F
0925:  RLF    3B,F
0926:  MOVF   37,W
0927:  SUBWF  38,F
0928:  BTFSC  03.0
0929:  GOTO   134
092A:  MOVLW  01
092B:  SUBWF  39,F
092C:  BTFSC  03.0
092D:  GOTO   134
092E:  SUBWF  3A,F
092F:  BTFSC  03.0
0930:  GOTO   134
0931:  SUBWF  3B,F
0932:  BTFSS  03.0
0933:  GOTO   157
0934:  MOVF   36,W
0935:  SUBWF  39,F
0936:  BTFSC  03.0
0937:  GOTO   13F
0938:  MOVLW  01
0939:  SUBWF  3A,F
093A:  BTFSC  03.0
093B:  GOTO   13F
093C:  SUBWF  3B,F
093D:  BTFSS  03.0
093E:  GOTO   157
093F:  MOVF   35,W
0940:  IORLW  80
0941:  SUBWF  3A,F
0942:  BTFSC  03.0
0943:  GOTO   148
0944:  MOVLW  01
0945:  SUBWF  3B,F
0946:  BTFSS  03.0
0947:  GOTO   157
0948:  INCF   7A,F
0949:  BTFSS  03.2
094A:  GOTO   157
094B:  INCF   79,F
094C:  BTFSS  03.2
094D:  GOTO   157
094E:  INCF   78,F
094F:  BTFSS  03.2
0950:  GOTO   157
0951:  INCF   77,F
0952:  BTFSC  03.2
0953:  GOTO   161
0954:  RRF    78,F
0955:  RRF    79,F
0956:  RRF    7A,F
0957:  MOVF   31,W
0958:  MOVWF  3C
0959:  MOVF   35,W
095A:  XORWF  3C,F
095B:  BTFSS  3C.7
095C:  GOTO   15F
095D:  BSF    78.7
095E:  GOTO   165
095F:  BCF    78.7
0960:  GOTO   165
0961:  CLRF   77
0962:  CLRF   78
0963:  CLRF   79
0964:  CLRF   7A
*
09A7:  MOVF   30,W
09A8:  BTFSC  03.2
09A9:  GOTO   217
09AA:  MOVWF  38
09AB:  MOVF   34,W
09AC:  BTFSC  03.2
09AD:  GOTO   217
09AE:  ADDWF  38,F
09AF:  BTFSC  03.0
09B0:  GOTO   1B8
09B1:  MOVLW  7F
09B2:  SUBWF  38,F
09B3:  BTFSS  03.0
09B4:  GOTO   217
09B5:  BTFSC  03.2
09B6:  GOTO   217
09B7:  GOTO   1BC
09B8:  MOVLW  81
09B9:  ADDWF  38,F
09BA:  BTFSC  03.0
09BB:  GOTO   217
09BC:  MOVF   38,W
09BD:  MOVWF  77
09BE:  CLRF   78
09BF:  CLRF   79
09C0:  CLRF   7A
09C1:  MOVF   31,W
09C2:  MOVWF  3C
09C3:  BSF    3C.7
09C4:  MOVF   32,W
09C5:  MOVWF  3B
09C6:  MOVF   33,W
09C7:  MOVWF  3A
09C8:  MOVLW  18
09C9:  MOVWF  38
09CA:  CLRF   39
09CB:  BTFSS  3A.0
09CC:  GOTO   1E5
09CD:  MOVF   37,W
09CE:  ADDWF  7A,F
09CF:  BTFSS  03.0
09D0:  GOTO   1D7
09D1:  INCF   79,F
09D2:  BTFSS  03.2
09D3:  GOTO   1D7
09D4:  INCF   78,F
09D5:  BTFSC  03.2
09D6:  BSF    39.7
09D7:  MOVF   36,W
09D8:  ADDWF  79,F
09D9:  BTFSS  03.0
09DA:  GOTO   1DE
09DB:  INCF   78,F
09DC:  BTFSC  03.2
09DD:  BSF    39.7
09DE:  MOVF   35,W
09DF:  MOVWF  32
09E0:  BSF    32.7
09E1:  MOVF   32,W
09E2:  ADDWF  78,F
09E3:  BTFSC  03.0
09E4:  BSF    39.7
09E5:  RLF    39,F
09E6:  RRF    78,F
09E7:  RRF    79,F
09E8:  RRF    7A,F
09E9:  RRF    3C,F
09EA:  RRF    3B,F
09EB:  RRF    3A,F
09EC:  BCF    03.0
09ED:  DECFSZ 38,F
09EE:  GOTO   1CA
09EF:  MOVLW  01
09F0:  ADDWF  77,F
09F1:  BTFSC  03.0
09F2:  GOTO   217
09F3:  BTFSC  78.7
09F4:  GOTO   1FC
09F5:  RLF    3C,F
09F6:  RLF    7A,F
09F7:  RLF    79,F
09F8:  RLF    78,F
09F9:  DECF   77,F
09FA:  BTFSC  03.2
09FB:  GOTO   217
09FC:  BTFSS  3C.7
09FD:  GOTO   20D
09FE:  INCF   7A,F
09FF:  BTFSS  03.2
0A00:  GOTO   20D
0A01:  INCF   79,F
0A02:  BTFSS  03.2
0A03:  GOTO   20D
0A04:  INCF   78,F
0A05:  BTFSS  03.2
0A06:  GOTO   20D
0A07:  RRF    78,F
0A08:  RRF    79,F
0A09:  RRF    7A,F
0A0A:  INCF   77,F
0A0B:  BTFSC  03.2
0A0C:  GOTO   217
0A0D:  MOVF   31,W
0A0E:  MOVWF  39
0A0F:  MOVF   35,W
0A10:  XORWF  39,F
0A11:  BTFSS  39.7
0A12:  GOTO   215
0A13:  BSF    78.7
0A14:  GOTO   21B
0A15:  BCF    78.7
0A16:  GOTO   21B
0A17:  CLRF   77
0A18:  CLRF   78
0A19:  CLRF   79
0A1A:  CLRF   7A
*
0A51:  MOVLW  8E
0A52:  MOVWF  77
0A53:  MOVF   2C,W
0A54:  SUBWF  77,F
0A55:  MOVF   2D,W
0A56:  MOVWF  79
0A57:  MOVF   2E,W
0A58:  MOVWF  78
0A59:  BSF    79.7
0A5A:  MOVF   77,F
0A5B:  BTFSC  03.2
0A5C:  GOTO   268
0A5D:  BCF    03.0
0A5E:  MOVF   79,F
0A5F:  BTFSS  03.2
0A60:  GOTO   264
0A61:  MOVF   78,F
0A62:  BTFSC  03.2
0A63:  GOTO   268
0A64:  RRF    79,F
0A65:  RRF    78,F
0A66:  DECFSZ 77,F
0A67:  GOTO   25D
0A68:  BTFSS  2D.7
0A69:  GOTO   26F
0A6A:  COMF   78,F
0A6B:  COMF   79,F
0A6C:  INCF   78,F
0A6D:  BTFSC  03.2
0A6E:  INCF   79,F
*
0A7C:  MOVF   6B,W
0A7D:  XORWF  6D,W
0A7E:  ANDLW  80
0A7F:  MOVWF  6F
0A80:  BTFSS  6B.7
0A81:  GOTO   287
0A82:  COMF   6A,F
0A83:  COMF   6B,F
0A84:  INCF   6A,F
0A85:  BTFSC  03.2
0A86:  INCF   6B,F
0A87:  BTFSS  6D.7
0A88:  GOTO   28E
0A89:  COMF   6C,F
0A8A:  COMF   6D,F
0A8B:  INCF   6C,F
0A8C:  BTFSC  03.2
0A8D:  INCF   6D,F
0A8E:  CLRF   78
0A8F:  CLRF   79
0A90:  CLRF   77
0A91:  CLRF   7A
0A92:  MOVF   6D,W
0A93:  BTFSS  03.2
0A94:  GOTO   298
0A95:  MOVF   6C,W
0A96:  BTFSC  03.2
0A97:  GOTO   2B2
0A98:  MOVLW  10
0A99:  MOVWF  6E
0A9A:  BCF    03.0
0A9B:  RLF    6A,F
0A9C:  RLF    6B,F
0A9D:  RLF    77,F
0A9E:  RLF    7A,F
0A9F:  MOVF   6D,W
0AA0:  SUBWF  7A,W
0AA1:  BTFSS  03.2
0AA2:  GOTO   2A5
0AA3:  MOVF   6C,W
0AA4:  SUBWF  77,W
0AA5:  BTFSS  03.0
0AA6:  GOTO   2AE
0AA7:  MOVF   6C,W
0AA8:  SUBWF  77,F
0AA9:  BTFSS  03.0
0AAA:  DECF   7A,F
0AAB:  MOVF   6D,W
0AAC:  SUBWF  7A,F
0AAD:  BSF    03.0
0AAE:  RLF    78,F
0AAF:  RLF    79,F
0AB0:  DECFSZ 6E,F
0AB1:  GOTO   29A
0AB2:  BTFSS  6F.7
0AB3:  GOTO   2B9
0AB4:  COMF   78,F
0AB5:  COMF   79,F
0AB6:  INCF   78,F
0AB7:  BTFSC  03.2
0AB8:  INCF   79,F
*
0CDC:  BCF    0A.0
0CDD:  BCF    0A.1
0CDE:  BSF    0A.2
0CDF:  ADDWF  02,F
0CE0:  GOTO   3D7
0CE1:  GOTO   3D1
0CE2:  GOTO   3D3
0CE3:  GOTO   3D5
....................  
.................... #list 
....................  
.................... #device ADC=16 
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0B35:  BCF    03.5
0B36:  CLRF   2C
0B37:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
024B:  BSF    03.5
024C:  CLRF   45
....................    sign = 0; 
024D:  CLRF   43
....................    base = 10; 
024E:  MOVLW  0A
024F:  MOVWF  44
....................    result = 0; 
0250:  CLRF   42
....................  
....................    if (!s) 
0251:  MOVF   40,W
0252:  IORWF  41,W
0253:  BTFSS  03.2
0254:  GOTO   258
....................       return 0; 
0255:  MOVLW  00
0256:  MOVWF  78
0257:  GOTO   34B
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0258:  MOVF   45,W
0259:  INCF   45,F
025A:  ADDWF  40,W
025B:  MOVWF  04
025C:  BCF    03.7
025D:  BTFSC  41.0
025E:  BSF    03.7
025F:  MOVF   00,W
0260:  MOVWF  46
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0261:  MOVF   46,W
0262:  SUBLW  2D
0263:  BTFSS  03.2
0264:  GOTO   271
....................    { 
....................       sign = 1;         // Set the sign to negative 
0265:  MOVLW  01
0266:  MOVWF  43
....................       c = s[index++]; 
0267:  MOVF   45,W
0268:  INCF   45,F
0269:  ADDWF  40,W
026A:  MOVWF  04
026B:  BCF    03.7
026C:  BTFSC  41.0
026D:  BSF    03.7
026E:  MOVF   00,W
026F:  MOVWF  46
....................    } 
0270:  GOTO   27E
....................    else if (c == '+') 
0271:  MOVF   46,W
0272:  SUBLW  2B
0273:  BTFSS  03.2
0274:  GOTO   27E
....................    { 
....................       c = s[index++]; 
0275:  MOVF   45,W
0276:  INCF   45,F
0277:  ADDWF  40,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  BTFSC  41.0
027B:  BSF    03.7
027C:  MOVF   00,W
027D:  MOVWF  46
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
027E:  MOVF   46,W
027F:  SUBLW  2F
0280:  BTFSC  03.0
0281:  GOTO   341
0282:  MOVF   46,W
0283:  SUBLW  39
0284:  BTFSS  03.0
0285:  GOTO   341
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0286:  MOVF   46,W
0287:  SUBLW  30
0288:  BTFSS  03.2
0289:  GOTO   2AA
028A:  MOVF   45,W
028B:  ADDWF  40,W
028C:  MOVWF  04
028D:  BCF    03.7
028E:  BTFSC  41.0
028F:  BSF    03.7
0290:  MOVF   00,W
0291:  SUBLW  78
0292:  BTFSC  03.2
0293:  GOTO   29E
0294:  MOVF   45,W
0295:  ADDWF  40,W
0296:  MOVWF  04
0297:  BCF    03.7
0298:  BTFSC  41.0
0299:  BSF    03.7
029A:  MOVF   00,W
029B:  SUBLW  58
029C:  BTFSS  03.2
029D:  GOTO   2AA
....................       { 
....................          base = 16; 
029E:  MOVLW  10
029F:  MOVWF  44
....................          index++; 
02A0:  INCF   45,F
....................          c = s[index++]; 
02A1:  MOVF   45,W
02A2:  INCF   45,F
02A3:  ADDWF  40,W
02A4:  MOVWF  04
02A5:  BCF    03.7
02A6:  BTFSC  41.0
02A7:  BSF    03.7
02A8:  MOVF   00,W
02A9:  MOVWF  46
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02AA:  MOVF   44,W
02AB:  SUBLW  0A
02AC:  BTFSS  03.2
02AD:  GOTO   2EF
....................       { 
....................          while (c >= '0' && c <= '9') 
02AE:  MOVF   46,W
02AF:  SUBLW  2F
02B0:  BTFSC  03.0
02B1:  GOTO   2EE
02B2:  MOVF   46,W
02B3:  SUBLW  39
02B4:  BTFSS  03.0
02B5:  GOTO   2EE
....................          { 
....................             result = 10*result + (c - '0'); 
02B6:  MOVLW  0A
02B7:  MOVWF  47
02B8:  MOVF   42,W
02B9:  MOVWF  48
*
02DE:  MOVF   78,W
02DF:  MOVWF  47
02E0:  MOVLW  30
02E1:  SUBWF  46,W
02E2:  ADDWF  47,W
02E3:  MOVWF  42
....................             c = s[index++]; 
02E4:  MOVF   45,W
02E5:  INCF   45,F
02E6:  ADDWF  40,W
02E7:  MOVWF  04
02E8:  BCF    03.7
02E9:  BTFSC  41.0
02EA:  BSF    03.7
02EB:  MOVF   00,W
02EC:  MOVWF  46
02ED:  GOTO   2AE
....................          } 
....................       } 
02EE:  GOTO   341
....................       else if (base == 16)    // The number is a hexa number 
02EF:  MOVF   44,W
02F0:  SUBLW  10
02F1:  BTFSS  03.2
02F2:  GOTO   341
....................       { 
....................          c = toupper(c); 
02F3:  MOVF   46,W
02F4:  SUBLW  60
02F5:  BTFSC  03.0
02F6:  GOTO   2FE
02F7:  MOVF   46,W
02F8:  SUBLW  7A
02F9:  BTFSS  03.0
02FA:  GOTO   2FE
02FB:  MOVF   46,W
02FC:  ANDLW  DF
02FD:  GOTO   2FF
02FE:  MOVF   46,W
02FF:  MOVWF  46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0300:  MOVF   46,W
0301:  SUBLW  2F
0302:  BTFSC  03.0
0303:  GOTO   308
0304:  MOVF   46,W
0305:  SUBLW  39
0306:  BTFSC  03.0
0307:  GOTO   310
0308:  MOVF   46,W
0309:  SUBLW  40
030A:  BTFSC  03.0
030B:  GOTO   341
030C:  MOVF   46,W
030D:  SUBLW  46
030E:  BTFSS  03.0
030F:  GOTO   341
....................          { 
....................             if (c >= '0' && c <= '9') 
0310:  MOVF   46,W
0311:  SUBLW  2F
0312:  BTFSC  03.0
0313:  GOTO   321
0314:  MOVF   46,W
0315:  SUBLW  39
0316:  BTFSS  03.0
0317:  GOTO   321
....................                result = (result << 4) + (c - '0'); 
0318:  SWAPF  42,W
0319:  MOVWF  47
031A:  MOVLW  F0
031B:  ANDWF  47,F
031C:  MOVLW  30
031D:  SUBWF  46,W
031E:  ADDWF  47,W
031F:  MOVWF  42
0320:  GOTO   32A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0321:  SWAPF  42,W
0322:  MOVWF  47
0323:  MOVLW  F0
0324:  ANDWF  47,F
0325:  MOVLW  41
0326:  SUBWF  46,W
0327:  ADDLW  0A
0328:  ADDWF  47,W
0329:  MOVWF  42
....................  
....................             c = s[index++]; 
032A:  MOVF   45,W
032B:  INCF   45,F
032C:  ADDWF  40,W
032D:  MOVWF  04
032E:  BCF    03.7
032F:  BTFSC  41.0
0330:  BSF    03.7
0331:  MOVF   00,W
0332:  MOVWF  46
....................             c = toupper(c); 
0333:  MOVF   46,W
0334:  SUBLW  60
0335:  BTFSC  03.0
0336:  GOTO   33E
0337:  MOVF   46,W
0338:  SUBLW  7A
0339:  BTFSS  03.0
033A:  GOTO   33E
033B:  MOVF   46,W
033C:  ANDLW  DF
033D:  GOTO   33F
033E:  MOVF   46,W
033F:  MOVWF  46
0340:  GOTO   300
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0341:  DECFSZ 43,W
0342:  GOTO   349
0343:  MOVF   44,W
0344:  SUBLW  0A
0345:  BTFSS  03.2
0346:  GOTO   349
....................        result = -result; 
0347:  COMF   42,F
0348:  INCF   42,F
....................  
....................    return(result); 
0349:  MOVF   42,W
034A:  MOVWF  78
034B:  BCF    03.5
034C:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE<string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS 
....................  
.................... #use delay(crystal=20000000) 
*
03DF:  MOVLW  6A
03E0:  MOVWF  04
03E1:  BCF    03.7
03E2:  MOVF   00,W
03E3:  BTFSC  03.2
03E4:  GOTO   3F2
03E5:  MOVLW  06
03E6:  MOVWF  78
03E7:  CLRF   77
03E8:  DECFSZ 77,F
03E9:  GOTO   3E8
03EA:  DECFSZ 78,F
03EB:  GOTO   3E7
03EC:  MOVLW  7B
03ED:  MOVWF  77
03EE:  DECFSZ 77,F
03EF:  GOTO   3EE
03F0:  DECFSZ 00,F
03F1:  GOTO   3E5
03F2:  RETURN
.................... #use FIXED_IO( A_outputs=PIN_A3,PIN_A2,PIN_A1,PIN_A0,PIN_A4 ) 
.................... #use rs232(stream=com1,baud=9600,xmit=PIN_C6,rcv=PIN_c7)) 
....................  
.................... #define S_0   PIN_A0 
.................... #define S_1   PIN_A1 
.................... #define S_2   PIN_A2 
.................... #define S_3   PIN_A3 
.................... #define READ   PIN_B0 
....................  
....................  
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_D6 
.................... #define LCD_RS_PIN PIN_D7 
.................... #define LCD_RW_PIN PIN_C4 
.................... #define LCD_DATA4 PIN_D5 
.................... #define LCD_DATA5 PIN_D4 
.................... #define LCD_DATA6 PIN_D3 
.................... #define LCD_DATA7 PIN_D2 
....................  
.................... #define UNIDENTIFIED    0 
.................... #define COLOR_RED       1 
.................... #define COLOR_BLUE      2 
.................... #define COLOR_GREEN     3 
.................... #define COLOR_COUNT_MAX     4 
.................... #define LOW_   1 
.................... #define MEDIUM    2 
.................... #define HIGH_   3 
.................... #define ON_    1 
.................... #define OFF_   0 
.................... #include<lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0466:  BSF    08.5
....................    output_float(LCD_DATA5); 
0467:  BSF    08.4
....................    output_float(LCD_DATA6); 
0468:  BSF    08.3
....................    output_float(LCD_DATA7); 
0469:  BSF    08.2
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
046A:  BCF    03.5
046B:  BSF    07.4
046C:  BCF    32.4
046D:  MOVF   32,W
046E:  BSF    03.5
046F:  MOVWF  07
....................    delay_cycles(1); 
0470:  NOP
....................    lcd_output_enable(1); 
0471:  BCF    03.5
0472:  BSF    08.6
0473:  BSF    03.5
0474:  BCF    08.6
....................    delay_cycles(1); 
0475:  NOP
....................    high = lcd_read_nibble(); 
0476:  BCF    03.5
0477:  CALL   429
0478:  MOVF   78,W
0479:  MOVWF  70
....................        
....................    lcd_output_enable(0); 
047A:  BCF    08.6
047B:  BSF    03.5
047C:  BCF    08.6
....................    delay_cycles(1); 
047D:  NOP
....................    lcd_output_enable(1); 
047E:  BCF    03.5
047F:  BSF    08.6
0480:  BSF    03.5
0481:  BCF    08.6
....................    delay_us(1); 
0482:  GOTO   483
0483:  GOTO   484
0484:  NOP
....................    low = lcd_read_nibble(); 
0485:  BCF    03.5
0486:  CALL   429
0487:  MOVF   78,W
0488:  MOVWF  6F
....................        
....................    lcd_output_enable(0); 
0489:  BCF    08.6
048A:  BSF    03.5
048B:  BCF    08.6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
048C:  BCF    08.5
....................    output_drive(LCD_DATA5); 
048D:  BCF    08.4
....................    output_drive(LCD_DATA6); 
048E:  BCF    08.3
....................    output_drive(LCD_DATA7); 
048F:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0490:  SWAPF  70,W
0491:  MOVWF  77
0492:  MOVLW  F0
0493:  ANDWF  77,F
0494:  MOVF   77,W
0495:  BCF    03.5
0496:  IORWF  6F,W
0497:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0429:  CLRF   71
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
042A:  BSF    03.5
042B:  BSF    08.5
042C:  MOVLW  00
042D:  BCF    03.5
042E:  BTFSC  08.5
042F:  MOVLW  01
0430:  IORWF  71,F
....................    n |= input(LCD_DATA5) << 1; 
0431:  BSF    03.5
0432:  BSF    08.4
0433:  MOVLW  00
0434:  BCF    03.5
0435:  BTFSC  08.4
0436:  MOVLW  01
0437:  MOVWF  77
0438:  BCF    03.0
0439:  RLF    77,F
043A:  MOVF   77,W
043B:  IORWF  71,F
....................    n |= input(LCD_DATA6) << 2; 
043C:  BSF    03.5
043D:  BSF    08.3
043E:  MOVLW  00
043F:  BCF    03.5
0440:  BTFSC  08.3
0441:  MOVLW  01
0442:  MOVWF  77
0443:  RLF    77,F
0444:  RLF    77,F
0445:  MOVLW  FC
0446:  ANDWF  77,F
0447:  MOVF   77,W
0448:  IORWF  71,F
....................    n |= input(LCD_DATA7) << 3; 
0449:  BSF    03.5
044A:  BSF    08.2
044B:  MOVLW  00
044C:  BCF    03.5
044D:  BTFSC  08.2
044E:  MOVLW  01
044F:  MOVWF  77
0450:  RLF    77,F
0451:  RLF    77,F
0452:  RLF    77,F
0453:  MOVLW  F8
0454:  ANDWF  77,F
0455:  MOVF   77,W
0456:  IORWF  71,F
....................     
....................    return(n); 
0457:  MOVF   71,W
0458:  MOVWF  78
....................   #else 
0459:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
03F3:  BTFSC  70.0
03F4:  GOTO   3F7
03F5:  BCF    08.5
03F6:  GOTO   3F8
03F7:  BSF    08.5
03F8:  BSF    03.5
03F9:  BCF    08.5
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
03FA:  BTFSC  70.1
03FB:  GOTO   400
03FC:  BCF    03.5
03FD:  BCF    08.4
03FE:  GOTO   402
03FF:  BSF    03.5
0400:  BCF    03.5
0401:  BSF    08.4
0402:  BSF    03.5
0403:  BCF    08.4
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0404:  BTFSC  70.2
0405:  GOTO   40A
0406:  BCF    03.5
0407:  BCF    08.3
0408:  GOTO   40C
0409:  BSF    03.5
040A:  BCF    03.5
040B:  BSF    08.3
040C:  BSF    03.5
040D:  BCF    08.3
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
040E:  BTFSC  70.3
040F:  GOTO   414
0410:  BCF    03.5
0411:  BCF    08.2
0412:  GOTO   416
0413:  BSF    03.5
0414:  BCF    03.5
0415:  BSF    08.2
0416:  BSF    03.5
0417:  BCF    08.2
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0418:  NOP
....................    lcd_output_enable(1); 
0419:  BCF    03.5
041A:  BSF    08.6
041B:  BSF    03.5
041C:  BCF    08.6
....................    delay_us(2); 
041D:  MOVLW  02
041E:  MOVWF  77
041F:  DECFSZ 77,F
0420:  GOTO   41F
0421:  GOTO   422
0422:  NOP
....................    lcd_output_enable(0); 
0423:  BCF    03.5
0424:  BCF    08.6
0425:  BSF    03.5
0426:  BCF    08.6
0427:  BCF    03.5
0428:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
045A:  BSF    03.5
045B:  BCF    08.6
....................    lcd_rs_tris(); 
045C:  BCF    08.7
....................    lcd_rw_tris(); 
045D:  BCF    03.5
045E:  BCF    32.4
045F:  MOVF   32,W
0460:  BSF    03.5
0461:  MOVWF  07
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0462:  BCF    03.5
0463:  BCF    08.7
0464:  BSF    03.5
0465:  BCF    08.7
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0498:  MOVF   78,W
0499:  MOVWF  6F
049A:  BTFSS  6F.7
049B:  GOTO   49E
049C:  BSF    03.5
049D:  GOTO   466
....................    lcd_output_rs(address); 
049E:  MOVF   6D,F
049F:  BTFSS  03.2
04A0:  GOTO   4A3
04A1:  BCF    08.7
04A2:  GOTO   4A4
04A3:  BSF    08.7
04A4:  BSF    03.5
04A5:  BCF    08.7
....................    delay_cycles(1); 
04A6:  NOP
....................    lcd_output_rw(0); 
04A7:  BCF    03.5
04A8:  BCF    07.4
04A9:  BCF    32.4
04AA:  MOVF   32,W
04AB:  BSF    03.5
04AC:  MOVWF  07
....................    delay_cycles(1); 
04AD:  NOP
....................    lcd_output_enable(0); 
04AE:  BCF    03.5
04AF:  BCF    08.6
04B0:  BSF    03.5
04B1:  BCF    08.6
....................    lcd_send_nibble(n >> 4); 
04B2:  BCF    03.5
04B3:  SWAPF  6E,W
04B4:  MOVWF  6F
04B5:  MOVLW  0F
04B6:  ANDWF  6F,F
04B7:  MOVF   6F,W
04B8:  MOVWF  70
04B9:  CALL   3F3
....................    lcd_send_nibble(n & 0xf); 
04BA:  MOVF   6E,W
04BB:  ANDLW  0F
04BC:  MOVWF  6F
04BD:  MOVWF  70
04BE:  CALL   3F3
04BF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
04C0:  MOVLW  28
04C1:  MOVWF  66
04C2:  MOVLW  0C
04C3:  MOVWF  67
04C4:  MOVLW  01
04C5:  MOVWF  68
04C6:  MOVLW  06
04C7:  MOVWF  69
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
04C8:  BCF    08.6
04C9:  BSF    03.5
04CA:  BCF    08.6
....................    lcd_output_rs(0); 
04CB:  BCF    03.5
04CC:  BCF    08.7
04CD:  BSF    03.5
04CE:  BCF    08.7
....................    lcd_output_rw(0); 
04CF:  BCF    03.5
04D0:  BCF    07.4
04D1:  BCF    32.4
04D2:  MOVF   32,W
04D3:  BSF    03.5
04D4:  MOVWF  07
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
04D5:  BCF    08.5
....................    output_drive(LCD_DATA5); 
04D6:  BCF    08.4
....................    output_drive(LCD_DATA6); 
04D7:  BCF    08.3
....................    output_drive(LCD_DATA7); 
04D8:  BCF    08.2
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
04D9:  BCF    08.6
....................    lcd_rs_tris(); 
04DA:  BCF    08.7
....................    lcd_rw_tris(); 
04DB:  BCF    03.5
04DC:  BCF    32.4
04DD:  MOVF   32,W
04DE:  BSF    03.5
04DF:  MOVWF  07
....................  #endif 
....................      
....................    delay_ms(15); 
04E0:  MOVLW  0F
04E1:  BCF    03.5
04E2:  MOVWF  6A
04E3:  CALL   3DF
....................    for(i=1;i<=3;++i) 
04E4:  MOVLW  01
04E5:  MOVWF  65
04E6:  MOVF   65,W
04E7:  SUBLW  03
04E8:  BTFSS  03.0
04E9:  GOTO   4F2
....................    { 
....................        lcd_send_nibble(3); 
04EA:  MOVLW  03
04EB:  MOVWF  70
04EC:  CALL   3F3
....................        delay_ms(5); 
04ED:  MOVLW  05
04EE:  MOVWF  6A
04EF:  CALL   3DF
04F0:  INCF   65,F
04F1:  GOTO   4E6
....................    } 
....................     
....................    lcd_send_nibble(2); 
04F2:  MOVLW  02
04F3:  MOVWF  70
04F4:  CALL   3F3
....................    delay_ms(5); 
04F5:  MOVLW  05
04F6:  MOVWF  6A
04F7:  CALL   3DF
....................    for(i=0;i<=3;++i) 
04F8:  CLRF   65
04F9:  MOVF   65,W
04FA:  SUBLW  03
04FB:  BTFSS  03.0
04FC:  GOTO   509
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
04FD:  MOVLW  66
04FE:  ADDWF  65,W
04FF:  MOVWF  04
0500:  BCF    03.7
0501:  MOVF   00,W
0502:  MOVWF  6A
0503:  CLRF   6D
0504:  MOVF   6A,W
0505:  MOVWF  6E
0506:  CALL   45A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0507:  INCF   65,F
0508:  GOTO   4F9
0509:  BSF    0A.3
050A:  BCF    0A.4
050B:  GOTO   34D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
050C:  DECFSZ 6A,W
050D:  GOTO   50F
050E:  GOTO   512
....................       address=LCD_LINE_TWO; 
050F:  MOVLW  40
0510:  MOVWF  6B
0511:  GOTO   513
....................    else 
....................       address=0; 
0512:  CLRF   6B
....................       
....................    address+=x-1; 
0513:  MOVLW  01
0514:  SUBWF  69,W
0515:  ADDWF  6B,F
....................    lcd_send_byte(0,0x80|address); 
0516:  MOVF   6B,W
0517:  IORLW  80
0518:  MOVWF  6C
0519:  CLRF   6D
051A:  MOVF   6C,W
051B:  MOVWF  6E
051C:  CALL   45A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
051D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
051E:  MOVF   68,W
051F:  XORLW  07
0520:  BTFSC  03.2
0521:  GOTO   52C
0522:  XORLW  0B
0523:  BTFSC  03.2
0524:  GOTO   531
0525:  XORLW  06
0526:  BTFSC  03.2
0527:  GOTO   539
0528:  XORLW  02
0529:  BTFSC  03.2
052A:  GOTO   53F
052B:  GOTO   544
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
052C:  MOVLW  01
052D:  MOVWF  69
052E:  MOVWF  6A
052F:  CALL   50C
0530:  GOTO   549
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0531:  CLRF   6D
0532:  MOVLW  01
0533:  MOVWF  6E
0534:  CALL   45A
....................                      delay_ms(2); 
0535:  MOVLW  02
0536:  MOVWF  6A
0537:  CALL   3DF
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0538:  GOTO   549
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0539:  MOVLW  01
053A:  MOVWF  69
053B:  MOVLW  02
053C:  MOVWF  6A
053D:  CALL   50C
053E:  GOTO   549
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
053F:  CLRF   6D
0540:  MOVLW  10
0541:  MOVWF  6E
0542:  CALL   45A
0543:  GOTO   549
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0544:  MOVLW  01
0545:  MOVWF  6D
0546:  MOVF   68,W
0547:  MOVWF  6E
0548:  CALL   45A
....................      #endif 
....................    } 
0549:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... unsigned char has_product = 0, count_enable = 0, isFromButtonPressed = 0,done=0,cycle,data_received[5],c,has_red,has_blue,has_green; 
.................... int color_count = 0, red_count = 0, blue_count = 0, green_count = 0, blind_count = 0; 
.................... unsigned int red_product = 0, blue_product = 0, green_product = 0,sum;  
.................... int color_flag,on_off,speed_mode,freq_mode,sp_stop,time_stop,is_running; 
.................... static  float  count, red_freq, blue_freq, green_freq; 
*
0B38:  CLRF   51
0B39:  CLRF   52
0B3A:  CLRF   53
0B3B:  CLRF   54
0B3C:  CLRF   55
0B3D:  CLRF   56
0B3E:  CLRF   57
0B3F:  CLRF   58
0B40:  CLRF   59
0B41:  CLRF   5A
0B42:  CLRF   5B
0B43:  CLRF   5C
0B44:  CLRF   5D
0B45:  CLRF   5E
0B46:  CLRF   5F
0B47:  CLRF   60
.................... int16 Ton, ChuKy=10000; 
.................... float Map(float x, float in_min, float in_max, float out_min, float out_max) 
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
....................    tam =  tam + out_min; 
....................    return tam; 
.................... } 
....................  
.................... void Hien_thi(int16 value) 
.................... { 
....................    lcd_putc(value/10000 + 0x30) ; // chuc nghin 
....................    lcd_putc(value%10000/1000 + 0x30) ;  // nghin 
....................    lcd_putc(value%10000%1000/100 + 0x30) ; // tram 
....................    lcd_putc(value%10000%1000%100/10 + 0x30) ; // chuc 
....................    lcd_putc(value%10 + 0x30) ; // don vi 
....................     
.................... } 
.................... void TCS_mode(int8 s2, int8 s3) 
.................... { 
....................    count=0; 
*
01DA:  CLRF   54
01DB:  CLRF   53
01DC:  CLRF   52
01DD:  CLRF   51
....................    color_flag++; 
01DE:  INCF   4A,F
....................    OUTPUT_BIT(S_2,s2); 
01DF:  BSF    03.5
01E0:  MOVF   40,F
01E1:  BTFSS  03.2
01E2:  GOTO   1E7
01E3:  BCF    03.5
01E4:  BCF    05.2
01E5:  GOTO   1E9
01E6:  BSF    03.5
01E7:  BCF    03.5
01E8:  BSF    05.2
01E9:  MOVLW  E0
01EA:  BSF    03.5
01EB:  MOVWF  05
....................    OUTPUT_BIT(S_3,s3); 
01EC:  MOVF   41,F
01ED:  BTFSS  03.2
01EE:  GOTO   1F3
01EF:  BCF    03.5
01F0:  BCF    05.3
01F1:  GOTO   1F5
01F2:  BSF    03.5
01F3:  BCF    03.5
01F4:  BSF    05.3
01F5:  MOVLW  E0
01F6:  BSF    03.5
01F7:  MOVWF  05
....................    set_timer1(3036); 
01F8:  BCF    03.5
01F9:  CLRF   0E
01FA:  MOVLW  0B
01FB:  MOVWF  0F
01FC:  MOVLW  DC
01FD:  MOVWF  0E
....................    if(color_flag==4) 
01FE:  MOVF   4A,W
01FF:  SUBLW  04
0200:  BTFSS  03.2
0201:  GOTO   206
....................       { 
....................        color_flag=0; 
0202:  CLRF   4A
....................        setup_timer_1(T1_DISABLED); 
0203:  CLRF   10
....................        done=1; 
0204:  MOVLW  01
0205:  MOVWF  36
....................       } 
0206:  RETURN
.................... } 
.................... void get_data() 
*
035B:  BSF    03.5
035C:  CLRF   40
.................... { 
.................... int i=0; 
.................... c=fgetc(com1); 
035D:  BCF    03.5
035E:  BTFSS  0C.5
035F:  GOTO   35E
0360:  MOVF   1A,W
0361:  MOVWF  3D
.................... if(c=='<') 
0362:  MOVF   3D,W
0363:  SUBLW  3C
0364:  BTFSS  03.2
0365:  GOTO   37F
....................    { do{ c=fgetc(com1); 
0366:  BTFSS  0C.5
0367:  GOTO   366
0368:  MOVF   1A,W
0369:  MOVWF  3D
....................          if(c!='-'&& c!='>') data_received[i++]=c; 
036A:  MOVF   3D,W
036B:  SUBLW  2D
036C:  BTFSC  03.2
036D:  GOTO   37B
036E:  MOVF   3D,W
036F:  SUBLW  3E
0370:  BTFSC  03.2
0371:  GOTO   37B
0372:  BSF    03.5
0373:  MOVF   40,W
0374:  INCF   40,F
0375:  ADDLW  38
0376:  MOVWF  04
0377:  BCF    03.7
0378:  BCF    03.5
0379:  MOVF   3D,W
037A:  MOVWF  00
....................        } 
....................        while(c!='>'); 
037B:  MOVF   3D,W
037C:  SUBLW  3E
037D:  BTFSS  03.2
037E:  GOTO   366
....................    } 
....................     
.................... } 
....................  
.................... void Delay4us(int16 t) 
.................... { 
....................    while(t>0) t--; 
*
0770:  MOVF   6C,F
0771:  BTFSS  03.2
0772:  GOTO   776
0773:  MOVF   6D,F
0774:  BTFSC  03.2
0775:  GOTO   77B
0776:  MOVF   6C,W
0777:  BTFSC  03.2
0778:  DECF   6D,F
0779:  DECF   6C,F
077A:  GOTO   770
077B:  RETURN
.................... } 
....................  
.................... long Convert(float x, float in_min, float in_max, float out_min, float out_max) 
*
0848:  BSF    03.1
0849:  BCF    03.5
084A:  CLRF   2B
084B:  BTFSC  0B.7
084C:  BSF    2B.7
084D:  BCF    0B.7
084E:  BSF    03.5
084F:  MOVF   27,W
0850:  MOVWF  43
0851:  MOVF   26,W
0852:  MOVWF  42
0853:  MOVF   25,W
0854:  MOVWF  41
0855:  MOVF   24,W
0856:  MOVWF  40
0857:  MOVF   23,W
0858:  MOVWF  47
0859:  MOVF   22,W
085A:  MOVWF  46
085B:  MOVF   21,W
085C:  MOVWF  45
085D:  MOVF   20,W
085E:  MOVWF  44
085F:  BCF    0A.3
0860:  BCF    03.5
0861:  CALL   068
0862:  BSF    0A.3
0863:  BTFSC  2B.7
0864:  BSF    0B.7
0865:  MOVF   7A,W
0866:  BSF    03.5
0867:  MOVWF  2F
0868:  MOVF   79,W
0869:  MOVWF  2E
086A:  MOVF   78,W
086B:  MOVWF  2D
086C:  MOVF   77,W
086D:  MOVWF  2C
086E:  BSF    03.1
086F:  BCF    03.5
0870:  CLRF   2B
0871:  BTFSC  0B.7
0872:  BSF    2B.7
0873:  BCF    0B.7
0874:  MOVF   7E,W
0875:  BSF    03.5
0876:  MOVWF  43
0877:  MOVF   7D,W
0878:  MOVWF  42
0879:  MOVF   7C,W
087A:  MOVWF  41
087B:  MOVF   7B,W
087C:  MOVWF  40
087D:  MOVF   75,W
087E:  MOVWF  47
087F:  MOVF   74,W
0880:  MOVWF  46
0881:  MOVF   73,W
0882:  MOVWF  45
0883:  MOVF   72,W
0884:  MOVWF  44
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   068
0888:  BSF    0A.3
0889:  BTFSC  2B.7
088A:  BSF    0B.7
088B:  BSF    03.5
088C:  MOVF   2F,W
088D:  MOVWF  33
088E:  MOVF   2E,W
088F:  MOVWF  32
0890:  MOVF   2D,W
0891:  MOVWF  31
0892:  MOVF   2C,W
0893:  MOVWF  30
0894:  MOVF   7A,W
0895:  MOVWF  37
0896:  MOVF   79,W
0897:  MOVWF  36
0898:  MOVF   78,W
0899:  MOVWF  35
089A:  MOVF   77,W
089B:  MOVWF  34
*
0965:  MOVF   7A,W
0966:  MOVWF  2B
0967:  MOVF   79,W
0968:  MOVWF  2A
0969:  MOVF   78,W
096A:  MOVWF  29
096B:  MOVF   77,W
096C:  MOVWF  28
.................... { 
....................    float tam = (out_max - out_min)/(in_max - in_min); 
....................    tam = (x - in_min) * tam; 
096D:  BSF    03.1
096E:  BCF    03.5
096F:  CLRF   2B
0970:  BTFSC  0B.7
0971:  BSF    2B.7
0972:  BCF    0B.7
0973:  MOVF   71,W
0974:  BSF    03.5
0975:  MOVWF  43
0976:  MOVF   70,W
0977:  MOVWF  42
0978:  BCF    03.5
0979:  MOVF   6F,W
097A:  BSF    03.5
097B:  MOVWF  41
097C:  BCF    03.5
097D:  MOVF   6E,W
097E:  BSF    03.5
097F:  MOVWF  40
0980:  MOVF   75,W
0981:  MOVWF  47
0982:  MOVF   74,W
0983:  MOVWF  46
0984:  MOVF   73,W
0985:  MOVWF  45
0986:  MOVF   72,W
0987:  MOVWF  44
0988:  BCF    0A.3
0989:  BCF    03.5
098A:  CALL   068
098B:  BSF    0A.3
098C:  BTFSC  2B.7
098D:  BSF    0B.7
098E:  MOVF   7A,W
098F:  BSF    03.5
0990:  MOVWF  2F
0991:  MOVF   79,W
0992:  MOVWF  2E
0993:  MOVF   78,W
0994:  MOVWF  2D
0995:  MOVF   77,W
0996:  MOVWF  2C
0997:  MOVF   2F,W
0998:  MOVWF  33
0999:  MOVF   2E,W
099A:  MOVWF  32
099B:  MOVF   2D,W
099C:  MOVWF  31
099D:  MOVF   2C,W
099E:  MOVWF  30
099F:  MOVF   2B,W
09A0:  MOVWF  37
09A1:  MOVF   2A,W
09A2:  MOVWF  36
09A3:  MOVF   29,W
09A4:  MOVWF  35
09A5:  MOVF   28,W
09A6:  MOVWF  34
*
0A1B:  MOVF   7A,W
0A1C:  MOVWF  2B
0A1D:  MOVF   79,W
0A1E:  MOVWF  2A
0A1F:  MOVF   78,W
0A20:  MOVWF  29
0A21:  MOVF   77,W
0A22:  MOVWF  28
....................    tam = tam + out_min; 
0A23:  BCF    03.1
0A24:  BCF    03.5
0A25:  CLRF   2B
0A26:  BTFSC  0B.7
0A27:  BSF    2B.7
0A28:  BCF    0B.7
0A29:  BSF    03.5
0A2A:  MOVF   2B,W
0A2B:  MOVWF  43
0A2C:  MOVF   2A,W
0A2D:  MOVWF  42
0A2E:  MOVF   29,W
0A2F:  MOVWF  41
0A30:  MOVF   28,W
0A31:  MOVWF  40
0A32:  MOVF   23,W
0A33:  MOVWF  47
0A34:  MOVF   22,W
0A35:  MOVWF  46
0A36:  MOVF   21,W
0A37:  MOVWF  45
0A38:  MOVF   20,W
0A39:  MOVWF  44
0A3A:  BCF    0A.3
0A3B:  BCF    03.5
0A3C:  CALL   068
0A3D:  BSF    0A.3
0A3E:  BTFSC  2B.7
0A3F:  BSF    0B.7
0A40:  MOVF   7A,W
0A41:  BSF    03.5
0A42:  MOVWF  2B
0A43:  MOVF   79,W
0A44:  MOVWF  2A
0A45:  MOVF   78,W
0A46:  MOVWF  29
0A47:  MOVF   77,W
0A48:  MOVWF  28
....................    return tam; 
0A49:  MOVF   2B,W
0A4A:  MOVWF  2F
0A4B:  MOVF   2A,W
0A4C:  MOVWF  2E
0A4D:  MOVF   29,W
0A4E:  MOVWF  2D
0A4F:  MOVF   28,W
0A50:  MOVWF  2C
*
0A6F:  MOVF   79,W
.................... } 
....................  
.................... void Write(long Goc, signed long t,int servo) 
.................... { 
....................    Ton = Convert(Goc,0,180, 247,1250); 
*
0800:  MOVF   66,W
0801:  MOVWF  6B
0802:  MOVF   65,W
0803:  MOVWF  6A
*
0820:  MOVF   7A,W
0821:  MOVWF  6D
0822:  MOVF   79,W
0823:  MOVWF  6C
0824:  MOVF   78,W
0825:  MOVWF  6B
0826:  MOVF   77,W
0827:  MOVWF  6A
0828:  MOVF   6D,W
0829:  MOVWF  71
082A:  MOVF   6C,W
082B:  MOVWF  70
082C:  MOVF   6B,W
082D:  MOVWF  6F
082E:  MOVF   6A,W
082F:  MOVWF  6E
0830:  CLRF   75
0831:  CLRF   74
0832:  CLRF   73
0833:  CLRF   72
0834:  CLRF   7E
0835:  CLRF   7D
0836:  MOVLW  34
0837:  MOVWF  7C
0838:  MOVLW  86
0839:  MOVWF  7B
083A:  BSF    03.5
083B:  CLRF   23
083C:  CLRF   22
083D:  MOVLW  77
083E:  MOVWF  21
083F:  MOVLW  86
0840:  MOVWF  20
0841:  CLRF   27
0842:  MOVLW  40
0843:  MOVWF  26
0844:  MOVLW  1C
0845:  MOVWF  25
0846:  MOVLW  89
0847:  MOVWF  24
*
0A70:  MOVF   79,W
0A71:  BCF    03.5
0A72:  MOVWF  62
0A73:  MOVF   78,W
0A74:  MOVWF  61
....................    t=t/20; 
0A75:  MOVF   68,W
0A76:  MOVWF  6B
0A77:  MOVF   67,W
0A78:  MOVWF  6A
0A79:  CLRF   6D
0A7A:  MOVLW  14
0A7B:  MOVWF  6C
*
0AB9:  MOVF   79,W
0ABA:  MOVWF  68
0ABB:  MOVF   78,W
0ABC:  MOVWF  67
....................    for(;t>0;t--) 
0ABD:  BTFSC  68.7
0ABE:  GOTO   30F
0ABF:  MOVF   68,F
0AC0:  BTFSS  03.2
0AC1:  GOTO   2C6
0AC2:  MOVF   67,W
0AC3:  SUBLW  00
0AC4:  BTFSC  03.0
0AC5:  GOTO   30F
....................    { 
....................       // phat xung trong 20ms 
....................     if(servo==1) 
0AC6:  DECFSZ 69,W
0AC7:  GOTO   2E7
....................     { 
....................       output_bit(PIN_D1,1); 
0AC8:  BSF    08.1
0AC9:  BSF    03.5
0ACA:  BCF    08.1
....................       Delay4us(Ton); 
0ACB:  BCF    03.5
0ACC:  MOVF   62,W
0ACD:  MOVWF  6D
0ACE:  MOVF   61,W
0ACF:  MOVWF  6C
0AD0:  BCF    0A.3
0AD1:  CALL   770
0AD2:  BSF    0A.3
....................       output_bit(PIN_D1,0); 
0AD3:  BCF    08.1
0AD4:  BSF    03.5
0AD5:  BCF    08.1
....................       Delay4us(ChuKy-Ton); 
0AD6:  BCF    03.5
0AD7:  MOVF   61,W
0AD8:  SUBWF  63,W
0AD9:  MOVWF  6A
0ADA:  MOVF   64,W
0ADB:  MOVWF  6B
0ADC:  MOVF   62,W
0ADD:  BTFSS  03.0
0ADE:  INCFSZ 62,W
0ADF:  SUBWF  6B,F
0AE0:  MOVF   6B,W
0AE1:  MOVWF  6D
0AE2:  MOVF   6A,W
0AE3:  MOVWF  6C
0AE4:  BCF    0A.3
0AE5:  CALL   770
0AE6:  BSF    0A.3
....................     } 
....................      if(servo==2) 
0AE7:  MOVF   69,W
0AE8:  SUBLW  02
0AE9:  BTFSS  03.2
0AEA:  GOTO   30A
....................     { 
....................       output_bit(PIN_D0,1); 
0AEB:  BSF    08.0
0AEC:  BSF    03.5
0AED:  BCF    08.0
....................       Delay4us(Ton); 
0AEE:  BCF    03.5
0AEF:  MOVF   62,W
0AF0:  MOVWF  6D
0AF1:  MOVF   61,W
0AF2:  MOVWF  6C
0AF3:  BCF    0A.3
0AF4:  CALL   770
0AF5:  BSF    0A.3
....................       output_bit(PIN_D0,0); 
0AF6:  BCF    08.0
0AF7:  BSF    03.5
0AF8:  BCF    08.0
....................       Delay4us(ChuKy-Ton); 
0AF9:  BCF    03.5
0AFA:  MOVF   61,W
0AFB:  SUBWF  63,W
0AFC:  MOVWF  6A
0AFD:  MOVF   64,W
0AFE:  MOVWF  6B
0AFF:  MOVF   62,W
0B00:  BTFSS  03.0
0B01:  INCFSZ 62,W
0B02:  SUBWF  6B,F
0B03:  MOVF   6B,W
0B04:  MOVWF  6D
0B05:  MOVF   6A,W
0B06:  MOVWF  6C
0B07:  BCF    0A.3
0B08:  CALL   770
0B09:  BSF    0A.3
....................     } 
0B0A:  MOVF   67,W
0B0B:  BTFSC  03.2
0B0C:  DECF   68,F
0B0D:  DECF   67,F
0B0E:  GOTO   2BD
....................    } 
0B0F:  RETURN
.................... } 
....................  
.................... void WriteBack() 
.................... {  
....................    output_bit(PIN_D1,0); 
*
077C:  BCF    08.1
077D:  BSF    03.5
077E:  BCF    08.1
....................    output_bit(PIN_D0,0); 
077F:  BCF    03.5
0780:  BCF    08.0
0781:  BSF    03.5
0782:  BCF    08.0
0783:  BCF    03.5
0784:  RETURN
.................... } 
....................  
.................... #INT_EXT 
.................... void  EXT_isr(void)  
.................... {   
....................    count=count+1.0; 
*
01AE:  BCF    03.1
01AF:  MOVF   54,W
01B0:  BSF    03.5
01B1:  MOVWF  43
01B2:  BCF    03.5
01B3:  MOVF   53,W
01B4:  BSF    03.5
01B5:  MOVWF  42
01B6:  BCF    03.5
01B7:  MOVF   52,W
01B8:  BSF    03.5
01B9:  MOVWF  41
01BA:  BCF    03.5
01BB:  MOVF   51,W
01BC:  BSF    03.5
01BD:  MOVWF  40
01BE:  CLRF   47
01BF:  CLRF   46
01C0:  CLRF   45
01C1:  MOVLW  7F
01C2:  MOVWF  44
01C3:  BCF    03.5
01C4:  CALL   068
01C5:  MOVF   7A,W
01C6:  MOVWF  54
01C7:  MOVF   79,W
01C8:  MOVWF  53
01C9:  MOVF   78,W
01CA:  MOVWF  52
01CB:  MOVF   77,W
01CC:  MOVWF  51
.................... } 
....................  
01CD:  BCF    0B.1
01CE:  BCF    0A.3
01CF:  BCF    0A.4
01D0:  GOTO   03B
.................... #INT_RB 
.................... void Stop() 
.................... { 
....................    if(Input(Pin_B5)==0) 
01D1:  BSF    03.5
01D2:  BSF    06.5
01D3:  BCF    03.5
01D4:  BTFSS  06.5
....................       {   
....................          isFromButtonPressed=0;      
01D5:  CLRF   35
....................       } 
.................... } 
....................  
01D6:  BCF    0B.0
01D7:  BCF    0A.3
01D8:  BCF    0A.4
01D9:  GOTO   03B
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  
.................... {  
....................    switch(color_flag) 
*
0207:  MOVF   4A,W
0208:  ADDLW  FC
0209:  BTFSC  03.0
020A:  GOTO   23F
020B:  ADDLW  04
020C:  GOTO   243
....................       {   
....................       case 0:  
....................               TCS_mode(0,0);               
020D:  BSF    03.5
020E:  CLRF   40
020F:  CLRF   41
0210:  BCF    03.5
0211:  CALL   1DA
....................               break; 
0212:  GOTO   23F
....................       case 1: red_freq=count; 
0213:  MOVF   54,W
0214:  MOVWF  58
0215:  MOVF   53,W
0216:  MOVWF  57
0217:  MOVF   52,W
0218:  MOVWF  56
0219:  MOVF   51,W
021A:  MOVWF  55
....................               TCS_mode(1,1);             
021B:  MOVLW  01
021C:  BSF    03.5
021D:  MOVWF  40
021E:  MOVWF  41
021F:  BCF    03.5
0220:  CALL   1DA
....................               break; 
0221:  GOTO   23F
....................       case 2: green_freq=count; 
0222:  MOVF   54,W
0223:  MOVWF  60
0224:  MOVF   53,W
0225:  MOVWF  5F
0226:  MOVF   52,W
0227:  MOVWF  5E
0228:  MOVF   51,W
0229:  MOVWF  5D
....................               TCS_mode(0,1); 
022A:  BSF    03.5
022B:  CLRF   40
022C:  MOVLW  01
022D:  MOVWF  41
022E:  BCF    03.5
022F:  CALL   1DA
....................               break; 
0230:  GOTO   23F
....................       case 3: blue_freq=count; 
0231:  MOVF   54,W
0232:  MOVWF  5C
0233:  MOVF   53,W
0234:  MOVWF  5B
0235:  MOVF   52,W
0236:  MOVWF  5A
0237:  MOVF   51,W
0238:  MOVWF  59
....................               TCS_mode(1,0); 
0239:  MOVLW  01
023A:  BSF    03.5
023B:  MOVWF  40
023C:  CLRF   41
023D:  BCF    03.5
023E:  CALL   1DA
....................               break; 
....................       } 
.................... } 
023F:  BCF    0C.0
0240:  BCF    0A.3
0241:  BCF    0A.4
0242:  GOTO   03B
.................... #INT_RDA 
.................... void data_rec() 
.................... { 
....................  
....................    memset(&data_received[0],0,sizeof(data_received)); 
*
034D:  MOVLW  38
034E:  MOVWF  04
034F:  BCF    03.7
0350:  CLRF   77
0351:  MOVLW  05
0352:  MOVWF  78
....................    get_data(); 
....................    on_off=atoi(&data_received[0]); 
*
037F:  BSF    03.5
0380:  CLRF   41
0381:  MOVLW  38
0382:  MOVWF  40
0383:  BCF    03.5
0384:  CALL   24B
0385:  MOVF   78,W
0386:  MOVWF  4B
....................    sp_stop=atoi(&data_received[3]); 
0387:  BSF    03.5
0388:  CLRF   41
0389:  MOVLW  3B
038A:  MOVWF  40
038B:  BCF    03.5
038C:  CALL   24B
038D:  MOVF   78,W
038E:  MOVWF  4E
....................    time_stop=atoi(&data_received[4]); 
038F:  BSF    03.5
0390:  CLRF   41
0391:  MOVLW  3C
0392:  MOVWF  40
0393:  BCF    03.5
0394:  CALL   24B
0395:  MOVF   78,W
0396:  MOVWF  4F
....................    switch(data_received[1]) 
0397:  MOVF   39,W
0398:  XORLW  4C
0399:  BTFSC  03.2
039A:  GOTO   3A2
039B:  XORLW  01
039C:  BTFSC  03.2
039D:  GOTO   3A5
039E:  XORLW  05
039F:  BTFSC  03.2
03A0:  GOTO   3A8
03A1:  GOTO   3AA
....................    {   
....................       case 'L' :speed_mode=LOW_;break; 
03A2:  MOVLW  01
03A3:  MOVWF  4C
03A4:  GOTO   3AA
....................       case 'M' :speed_mode=MEDIUM;break; 
03A5:  MOVLW  02
03A6:  MOVWF  4C
03A7:  GOTO   3AA
....................       case 'H' :speed_mode=HIGH_;break; 
03A8:  MOVLW  03
03A9:  MOVWF  4C
....................    } 
....................    switch(data_received[2]) 
03AA:  MOVF   3A,W
03AB:  XORLW  6C
03AC:  BTFSC  03.2
03AD:  GOTO   3B5
03AE:  XORLW  01
03AF:  BTFSC  03.2
03B0:  GOTO   3B8
03B1:  XORLW  05
03B2:  BTFSC  03.2
03B3:  GOTO   3BB
03B4:  GOTO   3BD
....................    {   
....................       case 'l' :freq_mode=LOW_;break; 
03B5:  MOVLW  01
03B6:  MOVWF  4D
03B7:  GOTO   3BD
....................       case 'm' :freq_mode=MEDIUM;break; 
03B8:  MOVLW  02
03B9:  MOVWF  4D
03BA:  GOTO   3BD
....................       case 'h' :freq_mode=HIGH_;break; 
03BB:  MOVLW  03
03BC:  MOVWF  4D
....................    } 
....................  
03BD:  BCF    0C.5
03BE:  BCF    0A.3
03BF:  BCF    0A.4
03C0:  GOTO   03B
.................... } 
.................... unsigned char TCS3200_getcolor() 
.................... { done=0; 
*
064F:  CLRF   36
....................   setup_timer_1(T1_internal | T1_div_by_8); 
0650:  MOVLW  B5
0651:  MOVWF  10
....................   set_timer1(3036); 
0652:  CLRF   0E
0653:  MOVLW  0B
0654:  MOVWF  0F
0655:  MOVLW  DC
0656:  MOVWF  0E
....................    
....................   while(!done){}; 
0657:  MOVF   36,F
0658:  BTFSC  03.2
0659:  GOTO   657
....................            /*red_freq= Map(red_freq,500,1650,0,255); 
....................            blue_freq= Map(blue_freq,600,1600,0,255); 
....................            green_freq= Map(green_freq,400,1000,0,255);*/ 
....................            cycle++;     
065A:  INCF   37,F
....................            sum=red_product+blue_product+green_product; 
065B:  MOVF   47,W
065C:  ADDWF  46,W
065D:  ADDWF  48,W
065E:  MOVWF  49
....................            printf("%d|%d|%d|%d\r\n",red_product,blue_product,green_product,sum); 
065F:  MOVF   46,W
0660:  MOVWF  65
0661:  MOVLW  18
0662:  MOVWF  66
0663:  CALL   5B5
0664:  MOVLW  7C
0665:  BTFSS  0C.4
0666:  GOTO   665
0667:  MOVWF  19
0668:  MOVF   47,W
0669:  MOVWF  65
066A:  MOVLW  18
066B:  MOVWF  66
066C:  CALL   5B5
066D:  MOVLW  7C
066E:  BTFSS  0C.4
066F:  GOTO   66E
0670:  MOVWF  19
0671:  MOVF   48,W
0672:  MOVWF  65
0673:  MOVLW  18
0674:  MOVWF  66
0675:  CALL   5B5
0676:  MOVLW  7C
0677:  BTFSS  0C.4
0678:  GOTO   677
0679:  MOVWF  19
067A:  MOVF   49,W
067B:  MOVWF  65
067C:  MOVLW  18
067D:  MOVWF  66
067E:  CALL   5B5
067F:  MOVLW  0D
0680:  BTFSS  0C.4
0681:  GOTO   680
0682:  MOVWF  19
0683:  MOVLW  0A
0684:  BTFSS  0C.4
0685:  GOTO   684
0686:  MOVWF  19
....................             
....................              
....................   if (((red_freq < 150) && (blue_freq < 150)) || ((green_freq < 150) && (blue_freq < 150)) || ((red_freq < 150) && (green_freq < 150))) 
0687:  MOVF   58,W
0688:  MOVWF  68
0689:  MOVF   57,W
068A:  MOVWF  67
068B:  MOVF   56,W
068C:  MOVWF  66
068D:  MOVF   55,W
068E:  MOVWF  65
068F:  CLRF   6C
0690:  CLRF   6B
0691:  MOVLW  16
0692:  MOVWF  6A
0693:  MOVLW  86
0694:  MOVWF  69
0695:  CALL   610
0696:  BTFSS  03.0
0697:  GOTO   6A9
0698:  MOVF   5C,W
0699:  MOVWF  68
069A:  MOVF   5B,W
069B:  MOVWF  67
069C:  MOVF   5A,W
069D:  MOVWF  66
069E:  MOVF   59,W
069F:  MOVWF  65
06A0:  CLRF   6C
06A1:  CLRF   6B
06A2:  MOVLW  16
06A3:  MOVWF  6A
06A4:  MOVLW  86
06A5:  MOVWF  69
06A6:  CALL   610
06A7:  BTFSC  03.0
06A8:  GOTO   6ED
06A9:  MOVF   60,W
06AA:  MOVWF  68
06AB:  MOVF   5F,W
06AC:  MOVWF  67
06AD:  MOVF   5E,W
06AE:  MOVWF  66
06AF:  MOVF   5D,W
06B0:  MOVWF  65
06B1:  CLRF   6C
06B2:  CLRF   6B
06B3:  MOVLW  16
06B4:  MOVWF  6A
06B5:  MOVLW  86
06B6:  MOVWF  69
06B7:  CALL   610
06B8:  BTFSS  03.0
06B9:  GOTO   6CB
06BA:  MOVF   5C,W
06BB:  MOVWF  68
06BC:  MOVF   5B,W
06BD:  MOVWF  67
06BE:  MOVF   5A,W
06BF:  MOVWF  66
06C0:  MOVF   59,W
06C1:  MOVWF  65
06C2:  CLRF   6C
06C3:  CLRF   6B
06C4:  MOVLW  16
06C5:  MOVWF  6A
06C6:  MOVLW  86
06C7:  MOVWF  69
06C8:  CALL   610
06C9:  BTFSC  03.0
06CA:  GOTO   6ED
06CB:  MOVF   58,W
06CC:  MOVWF  68
06CD:  MOVF   57,W
06CE:  MOVWF  67
06CF:  MOVF   56,W
06D0:  MOVWF  66
06D1:  MOVF   55,W
06D2:  MOVWF  65
06D3:  CLRF   6C
06D4:  CLRF   6B
06D5:  MOVLW  16
06D6:  MOVWF  6A
06D7:  MOVLW  86
06D8:  MOVWF  69
06D9:  CALL   610
06DA:  BTFSS  03.0
06DB:  GOTO   6F1
06DC:  MOVF   60,W
06DD:  MOVWF  68
06DE:  MOVF   5F,W
06DF:  MOVWF  67
06E0:  MOVF   5E,W
06E1:  MOVWF  66
06E2:  MOVF   5D,W
06E3:  MOVWF  65
06E4:  CLRF   6C
06E5:  CLRF   6B
06E6:  MOVLW  16
06E7:  MOVWF  6A
06E8:  MOVLW  86
06E9:  MOVWF  69
06EA:  CALL   610
06EB:  BTFSS  03.0
06EC:  GOTO   6F1
....................         return UNIDENTIFIED; 
06ED:  MOVLW  00
06EE:  MOVWF  78
06EF:  GOTO   76D
06F0:  GOTO   76D
....................   else 
....................     { 
....................         if ((red_freq > blue_freq) && (red_freq > green_freq)) 
06F1:  MOVF   5C,W
06F2:  MOVWF  68
06F3:  MOVF   5B,W
06F4:  MOVWF  67
06F5:  MOVF   5A,W
06F6:  MOVWF  66
06F7:  MOVF   59,W
06F8:  MOVWF  65
06F9:  MOVF   58,W
06FA:  MOVWF  6C
06FB:  MOVF   57,W
06FC:  MOVWF  6B
06FD:  MOVF   56,W
06FE:  MOVWF  6A
06FF:  MOVF   55,W
0700:  MOVWF  69
0701:  CALL   610
0702:  BTFSS  03.0
0703:  GOTO   71B
0704:  MOVF   60,W
0705:  MOVWF  68
0706:  MOVF   5F,W
0707:  MOVWF  67
0708:  MOVF   5E,W
0709:  MOVWF  66
070A:  MOVF   5D,W
070B:  MOVWF  65
070C:  MOVF   58,W
070D:  MOVWF  6C
070E:  MOVF   57,W
070F:  MOVWF  6B
0710:  MOVF   56,W
0711:  MOVWF  6A
0712:  MOVF   55,W
0713:  MOVWF  69
0714:  CALL   610
0715:  BTFSS  03.0
0716:  GOTO   71B
....................             return COLOR_RED; 
0717:  MOVLW  01
0718:  MOVWF  78
0719:  GOTO   76D
071A:  GOTO   76D
....................         else if ((blue_freq > red_freq) && (blue_freq > green_freq)) 
071B:  MOVF   58,W
071C:  MOVWF  68
071D:  MOVF   57,W
071E:  MOVWF  67
071F:  MOVF   56,W
0720:  MOVWF  66
0721:  MOVF   55,W
0722:  MOVWF  65
0723:  MOVF   5C,W
0724:  MOVWF  6C
0725:  MOVF   5B,W
0726:  MOVWF  6B
0727:  MOVF   5A,W
0728:  MOVWF  6A
0729:  MOVF   59,W
072A:  MOVWF  69
072B:  CALL   610
072C:  BTFSS  03.0
072D:  GOTO   745
072E:  MOVF   60,W
072F:  MOVWF  68
0730:  MOVF   5F,W
0731:  MOVWF  67
0732:  MOVF   5E,W
0733:  MOVWF  66
0734:  MOVF   5D,W
0735:  MOVWF  65
0736:  MOVF   5C,W
0737:  MOVWF  6C
0738:  MOVF   5B,W
0739:  MOVWF  6B
073A:  MOVF   5A,W
073B:  MOVWF  6A
073C:  MOVF   59,W
073D:  MOVWF  69
073E:  CALL   610
073F:  BTFSS  03.0
0740:  GOTO   745
....................             return COLOR_BLUE; 
0741:  MOVLW  02
0742:  MOVWF  78
0743:  GOTO   76D
0744:  GOTO   76D
....................         else if ((green_freq > red_freq) && (green_freq > blue_freq)) 
0745:  MOVF   58,W
0746:  MOVWF  68
0747:  MOVF   57,W
0748:  MOVWF  67
0749:  MOVF   56,W
074A:  MOVWF  66
074B:  MOVF   55,W
074C:  MOVWF  65
074D:  MOVF   60,W
074E:  MOVWF  6C
074F:  MOVF   5F,W
0750:  MOVWF  6B
0751:  MOVF   5E,W
0752:  MOVWF  6A
0753:  MOVF   5D,W
0754:  MOVWF  69
0755:  CALL   610
0756:  BTFSS  03.0
0757:  GOTO   76D
0758:  MOVF   5C,W
0759:  MOVWF  68
075A:  MOVF   5B,W
075B:  MOVWF  67
075C:  MOVF   5A,W
075D:  MOVWF  66
075E:  MOVF   59,W
075F:  MOVWF  65
0760:  MOVF   60,W
0761:  MOVWF  6C
0762:  MOVF   5F,W
0763:  MOVWF  6B
0764:  MOVF   5E,W
0765:  MOVWF  6A
0766:  MOVF   5D,W
0767:  MOVWF  69
0768:  CALL   610
0769:  BTFSS  03.0
076A:  GOTO   76D
....................             return COLOR_GREEN; 
076B:  MOVLW  03
076C:  MOVWF  78
....................     }     
076D:  BSF    0A.3
076E:  BCF    0A.4
076F:  GOTO   3CA (RETURN)
.................... } 
....................  
.................... void main() 
*
0B10:  MOVF   03,W
0B11:  ANDLW  1F
0B12:  MOVWF  03
0B13:  MOVLW  81
0B14:  BSF    03.5
0B15:  MOVWF  19
0B16:  MOVLW  A6
0B17:  MOVWF  18
0B18:  MOVLW  90
0B19:  BCF    03.5
0B1A:  MOVWF  18
0B1B:  MOVLW  FF
0B1C:  MOVWF  32
0B1D:  CLRF   33
0B1E:  CLRF   34
0B1F:  CLRF   35
0B20:  CLRF   36
0B21:  CLRF   41
0B22:  CLRF   42
0B23:  CLRF   43
0B24:  CLRF   44
0B25:  CLRF   45
0B26:  CLRF   46
0B27:  CLRF   47
0B28:  CLRF   48
0B29:  MOVLW  27
0B2A:  MOVWF  64
0B2B:  MOVLW  10
0B2C:  MOVWF  63
0B2D:  BSF    03.5
0B2E:  BSF    1F.0
0B2F:  BSF    1F.1
0B30:  BSF    1F.2
0B31:  BCF    1F.3
0B32:  MOVLW  07
0B33:  MOVWF  1C
0B34:  BCF    03.7
....................  
.................... {  port_b_pullups(true); 
*
0B48:  BSF    03.5
0B49:  BCF    01.7
....................    lcd_init();  
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  GOTO   4C0
0B4D:  BSF    0A.3
....................    enable_interrupts(INT_EXT); 
0B4E:  BSF    0B.4
....................    enable_interrupts(INT_rb); 
0B4F:  BSF    0B.3
....................    enable_interrupts(INT_RDA); 
0B50:  BSF    03.5
0B51:  BSF    0C.5
....................    enable_interrupts(INT_TIMER1); 
0B52:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0B53:  MOVLW  C0
0B54:  BCF    03.5
0B55:  IORWF  0B,F
....................    set_tris_b(0x31); 
0B56:  MOVLW  31
0B57:  BSF    03.5
0B58:  MOVWF  06
....................  
.................... while (1){ 
....................     
....................       if(Input(Pin_B4)==0) 
0B59:  BSF    06.4
0B5A:  BCF    03.5
0B5B:  BTFSC  06.4
0B5C:  GOTO   35F
....................       {       
....................          isFromButtonPressed=1;      
0B5D:  MOVLW  01
0B5E:  MOVWF  35
....................       }      
....................       
....................       if ((on_off==ON_) && !is_running)         
0B5F:  DECFSZ 4B,W
0B60:  GOTO   390
0B61:  MOVF   50,F
0B62:  BTFSS  03.2
0B63:  GOTO   390
....................           { is_running=1; 
0B64:  MOVLW  01
0B65:  MOVWF  50
....................              count_enable = 1; 
0B66:  MOVWF  34
....................              switch(freq_mode) 
0B67:  MOVF   4D,W
0B68:  XORLW  01
0B69:  BTFSC  03.2
0B6A:  GOTO   372
0B6B:  XORLW  03
0B6C:  BTFSC  03.2
0B6D:  GOTO   37C
0B6E:  XORLW  01
0B6F:  BTFSC  03.2
0B70:  GOTO   386
0B71:  GOTO   38F
....................              { 
....................              case LOW_: output_low(S_0); 
0B72:  MOVLW  E0
0B73:  BSF    03.5
0B74:  MOVWF  05
0B75:  BCF    03.5
0B76:  BCF    05.0
....................                         output_high(S_1); 
0B77:  BSF    03.5
0B78:  MOVWF  05
0B79:  BCF    03.5
0B7A:  BSF    05.1
....................                         break; 
0B7B:  GOTO   38F
....................              case MEDIUM: output_low(S_1); 
0B7C:  MOVLW  E0
0B7D:  BSF    03.5
0B7E:  MOVWF  05
0B7F:  BCF    03.5
0B80:  BCF    05.1
....................                           output_high(S_0); 
0B81:  BSF    03.5
0B82:  MOVWF  05
0B83:  BCF    03.5
0B84:  BSF    05.0
....................                         break; 
0B85:  GOTO   38F
....................              case HIGH_: output_high(S_0); 
0B86:  MOVLW  E0
0B87:  BSF    03.5
0B88:  MOVWF  05
0B89:  BCF    03.5
0B8A:  BSF    05.0
....................                         output_high(S_1); 
0B8B:  BSF    03.5
0B8C:  MOVWF  05
0B8D:  BCF    03.5
0B8E:  BSF    05.1
....................                         break;  
....................              }          
....................           } 
0B8F:  GOTO   3C5
....................                      
....................       else if ((on_off==OFF_)&&is_running) 
0B90:  MOVF   4B,F
0B91:  BTFSS  03.2
0B92:  GOTO   3C5
0B93:  MOVF   50,F
0B94:  BTFSC  03.2
0B95:  GOTO   3C5
....................       {     is_running=0; 
0B96:  CLRF   50
....................             count_enable = 0; 
0B97:  CLRF   34
....................             color_count = red_count = blue_count = green_count = blind_count = 0; 
0B98:  CLRF   45
0B99:  MOVF   45,W
0B9A:  MOVWF  44
0B9B:  MOVWF  43
0B9C:  MOVWF  42
0B9D:  MOVWF  41
....................             red_product = blue_product = green_product = 0; 
0B9E:  CLRF   48
0B9F:  MOVF   48,W
0BA0:  MOVWF  47
0BA1:  MOVWF  46
....................             has_product = 0; 
0BA2:  CLRF   33
....................             {  
....................                lcd_putc("\f"); 
0BA3:  MOVLW  C1
0BA4:  BSF    03.6
0BA5:  MOVWF  0D
0BA6:  MOVLW  03
0BA7:  MOVWF  0F
0BA8:  BCF    0A.3
0BA9:  BCF    03.6
0BAA:  CALL   54A
0BAB:  BSF    0A.3
....................                lcd_gotoxy(5,1); 
0BAC:  MOVLW  05
0BAD:  MOVWF  69
0BAE:  MOVLW  01
0BAF:  MOVWF  6A
0BB0:  BCF    0A.3
0BB1:  CALL   50C
0BB2:  BSF    0A.3
....................                printf(lcd_putc,"STOPP !!!"); 
0BB3:  MOVLW  C2
0BB4:  BSF    03.6
0BB5:  MOVWF  0D
0BB6:  MOVLW  03
0BB7:  MOVWF  0F
0BB8:  BCF    0A.3
0BB9:  BCF    03.6
0BBA:  CALL   54A
0BBB:  BSF    0A.3
....................                delay_ms(500); 
0BBC:  MOVLW  02
0BBD:  MOVWF  65
0BBE:  MOVLW  FA
0BBF:  MOVWF  6A
0BC0:  BCF    0A.3
0BC1:  CALL   3DF
0BC2:  BSF    0A.3
0BC3:  DECFSZ 65,F
0BC4:  GOTO   3BE
....................             } 
....................       } 
....................        
....................       if (count_enable) 
0BC5:  MOVF   34,F
0BC6:  BTFSC  03.2
0BC7:  GOTO   4BA
....................       {             
....................             switch(TCS3200_getColor()) 
0BC8:  BCF    0A.3
0BC9:  GOTO   64F
0BCA:  BSF    0A.3
0BCB:  MOVF   78,W
0BCC:  ADDLW  FC
0BCD:  BTFSC  03.0
0BCE:  GOTO   3D8
0BCF:  ADDLW  04
0BD0:  GOTO   4DC
....................             { 
....................             case COLOR_RED : 
....................                 red_count++; 
0BD1:  INCF   42,F
....................                 break; 
0BD2:  GOTO   3D8
....................             case COLOR_BLUE : 
....................                 blue_count++; 
0BD3:  INCF   43,F
....................                 break; 
0BD4:  GOTO   3D8
....................             case COLOR_GREEN : 
....................                 green_count++; 
0BD5:  INCF   44,F
....................                 break; 
0BD6:  GOTO   3D8
....................             case UNIDENTIFIED : 
....................                 blind_count++; 
0BD7:  INCF   45,F
....................                 break; 
....................             } 
....................          
....................             color_count++; 
0BD8:  INCF   41,F
.................... //!                        lcd_putc("\f"); 
.................... //!                        lcd_gotoxy(7,2); 
.................... //!                        lcd_putc(red_count+0x30);        
.................... //!                        lcd_gotoxy(1,2); 
.................... //!                        lcd_putc(has_product+0x30);      
....................             if (color_count >= COLOR_COUNT_MAX) 
0BD9:  MOVF   41,W
0BDA:  SUBLW  03
0BDB:  BTFSC  03.0
0BDC:  GOTO   432
....................             { 
....................                 color_count = 0; 
0BDD:  CLRF   41
....................                  
....................                 if (!has_product) 
0BDE:  MOVF   33,F
0BDF:  BTFSS  03.2
0BE0:  GOTO   421
....................                 {             
....................                     if ((red_count > blue_count) && (red_count > green_count) && (red_count > blind_count)) 
0BE1:  MOVF   42,W
0BE2:  SUBWF  43,W
0BE3:  BTFSC  03.0
0BE4:  GOTO   3F2
0BE5:  MOVF   42,W
0BE6:  SUBWF  44,W
0BE7:  BTFSC  03.0
0BE8:  GOTO   3F2
0BE9:  MOVF   42,W
0BEA:  SUBWF  45,W
0BEB:  BTFSC  03.0
0BEC:  GOTO   3F2
....................                      {  
....................                       
....................                         red_product++; 
0BED:  INCF   46,F
....................                         has_product = 1; 
0BEE:  MOVLW  01
0BEF:  MOVWF  33
....................                         has_red=1; 
0BF0:  MOVWF  3E
....................                     }                  
0BF1:  GOTO   420
....................                     else if ((blue_count > red_count) && (blue_count > green_count) && (blue_count > blind_count)) 
0BF2:  MOVF   43,W
0BF3:  SUBWF  42,W
0BF4:  BTFSC  03.0
0BF5:  GOTO   403
0BF6:  MOVF   43,W
0BF7:  SUBWF  44,W
0BF8:  BTFSC  03.0
0BF9:  GOTO   403
0BFA:  MOVF   43,W
0BFB:  SUBWF  45,W
0BFC:  BTFSC  03.0
0BFD:  GOTO   403
....................                     { 
....................  
....................                         blue_product++; 
0BFE:  INCF   47,F
....................                         has_product = 1; 
0BFF:  MOVLW  01
0C00:  MOVWF  33
....................                         has_blue=1; 
0C01:  MOVWF  3F
....................                     } 
0C02:  GOTO   420
....................                     else if ((green_count > red_count) && (green_count > blue_count) && (green_count > blind_count)) 
0C03:  MOVF   44,W
0C04:  SUBWF  42,W
0C05:  BTFSC  03.0
0C06:  GOTO   414
0C07:  MOVF   44,W
0C08:  SUBWF  43,W
0C09:  BTFSC  03.0
0C0A:  GOTO   414
0C0B:  MOVF   44,W
0C0C:  SUBWF  45,W
0C0D:  BTFSC  03.0
0C0E:  GOTO   414
....................                     { 
....................  
....................                         green_product++; 
0C0F:  INCF   48,F
....................                         has_product = 1; 
0C10:  MOVLW  01
0C11:  MOVWF  33
....................                         has_green=1; 
0C12:  MOVWF  40
....................                     } 
0C13:  GOTO   420
....................                     else if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0C14:  MOVF   45,W
0C15:  SUBWF  42,W
0C16:  BTFSC  03.0
0C17:  GOTO   420
0C18:  MOVF   45,W
0C19:  SUBWF  44,W
0C1A:  BTFSC  03.0
0C1B:  GOTO   420
0C1C:  MOVF   45,W
0C1D:  SUBWF  43,W
0C1E:  BTFSC  03.0
0C1F:  GOTO   420
....................                     { 
....................  
....................                     } 
....................                 } 
0C20:  GOTO   42D
....................                 else 
....................                 { 
....................                     if ((blind_count > red_count) && (blind_count > green_count) && (blind_count > blue_count)) 
0C21:  MOVF   45,W
0C22:  SUBWF  42,W
0C23:  BTFSC  03.0
0C24:  GOTO   42D
0C25:  MOVF   45,W
0C26:  SUBWF  44,W
0C27:  BTFSC  03.0
0C28:  GOTO   42D
0C29:  MOVF   45,W
0C2A:  SUBWF  43,W
0C2B:  BTFSS  03.0
....................                         has_product = 0; 
0C2C:  CLRF   33
....................                         
....................                 } 
....................                              
....................                 red_count = blue_count = green_count = blind_count = 0; 
0C2D:  CLRF   45
0C2E:  MOVF   45,W
0C2F:  MOVWF  44
0C30:  MOVWF  43
0C31:  MOVWF  42
....................                 
....................             } 
....................         
....................             lcd_putc("\f"); 
0C32:  MOVLW  C7
0C33:  BSF    03.6
0C34:  MOVWF  0D
0C35:  MOVLW  03
0C36:  MOVWF  0F
0C37:  BCF    0A.3
0C38:  BCF    03.6
0C39:  CALL   54A
0C3A:  BSF    0A.3
....................             lcd_putc("RD   BL  GR "); 
0C3B:  MOVLW  C8
0C3C:  BSF    03.6
0C3D:  MOVWF  0D
0C3E:  MOVLW  03
0C3F:  MOVWF  0F
0C40:  BCF    0A.3
0C41:  BCF    03.6
0C42:  CALL   54A
0C43:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
0C44:  MOVLW  01
0C45:  MOVWF  69
0C46:  MOVLW  02
0C47:  MOVWF  6A
0C48:  BCF    0A.3
0C49:  CALL   50C
0C4A:  BSF    0A.3
....................             lcd_putc(red_product+0x30); 
0C4B:  MOVLW  30
0C4C:  ADDWF  46,W
0C4D:  MOVWF  65
0C4E:  MOVWF  68
0C4F:  BCF    0A.3
0C50:  CALL   51E
0C51:  BSF    0A.3
....................             lcd_gotoxy(5,2); 
0C52:  MOVLW  05
0C53:  MOVWF  69
0C54:  MOVLW  02
0C55:  MOVWF  6A
0C56:  BCF    0A.3
0C57:  CALL   50C
0C58:  BSF    0A.3
....................             lcd_putc(blue_product+0x30); 
0C59:  MOVLW  30
0C5A:  ADDWF  47,W
0C5B:  MOVWF  65
0C5C:  MOVWF  68
0C5D:  BCF    0A.3
0C5E:  CALL   51E
0C5F:  BSF    0A.3
....................             lcd_gotoxy(9,2); 
0C60:  MOVLW  09
0C61:  MOVWF  69
0C62:  MOVLW  02
0C63:  MOVWF  6A
0C64:  BCF    0A.3
0C65:  CALL   50C
0C66:  BSF    0A.3
....................             lcd_putc(green_product+0x30);  
0C67:  MOVLW  30
0C68:  ADDWF  48,W
0C69:  MOVWF  65
0C6A:  MOVWF  68
0C6B:  BCF    0A.3
0C6C:  CALL   51E
0C6D:  BSF    0A.3
....................             lcd_gotoxy(4,1); 
0C6E:  MOVLW  04
0C6F:  MOVWF  69
0C70:  MOVLW  01
0C71:  MOVWF  6A
0C72:  BCF    0A.3
0C73:  CALL   50C
0C74:  BSF    0A.3
....................             lcd_putc(input_state(pin_C2)+0x30); 
0C75:  MOVLW  00
0C76:  BTFSC  07.2
0C77:  MOVLW  01
0C78:  ADDLW  30
0C79:  MOVWF  65
0C7A:  MOVWF  68
0C7B:  BCF    0A.3
0C7C:  CALL   51E
0C7D:  BSF    0A.3
....................            if(has_red) 
0C7E:  MOVF   3E,F
0C7F:  BTFSC  03.2
0C80:  GOTO   49A
....................             { 
....................               if(!input_state(pin_E0)) 
0C81:  BTFSC  09.0
0C82:  GOTO   49A
....................              {//servo1  
....................                Write(120,1000,1); 
0C83:  CLRF   66
0C84:  MOVLW  78
0C85:  MOVWF  65
0C86:  MOVLW  03
0C87:  MOVWF  68
0C88:  MOVLW  E8
0C89:  MOVWF  67
0C8A:  MOVLW  01
0C8B:  MOVWF  69
0C8C:  CALL   000
....................                Write(0,1000,1); 
0C8D:  CLRF   66
0C8E:  CLRF   65
0C8F:  MOVLW  03
0C90:  MOVWF  68
0C91:  MOVLW  E8
0C92:  MOVWF  67
0C93:  MOVLW  01
0C94:  MOVWF  69
0C95:  CALL   000
....................                WriteBack();                 
0C96:  BCF    0A.3
0C97:  CALL   77C
0C98:  BSF    0A.3
....................                has_red=0; 
0C99:  CLRF   3E
....................  
....................              } 
....................                 
....................             } 
....................              
....................             if(has_blue) 
0C9A:  MOVF   3F,F
0C9B:  BTFSC  03.2
0C9C:  GOTO   4B6
....................              {  
....................              if(!input_state(pin_C2)){has_blue=0;} 
0C9D:  BTFSS  07.2
0C9E:  CLRF   3F
....................               //Oservo2 
....................               { 
....................                Write(120,1000,2); 
0C9F:  CLRF   66
0CA0:  MOVLW  78
0CA1:  MOVWF  65
0CA2:  MOVLW  03
0CA3:  MOVWF  68
0CA4:  MOVLW  E8
0CA5:  MOVWF  67
0CA6:  MOVLW  02
0CA7:  MOVWF  69
0CA8:  CALL   000
....................                Write(0,1000,2); 
0CA9:  CLRF   66
0CAA:  CLRF   65
0CAB:  MOVLW  03
0CAC:  MOVWF  68
0CAD:  MOVLW  E8
0CAE:  MOVWF  67
0CAF:  MOVLW  02
0CB0:  MOVWF  69
0CB1:  CALL   000
....................                WriteBack();                 
0CB2:  BCF    0A.3
0CB3:  CALL   77C
0CB4:  BSF    0A.3
....................                has_blue=0; 
0CB5:  CLRF   3F
....................               } 
....................              } 
....................              if(has_green) 
0CB6:  MOVF   40,F
0CB7:  BTFSS  03.2
....................              { 
....................                has_green=0; 
0CB8:  CLRF   40
....................              } 
....................                       
....................      //LCD 
....................       } 
0CB9:  GOTO   4D9
....................       else 
....................       {      
....................             lcd_gotoxy(1,1); 
0CBA:  MOVLW  01
0CBB:  MOVWF  69
0CBC:  MOVWF  6A
0CBD:  BCF    0A.3
0CBE:  CALL   50C
0CBF:  BSF    0A.3
....................             lcd_putc("    MACH DEM SP"); 
0CC0:  MOVLW  CF
0CC1:  BSF    03.6
0CC2:  MOVWF  0D
0CC3:  MOVLW  03
0CC4:  MOVWF  0F
0CC5:  BCF    0A.3
0CC6:  BCF    03.6
0CC7:  CALL   54A
0CC8:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
0CC9:  MOVLW  01
0CCA:  MOVWF  69
0CCB:  MOVLW  02
0CCC:  MOVWF  6A
0CCD:  BCF    0A.3
0CCE:  CALL   50C
0CCF:  BSF    0A.3
....................             lcd_putc("  CAM BIEN MAU"); 
0CD0:  MOVLW  D7
0CD1:  BSF    03.6
0CD2:  MOVWF  0D
0CD3:  MOVLW  03
0CD4:  MOVWF  0F
0CD5:  BCF    0A.3
0CD6:  BCF    03.6
0CD7:  CALL   54A
0CD8:  BSF    0A.3
....................       } 
0CD9:  BSF    03.5
0CDA:  GOTO   359
....................        
.................... } 
....................  
.................... } 
0CDB:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
